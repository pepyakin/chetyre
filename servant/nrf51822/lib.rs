# ! [ doc = "Peripheral access API for NRF51 microcontrollers (generated using svd2rust v0.14.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.14.0/svd2rust/#peripheral-api" ] # ! [ deny ( missing_docs ) ] # ! [ deny ( warnings ) ] # ! [ allow ( non_camel_case_types ) ] # ! [ no_std ] extern crate cortex_m ; # [ cfg ( feature = "rt" ) ] extern crate cortex_m_rt ; extern crate bare_metal ; extern crate vcell ; use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [ doc = r" Number available in the NVIC for configuring priority" ] pub const NVIC_PRIO_BITS : u8 = 2 ; # [ cfg ( feature = "rt" ) ] extern "C" { fn POWER_CLOCK ( ) ; fn RADIO ( ) ; fn UART0 ( ) ; fn SPI0_TWI0 ( ) ; fn SPI1_TWI1 ( ) ; fn GPIOTE ( ) ; fn ADC ( ) ; fn TIMER0 ( ) ; fn TIMER1 ( ) ; fn TIMER2 ( ) ; fn RTC0 ( ) ; fn TEMP ( ) ; fn RNG ( ) ; fn ECB ( ) ; fn CCM_AAR ( ) ; fn WDT ( ) ; fn RTC1 ( ) ; fn QDEC ( ) ; fn WUCOMP_COMP ( ) ; fn SWI0 ( ) ; fn SWI1 ( ) ; fn SWI2 ( ) ; fn SWI3 ( ) ; fn SWI4 ( ) ; fn SWI5 ( ) ; } # [ doc ( hidden ) ] pub union Vector { _handler : unsafe extern "C" fn ( ) , _reserved : u32 , } # [ cfg ( feature = "rt" ) ] # [ doc ( hidden ) ] # [ link_section = ".vector_table.interrupts" ] # [ no_mangle ] pub static __INTERRUPTS : [ Vector ; 26 ] = [ Vector { _handler : POWER_CLOCK } , Vector { _handler : RADIO } , Vector { _handler : UART0 } , Vector { _handler : SPI0_TWI0 } , Vector { _handler : SPI1_TWI1 } , Vector { _reserved : 0 } , Vector { _handler : GPIOTE } , Vector { _handler : ADC } , Vector { _handler : TIMER0 } , Vector { _handler : TIMER1 } , Vector { _handler : TIMER2 } , Vector { _handler : RTC0 } , Vector { _handler : TEMP } , Vector { _handler : RNG } , Vector { _handler : ECB } , Vector { _handler : CCM_AAR } , Vector { _handler : WDT } , Vector { _handler : RTC1 } , Vector { _handler : QDEC } , Vector { _handler : WUCOMP_COMP } , Vector { _handler : SWI0 } , Vector { _handler : SWI1 } , Vector { _handler : SWI2 } , Vector { _handler : SWI3 } , Vector { _handler : SWI4 } , Vector { _handler : SWI5 } , ] ; # [ doc = r" Enumeration of all the interrupts" ] pub enum Interrupt { # [ doc = "0 - POWER_CLOCK" ] POWER_CLOCK , # [ doc = "1 - RADIO" ] RADIO , # [ doc = "2 - UART0" ] UART0 , # [ doc = "3 - SPI0_TWI0" ] SPI0_TWI0 , # [ doc = "4 - SPI1_TWI1" ] SPI1_TWI1 , # [ doc = "6 - GPIOTE" ] GPIOTE , # [ doc = "7 - ADC" ] ADC , # [ doc = "8 - TIMER0" ] TIMER0 , # [ doc = "9 - TIMER1" ] TIMER1 , # [ doc = "10 - TIMER2" ] TIMER2 , # [ doc = "11 - RTC0" ] RTC0 , # [ doc = "12 - TEMP" ] TEMP , # [ doc = "13 - RNG" ] RNG , # [ doc = "14 - ECB" ] ECB , # [ doc = "15 - CCM_AAR" ] CCM_AAR , # [ doc = "16 - WDT" ] WDT , # [ doc = "17 - RTC1" ] RTC1 , # [ doc = "18 - QDEC" ] QDEC , # [ doc = "19 - WUCOMP_COMP" ] WUCOMP_COMP , # [ doc = "20 - SWI0" ] SWI0 , # [ doc = "21 - SWI1" ] SWI1 , # [ doc = "22 - SWI2" ] SWI2 , # [ doc = "23 - SWI3" ] SWI3 , # [ doc = "24 - SWI4" ] SWI4 , # [ doc = "25 - SWI5" ] SWI5 , } unsafe impl :: bare_metal :: Nr for Interrupt { # [ inline ] fn nr ( & self ) -> u8 { match * self { Interrupt :: POWER_CLOCK => 0 , Interrupt :: RADIO => 1 , Interrupt :: UART0 => 2 , Interrupt :: SPI0_TWI0 => 3 , Interrupt :: SPI1_TWI1 => 4 , Interrupt :: GPIOTE => 6 , Interrupt :: ADC => 7 , Interrupt :: TIMER0 => 8 , Interrupt :: TIMER1 => 9 , Interrupt :: TIMER2 => 10 , Interrupt :: RTC0 => 11 , Interrupt :: TEMP => 12 , Interrupt :: RNG => 13 , Interrupt :: ECB => 14 , Interrupt :: CCM_AAR => 15 , Interrupt :: WDT => 16 , Interrupt :: RTC1 => 17 , Interrupt :: QDEC => 18 , Interrupt :: WUCOMP_COMP => 19 , Interrupt :: SWI0 => 20 , Interrupt :: SWI1 => 21 , Interrupt :: SWI2 => 22 , Interrupt :: SWI3 => 23 , Interrupt :: SWI4 => 24 , Interrupt :: SWI5 => 25 , } } } pub use cortex_m :: peripheral :: Peripherals as CorePeripherals ; # [ cfg ( feature = "rt" ) ] pub use cortex_m_rt :: interrupt ; # [ cfg ( feature = "rt" ) ] pub use self :: Interrupt as interrupt ; pub use cortex_m :: peripheral :: { CBP , CPUID , DCB , DWT , FPB , ITM , MPU , NVIC , SCB , SYST , TPIU , } ; # [ doc = "Power Control." ] pub struct POWER { _marker : PhantomData < * const ( ) > } unsafe impl Send for POWER { } impl POWER { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const power :: RegisterBlock { 0x4000_0000 as * const _ } } impl Deref for POWER { type Target = power :: RegisterBlock ; fn deref ( & self ) -> & power :: RegisterBlock { unsafe { & * POWER :: ptr ( ) } } } # [ doc = "Power Control." ] pub mod power { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 120usize ] , # [ doc = "0x78 - Enable constant latency mode." ] pub tasks_constlat : TASKS_CONSTLAT , # [ doc = "0x7c - Enable low power mode (variable latency)." ] pub tasks_lowpwr : TASKS_LOWPWR , _reserved1 : [ u8 ; 136usize ] , # [ doc = "0x108 - Power failure warning." ] pub events_pofwarn : EVENTS_POFWARN , _reserved2 : [ u8 ; 504usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 244usize ] , # [ doc = "0x400 - Reset reason." ] pub resetreas : RESETREAS , _reserved4 : [ u8 ; 252usize ] , # [ doc = "0x500 - System off register." ] pub systemoff : SYSTEMOFF , _reserved5 : [ u8 ; 12usize ] , # [ doc = "0x510 - Power failure configuration." ] pub pofcon : POFCON , _reserved6 : [ u8 ; 8usize ] , # [ doc = "0x51c - General purpose retention register. This register is a retained register." ] pub gpregret : GPREGRET , _reserved7 : [ u8 ; 4usize ] , # [ doc = "0x524 - Ram on/off." ] pub ramon : RAMON , _reserved8 : [ u8 ; 28usize ] , # [ doc = "0x544 - Pin reset functionality configuration register. This register is a retained register." ] pub reset : RESET , _reserved9 : [ u8 ; 48usize ] , # [ doc = "0x578 - DCDC converter enable configuration register." ] pub dcdcen : DCDCEN , } # [ doc = "Enable constant latency mode." ] pub struct TASKS_CONSTLAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable constant latency mode." ] pub mod tasks_constlat { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_CONSTLAT { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Enable low power mode (variable latency)." ] pub struct TASKS_LOWPWR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable low power mode (variable latency)." ] pub mod tasks_lowpwr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_LOWPWR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Power failure warning." ] pub struct EVENTS_POFWARN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Power failure warning." ] pub mod events_pofwarn { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_POFWARN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `POFWARN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum POFWARNR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl POFWARNR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { POFWARNR :: DISABLED => false , POFWARNR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> POFWARNR { match value { false => POFWARNR :: DISABLED , true => POFWARNR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == POFWARNR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == POFWARNR :: ENABLED } } # [ doc = "Values that can be written to the field `POFWARN`" ] pub enum POFWARNW { # [ doc = "Enable interrupt on write." ] SET } impl POFWARNW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { POFWARNW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _POFWARNW < 'a > { w : & 'a mut W , } impl < 'a > _POFWARNW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : POFWARNW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( POFWARNW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 2 - Enable interrupt on POFWARN event." ] # [ inline ] pub fn pofwarn ( & self ) -> POFWARNR { POFWARNR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Enable interrupt on POFWARN event." ] # [ inline ] pub fn pofwarn ( & mut self ) -> _POFWARNW { _POFWARNW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `POFWARN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum POFWARNR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl POFWARNR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { POFWARNR :: DISABLED => false , POFWARNR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> POFWARNR { match value { false => POFWARNR :: DISABLED , true => POFWARNR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == POFWARNR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == POFWARNR :: ENABLED } } # [ doc = "Values that can be written to the field `POFWARN`" ] pub enum POFWARNW { # [ doc = "Disable interrupt on write." ] CLEAR } impl POFWARNW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { POFWARNW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _POFWARNW < 'a > { w : & 'a mut W , } impl < 'a > _POFWARNW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : POFWARNW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( POFWARNW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 2 - Disable interrupt on POFWARN event." ] # [ inline ] pub fn pofwarn ( & self ) -> POFWARNR { POFWARNR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Disable interrupt on POFWARN event." ] # [ inline ] pub fn pofwarn ( & mut self ) -> _POFWARNW { _POFWARNW { w : self } } } } # [ doc = "Reset reason." ] pub struct RESETREAS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Reset reason." ] pub mod resetreas { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RESETREAS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct RESETPINR { bits : bool , } impl RESETPINR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DOGR { bits : bool , } impl DOGR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct SREQR { bits : bool , } impl SREQR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct LOCKUPR { bits : bool , } impl LOCKUPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct OFFR { bits : bool , } impl OFFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct WUCOMPR { bits : bool , } impl WUCOMPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct DIFR { bits : bool , } impl DIFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Proxy" ] pub struct _RESETPINW < 'a > { w : & 'a mut W , } impl < 'a > _RESETPINW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DOGW < 'a > { w : & 'a mut W , } impl < 'a > _DOGW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _SREQW < 'a > { w : & 'a mut W , } impl < 'a > _SREQW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _LOCKUPW < 'a > { w : & 'a mut W , } impl < 'a > _LOCKUPW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _OFFW < 'a > { w : & 'a mut W , } impl < 'a > _OFFW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _WUCOMPW < 'a > { w : & 'a mut W , } impl < 'a > _WUCOMPW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _DIFW < 'a > { w : & 'a mut W , } impl < 'a > _DIFW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Reset from pin-reset detected." ] # [ inline ] pub fn resetpin ( & self ) -> RESETPINR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; RESETPINR { bits } } # [ doc = "Bit 1 - Reset from watchdog detected." ] # [ inline ] pub fn dog ( & self ) -> DOGR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DOGR { bits } } # [ doc = "Bit 2 - Reset from AIRCR.SYSRESETREQ detected." ] # [ inline ] pub fn sreq ( & self ) -> SREQR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; SREQR { bits } } # [ doc = "Bit 3 - Reset from CPU lock-up detected." ] # [ inline ] pub fn lockup ( & self ) -> LOCKUPR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; LOCKUPR { bits } } # [ doc = "Bit 16 - Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO." ] # [ inline ] pub fn off ( & self ) -> OFFR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; OFFR { bits } } # [ doc = "Bit 17 - Reset from wake-up from OFF mode detected by the use of ANADETECT signal from WUCOMP." ] # [ inline ] pub fn wucomp ( & self ) -> WUCOMPR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; WUCOMPR { bits } } # [ doc = "Bit 18 - Reset from wake-up from OFF mode detected by entering into debug interface mode." ] # [ inline ] pub fn dif ( & self ) -> DIFR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; DIFR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Reset from pin-reset detected." ] # [ inline ] pub fn resetpin ( & mut self ) -> _RESETPINW { _RESETPINW { w : self } } # [ doc = "Bit 1 - Reset from watchdog detected." ] # [ inline ] pub fn dog ( & mut self ) -> _DOGW { _DOGW { w : self } } # [ doc = "Bit 2 - Reset from AIRCR.SYSRESETREQ detected." ] # [ inline ] pub fn sreq ( & mut self ) -> _SREQW { _SREQW { w : self } } # [ doc = "Bit 3 - Reset from CPU lock-up detected." ] # [ inline ] pub fn lockup ( & mut self ) -> _LOCKUPW { _LOCKUPW { w : self } } # [ doc = "Bit 16 - Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO." ] # [ inline ] pub fn off ( & mut self ) -> _OFFW { _OFFW { w : self } } # [ doc = "Bit 17 - Reset from wake-up from OFF mode detected by the use of ANADETECT signal from WUCOMP." ] # [ inline ] pub fn wucomp ( & mut self ) -> _WUCOMPW { _WUCOMPW { w : self } } # [ doc = "Bit 18 - Reset from wake-up from OFF mode detected by entering into debug interface mode." ] # [ inline ] pub fn dif ( & mut self ) -> _DIFW { _DIFW { w : self } } } } # [ doc = "System off register." ] pub struct SYSTEMOFF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "System off register." ] pub mod systemoff { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SYSTEMOFF { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = "Values that can be written to the field `SYSTEMOFF`" ] pub enum SYSTEMOFFW { # [ doc = "Enter system off mode." ] ENTER } impl SYSTEMOFFW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SYSTEMOFFW :: ENTER => true } } } # [ doc = r" Proxy" ] pub struct _SYSTEMOFFW < 'a > { w : & 'a mut W , } impl < 'a > _SYSTEMOFFW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SYSTEMOFFW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enter system off mode." ] # [ inline ] pub fn enter ( self ) -> & 'a mut W { self . variant ( SYSTEMOFFW :: ENTER ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enter system off mode." ] # [ inline ] pub fn systemoff ( & mut self ) -> _SYSTEMOFFW { _SYSTEMOFFW { w : self } } } } # [ doc = "Power failure configuration." ] pub struct POFCON { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Power failure configuration." ] pub mod pofcon { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: POFCON { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `POF`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum POFR { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl POFR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { POFR :: DISABLED => false , POFR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> POFR { match value { false => POFR :: DISABLED , true => POFR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == POFR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == POFR :: ENABLED } } # [ doc = "Possible values of the field `THRESHOLD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum THRESHOLDR { # [ doc = "Set threshold to 2.1Volts." ] V21 , # [ doc = "Set threshold to 2.3Volts." ] V23 , # [ doc = "Set threshold to 2.5Volts." ] V25 , # [ doc = "Set threshold to 2.7Volts." ] V27 } impl THRESHOLDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { THRESHOLDR :: V21 => 0 , THRESHOLDR :: V23 => 0x01 , THRESHOLDR :: V25 => 0x02 , THRESHOLDR :: V27 => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> THRESHOLDR { match value { 0 => THRESHOLDR :: V21 , 1 => THRESHOLDR :: V23 , 2 => THRESHOLDR :: V25 , 3 => THRESHOLDR :: V27 , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `V21`" ] # [ inline ] pub fn is_v21 ( & self ) -> bool { * self == THRESHOLDR :: V21 } # [ doc = "Checks if the value of the field is `V23`" ] # [ inline ] pub fn is_v23 ( & self ) -> bool { * self == THRESHOLDR :: V23 } # [ doc = "Checks if the value of the field is `V25`" ] # [ inline ] pub fn is_v25 ( & self ) -> bool { * self == THRESHOLDR :: V25 } # [ doc = "Checks if the value of the field is `V27`" ] # [ inline ] pub fn is_v27 ( & self ) -> bool { * self == THRESHOLDR :: V27 } } # [ doc = "Values that can be written to the field `POF`" ] pub enum POFW { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl POFW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { POFW :: DISABLED => false , POFW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _POFW < 'a > { w : & 'a mut W , } impl < 'a > _POFW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : POFW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( POFW :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( POFW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `THRESHOLD`" ] pub enum THRESHOLDW { # [ doc = "Set threshold to 2.1Volts." ] V21 , # [ doc = "Set threshold to 2.3Volts." ] V23 , # [ doc = "Set threshold to 2.5Volts." ] V25 , # [ doc = "Set threshold to 2.7Volts." ] V27 } impl THRESHOLDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { THRESHOLDW :: V21 => 0 , THRESHOLDW :: V23 => 1 , THRESHOLDW :: V25 => 2 , THRESHOLDW :: V27 => 3 } } } # [ doc = r" Proxy" ] pub struct _THRESHOLDW < 'a > { w : & 'a mut W , } impl < 'a > _THRESHOLDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : THRESHOLDW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Set threshold to 2.1Volts." ] # [ inline ] pub fn v21 ( self ) -> & 'a mut W { self . variant ( THRESHOLDW :: V21 ) } # [ doc = "Set threshold to 2.3Volts." ] # [ inline ] pub fn v23 ( self ) -> & 'a mut W { self . variant ( THRESHOLDW :: V23 ) } # [ doc = "Set threshold to 2.5Volts." ] # [ inline ] pub fn v25 ( self ) -> & 'a mut W { self . variant ( THRESHOLDW :: V25 ) } # [ doc = "Set threshold to 2.7Volts." ] # [ inline ] pub fn v27 ( self ) -> & 'a mut W { self . variant ( THRESHOLDW :: V27 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Power failure comparator enable." ] # [ inline ] pub fn pof ( & self ) -> POFR { POFR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 1:2 - Set threshold level." ] # [ inline ] pub fn threshold ( & self ) -> THRESHOLDR { THRESHOLDR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Power failure comparator enable." ] # [ inline ] pub fn pof ( & mut self ) -> _POFW { _POFW { w : self } } # [ doc = "Bits 1:2 - Set threshold level." ] # [ inline ] pub fn threshold ( & mut self ) -> _THRESHOLDW { _THRESHOLDW { w : self } } } } # [ doc = "General purpose retention register. This register is a retained register." ] pub struct GPREGRET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "General purpose retention register. This register is a retained register." ] pub mod gpregret { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: GPREGRET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct GPREGRETR { bits : u8 , } impl GPREGRETR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _GPREGRETW < 'a > { w : & 'a mut W , } impl < 'a > _GPREGRETW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - General purpose retention register." ] # [ inline ] pub fn gpregret ( & self ) -> GPREGRETR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; GPREGRETR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - General purpose retention register." ] # [ inline ] pub fn gpregret ( & mut self ) -> _GPREGRETW { _GPREGRETW { w : self } } } } # [ doc = "Ram on/off." ] pub struct RAMON { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Ram on/off." ] pub mod ramon { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RAMON { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ONRAM0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ONRAM0R { # [ doc = "RAM block 0 OFF in ON mode." ] RAM0OFF , # [ doc = "RAM block 0 ON in ON mode." ] RAM0ON } impl ONRAM0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ONRAM0R :: RAM0OFF => false , ONRAM0R :: RAM0ON => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ONRAM0R { match value { false => ONRAM0R :: RAM0OFF , true => ONRAM0R :: RAM0ON , } } # [ doc = "Checks if the value of the field is `RAM0OFF`" ] # [ inline ] pub fn is_ram0off ( & self ) -> bool { * self == ONRAM0R :: RAM0OFF } # [ doc = "Checks if the value of the field is `RAM0ON`" ] # [ inline ] pub fn is_ram0on ( & self ) -> bool { * self == ONRAM0R :: RAM0ON } } # [ doc = "Possible values of the field `ONRAM1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ONRAM1R { # [ doc = "RAM block 1 OFF in ON mode." ] RAM1OFF , # [ doc = "RAM block 1 ON in ON mode." ] RAM1ON } impl ONRAM1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ONRAM1R :: RAM1OFF => false , ONRAM1R :: RAM1ON => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ONRAM1R { match value { false => ONRAM1R :: RAM1OFF , true => ONRAM1R :: RAM1ON , } } # [ doc = "Checks if the value of the field is `RAM1OFF`" ] # [ inline ] pub fn is_ram1off ( & self ) -> bool { * self == ONRAM1R :: RAM1OFF } # [ doc = "Checks if the value of the field is `RAM1ON`" ] # [ inline ] pub fn is_ram1on ( & self ) -> bool { * self == ONRAM1R :: RAM1ON } } # [ doc = "Possible values of the field `ONRAM2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ONRAM2R { # [ doc = "RAM block 2 OFF in ON mode." ] RAM2OFF , # [ doc = "RAM block 2 ON in ON mode." ] RAM2ON } impl ONRAM2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ONRAM2R :: RAM2OFF => false , ONRAM2R :: RAM2ON => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ONRAM2R { match value { false => ONRAM2R :: RAM2OFF , true => ONRAM2R :: RAM2ON , } } # [ doc = "Checks if the value of the field is `RAM2OFF`" ] # [ inline ] pub fn is_ram2off ( & self ) -> bool { * self == ONRAM2R :: RAM2OFF } # [ doc = "Checks if the value of the field is `RAM2ON`" ] # [ inline ] pub fn is_ram2on ( & self ) -> bool { * self == ONRAM2R :: RAM2ON } } # [ doc = "Possible values of the field `ONRAM3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ONRAM3R { # [ doc = "RAM block 3 OFF in ON mode." ] RAM3OFF , # [ doc = "RAM block 3 ON in ON mode." ] RAM3ON } impl ONRAM3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ONRAM3R :: RAM3OFF => false , ONRAM3R :: RAM3ON => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ONRAM3R { match value { false => ONRAM3R :: RAM3OFF , true => ONRAM3R :: RAM3ON , } } # [ doc = "Checks if the value of the field is `RAM3OFF`" ] # [ inline ] pub fn is_ram3off ( & self ) -> bool { * self == ONRAM3R :: RAM3OFF } # [ doc = "Checks if the value of the field is `RAM3ON`" ] # [ inline ] pub fn is_ram3on ( & self ) -> bool { * self == ONRAM3R :: RAM3ON } } # [ doc = "Possible values of the field `OFFRAM0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OFFRAM0R { # [ doc = "RAM block 0 OFF in OFF mode." ] RAM0OFF , # [ doc = "RAM block 0 ON in OFF mode." ] RAM0ON } impl OFFRAM0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OFFRAM0R :: RAM0OFF => false , OFFRAM0R :: RAM0ON => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OFFRAM0R { match value { false => OFFRAM0R :: RAM0OFF , true => OFFRAM0R :: RAM0ON , } } # [ doc = "Checks if the value of the field is `RAM0OFF`" ] # [ inline ] pub fn is_ram0off ( & self ) -> bool { * self == OFFRAM0R :: RAM0OFF } # [ doc = "Checks if the value of the field is `RAM0ON`" ] # [ inline ] pub fn is_ram0on ( & self ) -> bool { * self == OFFRAM0R :: RAM0ON } } # [ doc = "Possible values of the field `OFFRAM1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OFFRAM1R { # [ doc = "RAM block 1 OFF in OFF mode." ] RAM1OFF , # [ doc = "RAM block 1 ON in OFF mode." ] RAM1ON } impl OFFRAM1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OFFRAM1R :: RAM1OFF => false , OFFRAM1R :: RAM1ON => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OFFRAM1R { match value { false => OFFRAM1R :: RAM1OFF , true => OFFRAM1R :: RAM1ON , } } # [ doc = "Checks if the value of the field is `RAM1OFF`" ] # [ inline ] pub fn is_ram1off ( & self ) -> bool { * self == OFFRAM1R :: RAM1OFF } # [ doc = "Checks if the value of the field is `RAM1ON`" ] # [ inline ] pub fn is_ram1on ( & self ) -> bool { * self == OFFRAM1R :: RAM1ON } } # [ doc = "Possible values of the field `OFFRAM2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OFFRAM2R { # [ doc = "RAM block 2 OFF in OFF mode." ] RAM2OFF , # [ doc = "RAM block 2 ON in OFF mode." ] RAM2ON } impl OFFRAM2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OFFRAM2R :: RAM2OFF => false , OFFRAM2R :: RAM2ON => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OFFRAM2R { match value { false => OFFRAM2R :: RAM2OFF , true => OFFRAM2R :: RAM2ON , } } # [ doc = "Checks if the value of the field is `RAM2OFF`" ] # [ inline ] pub fn is_ram2off ( & self ) -> bool { * self == OFFRAM2R :: RAM2OFF } # [ doc = "Checks if the value of the field is `RAM2ON`" ] # [ inline ] pub fn is_ram2on ( & self ) -> bool { * self == OFFRAM2R :: RAM2ON } } # [ doc = "Possible values of the field `OFFRAM3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OFFRAM3R { # [ doc = "RAM block 3 OFF in OFF mode." ] RAM3OFF , # [ doc = "RAM block 3 ON in OFF mode." ] RAM3ON } impl OFFRAM3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OFFRAM3R :: RAM3OFF => false , OFFRAM3R :: RAM3ON => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OFFRAM3R { match value { false => OFFRAM3R :: RAM3OFF , true => OFFRAM3R :: RAM3ON , } } # [ doc = "Checks if the value of the field is `RAM3OFF`" ] # [ inline ] pub fn is_ram3off ( & self ) -> bool { * self == OFFRAM3R :: RAM3OFF } # [ doc = "Checks if the value of the field is `RAM3ON`" ] # [ inline ] pub fn is_ram3on ( & self ) -> bool { * self == OFFRAM3R :: RAM3ON } } # [ doc = "Values that can be written to the field `ONRAM0`" ] pub enum ONRAM0W { # [ doc = "RAM block 0 OFF in ON mode." ] RAM0OFF , # [ doc = "RAM block 0 ON in ON mode." ] RAM0ON } impl ONRAM0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ONRAM0W :: RAM0OFF => false , ONRAM0W :: RAM0ON => true } } } # [ doc = r" Proxy" ] pub struct _ONRAM0W < 'a > { w : & 'a mut W , } impl < 'a > _ONRAM0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ONRAM0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RAM block 0 OFF in ON mode." ] # [ inline ] pub fn ram0off ( self ) -> & 'a mut W { self . variant ( ONRAM0W :: RAM0OFF ) } # [ doc = "RAM block 0 ON in ON mode." ] # [ inline ] pub fn ram0on ( self ) -> & 'a mut W { self . variant ( ONRAM0W :: RAM0ON ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ONRAM1`" ] pub enum ONRAM1W { # [ doc = "RAM block 1 OFF in ON mode." ] RAM1OFF , # [ doc = "RAM block 1 ON in ON mode." ] RAM1ON } impl ONRAM1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ONRAM1W :: RAM1OFF => false , ONRAM1W :: RAM1ON => true } } } # [ doc = r" Proxy" ] pub struct _ONRAM1W < 'a > { w : & 'a mut W , } impl < 'a > _ONRAM1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ONRAM1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RAM block 1 OFF in ON mode." ] # [ inline ] pub fn ram1off ( self ) -> & 'a mut W { self . variant ( ONRAM1W :: RAM1OFF ) } # [ doc = "RAM block 1 ON in ON mode." ] # [ inline ] pub fn ram1on ( self ) -> & 'a mut W { self . variant ( ONRAM1W :: RAM1ON ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ONRAM2`" ] pub enum ONRAM2W { # [ doc = "RAM block 2 OFF in ON mode." ] RAM2OFF , # [ doc = "RAM block 2 ON in ON mode." ] RAM2ON } impl ONRAM2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ONRAM2W :: RAM2OFF => false , ONRAM2W :: RAM2ON => true } } } # [ doc = r" Proxy" ] pub struct _ONRAM2W < 'a > { w : & 'a mut W , } impl < 'a > _ONRAM2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ONRAM2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RAM block 2 OFF in ON mode." ] # [ inline ] pub fn ram2off ( self ) -> & 'a mut W { self . variant ( ONRAM2W :: RAM2OFF ) } # [ doc = "RAM block 2 ON in ON mode." ] # [ inline ] pub fn ram2on ( self ) -> & 'a mut W { self . variant ( ONRAM2W :: RAM2ON ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ONRAM3`" ] pub enum ONRAM3W { # [ doc = "RAM block 3 OFF in ON mode." ] RAM3OFF , # [ doc = "RAM block 3 ON in ON mode." ] RAM3ON } impl ONRAM3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ONRAM3W :: RAM3OFF => false , ONRAM3W :: RAM3ON => true } } } # [ doc = r" Proxy" ] pub struct _ONRAM3W < 'a > { w : & 'a mut W , } impl < 'a > _ONRAM3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ONRAM3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RAM block 3 OFF in ON mode." ] # [ inline ] pub fn ram3off ( self ) -> & 'a mut W { self . variant ( ONRAM3W :: RAM3OFF ) } # [ doc = "RAM block 3 ON in ON mode." ] # [ inline ] pub fn ram3on ( self ) -> & 'a mut W { self . variant ( ONRAM3W :: RAM3ON ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OFFRAM0`" ] pub enum OFFRAM0W { # [ doc = "RAM block 0 OFF in OFF mode." ] RAM0OFF , # [ doc = "RAM block 0 ON in OFF mode." ] RAM0ON } impl OFFRAM0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OFFRAM0W :: RAM0OFF => false , OFFRAM0W :: RAM0ON => true } } } # [ doc = r" Proxy" ] pub struct _OFFRAM0W < 'a > { w : & 'a mut W , } impl < 'a > _OFFRAM0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OFFRAM0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RAM block 0 OFF in OFF mode." ] # [ inline ] pub fn ram0off ( self ) -> & 'a mut W { self . variant ( OFFRAM0W :: RAM0OFF ) } # [ doc = "RAM block 0 ON in OFF mode." ] # [ inline ] pub fn ram0on ( self ) -> & 'a mut W { self . variant ( OFFRAM0W :: RAM0ON ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OFFRAM1`" ] pub enum OFFRAM1W { # [ doc = "RAM block 1 OFF in OFF mode." ] RAM1OFF , # [ doc = "RAM block 1 ON in OFF mode." ] RAM1ON } impl OFFRAM1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OFFRAM1W :: RAM1OFF => false , OFFRAM1W :: RAM1ON => true } } } # [ doc = r" Proxy" ] pub struct _OFFRAM1W < 'a > { w : & 'a mut W , } impl < 'a > _OFFRAM1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OFFRAM1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RAM block 1 OFF in OFF mode." ] # [ inline ] pub fn ram1off ( self ) -> & 'a mut W { self . variant ( OFFRAM1W :: RAM1OFF ) } # [ doc = "RAM block 1 ON in OFF mode." ] # [ inline ] pub fn ram1on ( self ) -> & 'a mut W { self . variant ( OFFRAM1W :: RAM1ON ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OFFRAM2`" ] pub enum OFFRAM2W { # [ doc = "RAM block 2 OFF in OFF mode." ] RAM2OFF , # [ doc = "RAM block 2 ON in OFF mode." ] RAM2ON } impl OFFRAM2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OFFRAM2W :: RAM2OFF => false , OFFRAM2W :: RAM2ON => true } } } # [ doc = r" Proxy" ] pub struct _OFFRAM2W < 'a > { w : & 'a mut W , } impl < 'a > _OFFRAM2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OFFRAM2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RAM block 2 OFF in OFF mode." ] # [ inline ] pub fn ram2off ( self ) -> & 'a mut W { self . variant ( OFFRAM2W :: RAM2OFF ) } # [ doc = "RAM block 2 ON in OFF mode." ] # [ inline ] pub fn ram2on ( self ) -> & 'a mut W { self . variant ( OFFRAM2W :: RAM2ON ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OFFRAM3`" ] pub enum OFFRAM3W { # [ doc = "RAM block 3 OFF in OFF mode." ] RAM3OFF , # [ doc = "RAM block 3 ON in OFF mode." ] RAM3ON } impl OFFRAM3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OFFRAM3W :: RAM3OFF => false , OFFRAM3W :: RAM3ON => true } } } # [ doc = r" Proxy" ] pub struct _OFFRAM3W < 'a > { w : & 'a mut W , } impl < 'a > _OFFRAM3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OFFRAM3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RAM block 3 OFF in OFF mode." ] # [ inline ] pub fn ram3off ( self ) -> & 'a mut W { self . variant ( OFFRAM3W :: RAM3OFF ) } # [ doc = "RAM block 3 ON in OFF mode." ] # [ inline ] pub fn ram3on ( self ) -> & 'a mut W { self . variant ( OFFRAM3W :: RAM3ON ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - RAM block 0 behaviour in ON mode." ] # [ inline ] pub fn onram0 ( & self ) -> ONRAM0R { ONRAM0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - RAM block 1 behaviour in ON mode." ] # [ inline ] pub fn onram1 ( & self ) -> ONRAM1R { ONRAM1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - RAM block 2 behaviour in ON mode." ] # [ inline ] pub fn onram2 ( & self ) -> ONRAM2R { ONRAM2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - RAM block 3 behaviour in ON mode." ] # [ inline ] pub fn onram3 ( & self ) -> ONRAM3R { ONRAM3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - RAM block 0 behaviour in OFF mode." ] # [ inline ] pub fn offram0 ( & self ) -> OFFRAM0R { OFFRAM0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - RAM block 1 behaviour in OFF mode." ] # [ inline ] pub fn offram1 ( & self ) -> OFFRAM1R { OFFRAM1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - RAM block 2 behaviour in OFF mode." ] # [ inline ] pub fn offram2 ( & self ) -> OFFRAM2R { OFFRAM2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - RAM block 3 behaviour in OFF mode." ] # [ inline ] pub fn offram3 ( & self ) -> OFFRAM3R { OFFRAM3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x0f } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - RAM block 0 behaviour in ON mode." ] # [ inline ] pub fn onram0 ( & mut self ) -> _ONRAM0W { _ONRAM0W { w : self } } # [ doc = "Bit 1 - RAM block 1 behaviour in ON mode." ] # [ inline ] pub fn onram1 ( & mut self ) -> _ONRAM1W { _ONRAM1W { w : self } } # [ doc = "Bit 2 - RAM block 2 behaviour in ON mode." ] # [ inline ] pub fn onram2 ( & mut self ) -> _ONRAM2W { _ONRAM2W { w : self } } # [ doc = "Bit 3 - RAM block 3 behaviour in ON mode." ] # [ inline ] pub fn onram3 ( & mut self ) -> _ONRAM3W { _ONRAM3W { w : self } } # [ doc = "Bit 16 - RAM block 0 behaviour in OFF mode." ] # [ inline ] pub fn offram0 ( & mut self ) -> _OFFRAM0W { _OFFRAM0W { w : self } } # [ doc = "Bit 17 - RAM block 1 behaviour in OFF mode." ] # [ inline ] pub fn offram1 ( & mut self ) -> _OFFRAM1W { _OFFRAM1W { w : self } } # [ doc = "Bit 18 - RAM block 2 behaviour in OFF mode." ] # [ inline ] pub fn offram2 ( & mut self ) -> _OFFRAM2W { _OFFRAM2W { w : self } } # [ doc = "Bit 19 - RAM block 3 behaviour in OFF mode." ] # [ inline ] pub fn offram3 ( & mut self ) -> _OFFRAM3W { _OFFRAM3W { w : self } } } } # [ doc = "Pin reset functionality configuration register. This register is a retained register." ] pub struct RESET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin reset functionality configuration register. This register is a retained register." ] pub mod reset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RESET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `RESET`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RESETR { # [ doc = "Pin reset in debug interface mode disabled." ] DISABLED , # [ doc = "Pin reset in debug interface mode enabled." ] ENABLED } impl RESETR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RESETR :: DISABLED => false , RESETR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RESETR { match value { false => RESETR :: DISABLED , true => RESETR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RESETR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RESETR :: ENABLED } } # [ doc = "Values that can be written to the field `RESET`" ] pub enum RESETW { # [ doc = "Pin reset in debug interface mode disabled." ] DISABLED , # [ doc = "Pin reset in debug interface mode enabled." ] ENABLED } impl RESETW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RESETW :: DISABLED => false , RESETW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _RESETW < 'a > { w : & 'a mut W , } impl < 'a > _RESETW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RESETW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin reset in debug interface mode disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RESETW :: DISABLED ) } # [ doc = "Pin reset in debug interface mode enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( RESETW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable pin reset in debug interface mode." ] # [ inline ] pub fn reset ( & self ) -> RESETR { RESETR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable pin reset in debug interface mode." ] # [ inline ] pub fn reset ( & mut self ) -> _RESETW { _RESETW { w : self } } } } # [ doc = "DCDC converter enable configuration register." ] pub struct DCDCEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "DCDC converter enable configuration register." ] pub mod dcdcen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DCDCEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `DCDCEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DCDCENR { # [ doc = "DCDC converter disabled." ] DISABLED , # [ doc = "DCDC converter enabled." ] ENABLED } impl DCDCENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DCDCENR :: DISABLED => false , DCDCENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DCDCENR { match value { false => DCDCENR :: DISABLED , true => DCDCENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DCDCENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DCDCENR :: ENABLED } } # [ doc = "Values that can be written to the field `DCDCEN`" ] pub enum DCDCENW { # [ doc = "DCDC converter disabled." ] DISABLED , # [ doc = "DCDC converter enabled." ] ENABLED } impl DCDCENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DCDCENW :: DISABLED => false , DCDCENW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _DCDCENW < 'a > { w : & 'a mut W , } impl < 'a > _DCDCENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DCDCENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "DCDC converter disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( DCDCENW :: DISABLED ) } # [ doc = "DCDC converter enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( DCDCENW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable DCDC converter." ] # [ inline ] pub fn dcdcen ( & self ) -> DCDCENR { DCDCENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable DCDC converter." ] # [ inline ] pub fn dcdcen ( & mut self ) -> _DCDCENW { _DCDCENW { w : self } } } } } # [ doc = "Clock control." ] pub struct CLOCK { _marker : PhantomData < * const ( ) > } unsafe impl Send for CLOCK { } impl CLOCK { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const clock :: RegisterBlock { 0x4000_0000 as * const _ } } impl Deref for CLOCK { type Target = clock :: RegisterBlock ; fn deref ( & self ) -> & clock :: RegisterBlock { unsafe { & * CLOCK :: ptr ( ) } } } # [ doc = "Clock control." ] pub mod clock { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start HFCLK clock source." ] pub tasks_hfclkstart : TASKS_HFCLKSTART , # [ doc = "0x04 - Stop HFCLK clock source." ] pub tasks_hfclkstop : TASKS_HFCLKSTOP , # [ doc = "0x08 - Start LFCLK clock source." ] pub tasks_lfclkstart : TASKS_LFCLKSTART , # [ doc = "0x0c - Stop LFCLK clock source." ] pub tasks_lfclkstop : TASKS_LFCLKSTOP , # [ doc = "0x10 - Start calibration of LFCLK RC oscillator." ] pub tasks_cal : TASKS_CAL , # [ doc = "0x14 - Start calibration timer." ] pub tasks_ctstart : TASKS_CTSTART , # [ doc = "0x18 - Stop calibration timer." ] pub tasks_ctstop : TASKS_CTSTOP , _reserved0 : [ u8 ; 228usize ] , # [ doc = "0x100 - HFCLK oscillator started." ] pub events_hfclkstarted : EVENTS_HFCLKSTARTED , # [ doc = "0x104 - LFCLK oscillator started." ] pub events_lfclkstarted : EVENTS_LFCLKSTARTED , _reserved1 : [ u8 ; 4usize ] , # [ doc = "0x10c - Callibration of LFCLK RC oscillator completed." ] pub events_done : EVENTS_DONE , # [ doc = "0x110 - Callibration timer timeout." ] pub events_ctto : EVENTS_CTTO , _reserved2 : [ u8 ; 496usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 256usize ] , # [ doc = "0x40c - High frequency clock status." ] pub hfclkstat : HFCLKSTAT , _reserved4 : [ u8 ; 8usize ] , # [ doc = "0x418 - Low frequency clock status." ] pub lfclkstat : LFCLKSTAT , _reserved5 : [ u8 ; 252usize ] , # [ doc = "0x518 - Clock source for the LFCLK clock." ] pub lfclksrc : LFCLKSRC , _reserved6 : [ u8 ; 28usize ] , # [ doc = "0x538 - Calibration timer interval." ] pub ctiv : CTIV , _reserved7 : [ u8 ; 20usize ] , # [ doc = "0x550 - Crystal frequency." ] pub xtalfreq : XTALFREQ , } # [ doc = "Start HFCLK clock source." ] pub struct TASKS_HFCLKSTART { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start HFCLK clock source." ] pub mod tasks_hfclkstart { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_HFCLKSTART { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop HFCLK clock source." ] pub struct TASKS_HFCLKSTOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop HFCLK clock source." ] pub mod tasks_hfclkstop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_HFCLKSTOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Start LFCLK clock source." ] pub struct TASKS_LFCLKSTART { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start LFCLK clock source." ] pub mod tasks_lfclkstart { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_LFCLKSTART { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop LFCLK clock source." ] pub struct TASKS_LFCLKSTOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop LFCLK clock source." ] pub mod tasks_lfclkstop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_LFCLKSTOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Start calibration of LFCLK RC oscillator." ] pub struct TASKS_CAL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start calibration of LFCLK RC oscillator." ] pub mod tasks_cal { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_CAL { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Start calibration timer." ] pub struct TASKS_CTSTART { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start calibration timer." ] pub mod tasks_ctstart { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_CTSTART { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop calibration timer." ] pub struct TASKS_CTSTOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop calibration timer." ] pub mod tasks_ctstop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_CTSTOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "HFCLK oscillator started." ] pub struct EVENTS_HFCLKSTARTED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "HFCLK oscillator started." ] pub mod events_hfclkstarted { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_HFCLKSTARTED { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "LFCLK oscillator started." ] pub struct EVENTS_LFCLKSTARTED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "LFCLK oscillator started." ] pub mod events_lfclkstarted { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_LFCLKSTARTED { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Callibration of LFCLK RC oscillator completed." ] pub struct EVENTS_DONE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Callibration of LFCLK RC oscillator completed." ] pub mod events_done { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_DONE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Callibration timer timeout." ] pub struct EVENTS_CTTO { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Callibration timer timeout." ] pub mod events_ctto { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_CTTO { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `HFCLKSTARTED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HFCLKSTARTEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl HFCLKSTARTEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HFCLKSTARTEDR :: DISABLED => false , HFCLKSTARTEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HFCLKSTARTEDR { match value { false => HFCLKSTARTEDR :: DISABLED , true => HFCLKSTARTEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == HFCLKSTARTEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == HFCLKSTARTEDR :: ENABLED } } # [ doc = "Possible values of the field `LFCLKSTARTED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LFCLKSTARTEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl LFCLKSTARTEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { LFCLKSTARTEDR :: DISABLED => false , LFCLKSTARTEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> LFCLKSTARTEDR { match value { false => LFCLKSTARTEDR :: DISABLED , true => LFCLKSTARTEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == LFCLKSTARTEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == LFCLKSTARTEDR :: ENABLED } } # [ doc = "Possible values of the field `DONE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DONER { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DONER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DONER :: DISABLED => false , DONER :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DONER { match value { false => DONER :: DISABLED , true => DONER :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DONER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DONER :: ENABLED } } # [ doc = "Possible values of the field `CTTO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CTTOR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl CTTOR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CTTOR :: DISABLED => false , CTTOR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CTTOR { match value { false => CTTOR :: DISABLED , true => CTTOR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CTTOR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CTTOR :: ENABLED } } # [ doc = "Values that can be written to the field `HFCLKSTARTED`" ] pub enum HFCLKSTARTEDW { # [ doc = "Enable interrupt on write." ] SET } impl HFCLKSTARTEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HFCLKSTARTEDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _HFCLKSTARTEDW < 'a > { w : & 'a mut W , } impl < 'a > _HFCLKSTARTEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HFCLKSTARTEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( HFCLKSTARTEDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `LFCLKSTARTED`" ] pub enum LFCLKSTARTEDW { # [ doc = "Enable interrupt on write." ] SET } impl LFCLKSTARTEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { LFCLKSTARTEDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _LFCLKSTARTEDW < 'a > { w : & 'a mut W , } impl < 'a > _LFCLKSTARTEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : LFCLKSTARTEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( LFCLKSTARTEDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DONE`" ] pub enum DONEW { # [ doc = "Enable interrupt on write." ] SET } impl DONEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DONEW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _DONEW < 'a > { w : & 'a mut W , } impl < 'a > _DONEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DONEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( DONEW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CTTO`" ] pub enum CTTOW { # [ doc = "Enable interrupt on write." ] SET } impl CTTOW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CTTOW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CTTOW < 'a > { w : & 'a mut W , } impl < 'a > _CTTOW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CTTOW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CTTOW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on HFCLKSTARTED event." ] # [ inline ] pub fn hfclkstarted ( & self ) -> HFCLKSTARTEDR { HFCLKSTARTEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on LFCLKSTARTED event." ] # [ inline ] pub fn lfclkstarted ( & self ) -> LFCLKSTARTEDR { LFCLKSTARTEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable interrupt on DONE event." ] # [ inline ] pub fn done ( & self ) -> DONER { DONER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Enable interrupt on CTTO event." ] # [ inline ] pub fn ctto ( & self ) -> CTTOR { CTTOR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on HFCLKSTARTED event." ] # [ inline ] pub fn hfclkstarted ( & mut self ) -> _HFCLKSTARTEDW { _HFCLKSTARTEDW { w : self } } # [ doc = "Bit 1 - Enable interrupt on LFCLKSTARTED event." ] # [ inline ] pub fn lfclkstarted ( & mut self ) -> _LFCLKSTARTEDW { _LFCLKSTARTEDW { w : self } } # [ doc = "Bit 3 - Enable interrupt on DONE event." ] # [ inline ] pub fn done ( & mut self ) -> _DONEW { _DONEW { w : self } } # [ doc = "Bit 4 - Enable interrupt on CTTO event." ] # [ inline ] pub fn ctto ( & mut self ) -> _CTTOW { _CTTOW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `HFCLKSTARTED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HFCLKSTARTEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl HFCLKSTARTEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HFCLKSTARTEDR :: DISABLED => false , HFCLKSTARTEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HFCLKSTARTEDR { match value { false => HFCLKSTARTEDR :: DISABLED , true => HFCLKSTARTEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == HFCLKSTARTEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == HFCLKSTARTEDR :: ENABLED } } # [ doc = "Possible values of the field `LFCLKSTARTED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LFCLKSTARTEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl LFCLKSTARTEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { LFCLKSTARTEDR :: DISABLED => false , LFCLKSTARTEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> LFCLKSTARTEDR { match value { false => LFCLKSTARTEDR :: DISABLED , true => LFCLKSTARTEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == LFCLKSTARTEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == LFCLKSTARTEDR :: ENABLED } } # [ doc = "Possible values of the field `DONE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DONER { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DONER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DONER :: DISABLED => false , DONER :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DONER { match value { false => DONER :: DISABLED , true => DONER :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DONER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DONER :: ENABLED } } # [ doc = "Possible values of the field `CTTO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CTTOR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl CTTOR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CTTOR :: DISABLED => false , CTTOR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CTTOR { match value { false => CTTOR :: DISABLED , true => CTTOR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CTTOR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CTTOR :: ENABLED } } # [ doc = "Values that can be written to the field `HFCLKSTARTED`" ] pub enum HFCLKSTARTEDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl HFCLKSTARTEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HFCLKSTARTEDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _HFCLKSTARTEDW < 'a > { w : & 'a mut W , } impl < 'a > _HFCLKSTARTEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HFCLKSTARTEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( HFCLKSTARTEDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `LFCLKSTARTED`" ] pub enum LFCLKSTARTEDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl LFCLKSTARTEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { LFCLKSTARTEDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _LFCLKSTARTEDW < 'a > { w : & 'a mut W , } impl < 'a > _LFCLKSTARTEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : LFCLKSTARTEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( LFCLKSTARTEDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DONE`" ] pub enum DONEW { # [ doc = "Disable interrupt on write." ] CLEAR } impl DONEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DONEW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _DONEW < 'a > { w : & 'a mut W , } impl < 'a > _DONEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DONEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( DONEW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CTTO`" ] pub enum CTTOW { # [ doc = "Disable interrupt on write." ] CLEAR } impl CTTOW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CTTOW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CTTOW < 'a > { w : & 'a mut W , } impl < 'a > _CTTOW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CTTOW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CTTOW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on HFCLKSTARTED event." ] # [ inline ] pub fn hfclkstarted ( & self ) -> HFCLKSTARTEDR { HFCLKSTARTEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on LFCLKSTARTED event." ] # [ inline ] pub fn lfclkstarted ( & self ) -> LFCLKSTARTEDR { LFCLKSTARTEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Disable interrupt on DONE event." ] # [ inline ] pub fn done ( & self ) -> DONER { DONER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Disable interrupt on CTTO event." ] # [ inline ] pub fn ctto ( & self ) -> CTTOR { CTTOR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on HFCLKSTARTED event." ] # [ inline ] pub fn hfclkstarted ( & mut self ) -> _HFCLKSTARTEDW { _HFCLKSTARTEDW { w : self } } # [ doc = "Bit 1 - Disable interrupt on LFCLKSTARTED event." ] # [ inline ] pub fn lfclkstarted ( & mut self ) -> _LFCLKSTARTEDW { _LFCLKSTARTEDW { w : self } } # [ doc = "Bit 3 - Disable interrupt on DONE event." ] # [ inline ] pub fn done ( & mut self ) -> _DONEW { _DONEW { w : self } } # [ doc = "Bit 4 - Disable interrupt on CTTO event." ] # [ inline ] pub fn ctto ( & mut self ) -> _CTTOW { _CTTOW { w : self } } } } # [ doc = "High frequency clock status." ] pub struct HFCLKSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "High frequency clock status." ] pub mod hfclkstat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: HFCLKSTAT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SRC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SRCR { # [ doc = "Internal 16MHz RC oscillator running and generating the HFCLK clock." ] RC , # [ doc = "External 16MHz/32MHz crystal oscillator running and generating the HFCLK clock." ] XTAL } impl SRCR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SRCR :: RC => false , SRCR :: XTAL => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SRCR { match value { false => SRCR :: RC , true => SRCR :: XTAL , } } # [ doc = "Checks if the value of the field is `RC`" ] # [ inline ] pub fn is_rc ( & self ) -> bool { * self == SRCR :: RC } # [ doc = "Checks if the value of the field is `XTAL`" ] # [ inline ] pub fn is_xtal ( & self ) -> bool { * self == SRCR :: XTAL } } # [ doc = "Possible values of the field `STATE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STATER { # [ doc = "HFCLK clock not running." ] NOTRUNNING , # [ doc = "HFCLK clock running." ] RUNNING } impl STATER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { STATER :: NOTRUNNING => false , STATER :: RUNNING => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> STATER { match value { false => STATER :: NOTRUNNING , true => STATER :: RUNNING , } } # [ doc = "Checks if the value of the field is `NOTRUNNING`" ] # [ inline ] pub fn is_not_running ( & self ) -> bool { * self == STATER :: NOTRUNNING } # [ doc = "Checks if the value of the field is `RUNNING`" ] # [ inline ] pub fn is_running ( & self ) -> bool { * self == STATER :: RUNNING } } # [ doc = "Values that can be written to the field `SRC`" ] pub enum SRCW { # [ doc = "Internal 16MHz RC oscillator running and generating the HFCLK clock." ] RC , # [ doc = "External 16MHz/32MHz crystal oscillator running and generating the HFCLK clock." ] XTAL } impl SRCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SRCW :: RC => false , SRCW :: XTAL => true } } } # [ doc = r" Proxy" ] pub struct _SRCW < 'a > { w : & 'a mut W , } impl < 'a > _SRCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SRCW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Internal 16MHz RC oscillator running and generating the HFCLK clock." ] # [ inline ] pub fn rc ( self ) -> & 'a mut W { self . variant ( SRCW :: RC ) } # [ doc = "External 16MHz/32MHz crystal oscillator running and generating the HFCLK clock." ] # [ inline ] pub fn xtal ( self ) -> & 'a mut W { self . variant ( SRCW :: XTAL ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `STATE`" ] pub enum STATEW { # [ doc = "HFCLK clock not running." ] NOTRUNNING , # [ doc = "HFCLK clock running." ] RUNNING } impl STATEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { STATEW :: NOTRUNNING => false , STATEW :: RUNNING => true } } } # [ doc = r" Proxy" ] pub struct _STATEW < 'a > { w : & 'a mut W , } impl < 'a > _STATEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : STATEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "HFCLK clock not running." ] # [ inline ] pub fn not_running ( self ) -> & 'a mut W { self . variant ( STATEW :: NOTRUNNING ) } # [ doc = "HFCLK clock running." ] # [ inline ] pub fn running ( self ) -> & 'a mut W { self . variant ( STATEW :: RUNNING ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Active clock source for the HF clock." ] # [ inline ] pub fn src ( & self ) -> SRCR { SRCR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - State for the HFCLK." ] # [ inline ] pub fn state ( & self ) -> STATER { STATER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Active clock source for the HF clock." ] # [ inline ] pub fn src ( & mut self ) -> _SRCW { _SRCW { w : self } } # [ doc = "Bit 16 - State for the HFCLK." ] # [ inline ] pub fn state ( & mut self ) -> _STATEW { _STATEW { w : self } } } } # [ doc = "Low frequency clock status." ] pub struct LFCLKSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Low frequency clock status." ] pub mod lfclkstat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: LFCLKSTAT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SRC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SRCR { # [ doc = "Internal 32KiHz RC oscillator running and generating the LFCLK clock." ] RC , # [ doc = "External 32KiHz crystal oscillator running and generating the LFCLK clock." ] XTAL , # [ doc = "Internal 32KiHz synthesizer from the HFCLK running and generating the LFCLK clock." ] SYNTH , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl SRCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SRCR :: RC => 0 , SRCR :: XTAL => 0x01 , SRCR :: SYNTH => 0x02 , SRCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SRCR { match value { 0 => SRCR :: RC , 1 => SRCR :: XTAL , 2 => SRCR :: SYNTH , i => SRCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `RC`" ] # [ inline ] pub fn is_rc ( & self ) -> bool { * self == SRCR :: RC } # [ doc = "Checks if the value of the field is `XTAL`" ] # [ inline ] pub fn is_xtal ( & self ) -> bool { * self == SRCR :: XTAL } # [ doc = "Checks if the value of the field is `SYNTH`" ] # [ inline ] pub fn is_synth ( & self ) -> bool { * self == SRCR :: SYNTH } } # [ doc = "Possible values of the field `STATE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STATER { # [ doc = "LFCLK clock not running." ] NOTRUNNING , # [ doc = "LFCLK clock running." ] RUNNING } impl STATER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { STATER :: NOTRUNNING => false , STATER :: RUNNING => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> STATER { match value { false => STATER :: NOTRUNNING , true => STATER :: RUNNING , } } # [ doc = "Checks if the value of the field is `NOTRUNNING`" ] # [ inline ] pub fn is_not_running ( & self ) -> bool { * self == STATER :: NOTRUNNING } # [ doc = "Checks if the value of the field is `RUNNING`" ] # [ inline ] pub fn is_running ( & self ) -> bool { * self == STATER :: RUNNING } } # [ doc = "Values that can be written to the field `SRC`" ] pub enum SRCW { # [ doc = "Internal 32KiHz RC oscillator running and generating the LFCLK clock." ] RC , # [ doc = "External 32KiHz crystal oscillator running and generating the LFCLK clock." ] XTAL , # [ doc = "Internal 32KiHz synthesizer from the HFCLK running and generating the LFCLK clock." ] SYNTH } impl SRCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SRCW :: RC => 0 , SRCW :: XTAL => 1 , SRCW :: SYNTH => 2 } } } # [ doc = r" Proxy" ] pub struct _SRCW < 'a > { w : & 'a mut W , } impl < 'a > _SRCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SRCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Internal 32KiHz RC oscillator running and generating the LFCLK clock." ] # [ inline ] pub fn rc ( self ) -> & 'a mut W { self . variant ( SRCW :: RC ) } # [ doc = "External 32KiHz crystal oscillator running and generating the LFCLK clock." ] # [ inline ] pub fn xtal ( self ) -> & 'a mut W { self . variant ( SRCW :: XTAL ) } # [ doc = "Internal 32KiHz synthesizer from the HFCLK running and generating the LFCLK clock." ] # [ inline ] pub fn synth ( self ) -> & 'a mut W { self . variant ( SRCW :: SYNTH ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `STATE`" ] pub enum STATEW { # [ doc = "LFCLK clock not running." ] NOTRUNNING , # [ doc = "LFCLK clock running." ] RUNNING } impl STATEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { STATEW :: NOTRUNNING => false , STATEW :: RUNNING => true } } } # [ doc = r" Proxy" ] pub struct _STATEW < 'a > { w : & 'a mut W , } impl < 'a > _STATEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : STATEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "LFCLK clock not running." ] # [ inline ] pub fn not_running ( self ) -> & 'a mut W { self . variant ( STATEW :: NOTRUNNING ) } # [ doc = "LFCLK clock running." ] # [ inline ] pub fn running ( self ) -> & 'a mut W { self . variant ( STATEW :: RUNNING ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Active clock source for the LF clock." ] # [ inline ] pub fn src ( & self ) -> SRCR { SRCR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 16 - State for the LF clock." ] # [ inline ] pub fn state ( & self ) -> STATER { STATER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Active clock source for the LF clock." ] # [ inline ] pub fn src ( & mut self ) -> _SRCW { _SRCW { w : self } } # [ doc = "Bit 16 - State for the LF clock." ] # [ inline ] pub fn state ( & mut self ) -> _STATEW { _STATEW { w : self } } } } # [ doc = "Clock source for the LFCLK clock." ] pub struct LFCLKSRC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Clock source for the LFCLK clock." ] pub mod lfclksrc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: LFCLKSRC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SRC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SRCR { # [ doc = "Internal 32KiHz RC oscillator." ] RC , # [ doc = "External 32KiHz crystal." ] XTAL , # [ doc = "Internal 32KiHz synthesizer from HFCLK system clock." ] SYNTH , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl SRCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SRCR :: RC => 0 , SRCR :: XTAL => 0x01 , SRCR :: SYNTH => 0x02 , SRCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SRCR { match value { 0 => SRCR :: RC , 1 => SRCR :: XTAL , 2 => SRCR :: SYNTH , i => SRCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `RC`" ] # [ inline ] pub fn is_rc ( & self ) -> bool { * self == SRCR :: RC } # [ doc = "Checks if the value of the field is `XTAL`" ] # [ inline ] pub fn is_xtal ( & self ) -> bool { * self == SRCR :: XTAL } # [ doc = "Checks if the value of the field is `SYNTH`" ] # [ inline ] pub fn is_synth ( & self ) -> bool { * self == SRCR :: SYNTH } } # [ doc = "Values that can be written to the field `SRC`" ] pub enum SRCW { # [ doc = "Internal 32KiHz RC oscillator." ] RC , # [ doc = "External 32KiHz crystal." ] XTAL , # [ doc = "Internal 32KiHz synthesizer from HFCLK system clock." ] SYNTH } impl SRCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SRCW :: RC => 0 , SRCW :: XTAL => 1 , SRCW :: SYNTH => 2 } } } # [ doc = r" Proxy" ] pub struct _SRCW < 'a > { w : & 'a mut W , } impl < 'a > _SRCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SRCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Internal 32KiHz RC oscillator." ] # [ inline ] pub fn rc ( self ) -> & 'a mut W { self . variant ( SRCW :: RC ) } # [ doc = "External 32KiHz crystal." ] # [ inline ] pub fn xtal ( self ) -> & 'a mut W { self . variant ( SRCW :: XTAL ) } # [ doc = "Internal 32KiHz synthesizer from HFCLK system clock." ] # [ inline ] pub fn synth ( self ) -> & 'a mut W { self . variant ( SRCW :: SYNTH ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Clock source." ] # [ inline ] pub fn src ( & self ) -> SRCR { SRCR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Clock source." ] # [ inline ] pub fn src ( & mut self ) -> _SRCW { _SRCW { w : self } } } } # [ doc = "Calibration timer interval." ] pub struct CTIV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Calibration timer interval." ] pub mod ctiv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CTIV { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct CTIVR { bits : u8 , } impl CTIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _CTIVW < 'a > { w : & 'a mut W , } impl < 'a > _CTIVW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:6 - Calibration timer interval in 0.25s resolution." ] # [ inline ] pub fn ctiv ( & self ) -> CTIVR { let bits = { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; CTIVR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:6 - Calibration timer interval in 0.25s resolution." ] # [ inline ] pub fn ctiv ( & mut self ) -> _CTIVW { _CTIVW { w : self } } } } # [ doc = "Crystal frequency." ] pub struct XTALFREQ { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Crystal frequency." ] pub mod xtalfreq { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: XTALFREQ { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `XTALFREQ`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum XTALFREQR { # [ doc = "16MHz xtal is used." ] _16MHZ , # [ doc = "32MHz xtal is used." ] _32MHZ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl XTALFREQR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { XTALFREQR :: _16MHZ => 0xff , XTALFREQR :: _32MHZ => 0 , XTALFREQR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> XTALFREQR { match value { 255 => XTALFREQR :: _16MHZ , 0 => XTALFREQR :: _32MHZ , i => XTALFREQR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `_16MHZ`" ] # [ inline ] pub fn is_16mhz ( & self ) -> bool { * self == XTALFREQR :: _16MHZ } # [ doc = "Checks if the value of the field is `_32MHZ`" ] # [ inline ] pub fn is_32mhz ( & self ) -> bool { * self == XTALFREQR :: _32MHZ } } # [ doc = "Values that can be written to the field `XTALFREQ`" ] pub enum XTALFREQW { # [ doc = "16MHz xtal is used." ] _16MHZ , # [ doc = "32MHz xtal is used." ] _32MHZ } impl XTALFREQW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { XTALFREQW :: _16MHZ => 255 , XTALFREQW :: _32MHZ => 0 } } } # [ doc = r" Proxy" ] pub struct _XTALFREQW < 'a > { w : & 'a mut W , } impl < 'a > _XTALFREQW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : XTALFREQW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "16MHz xtal is used." ] # [ inline ] pub fn _16mhz ( self ) -> & 'a mut W { self . variant ( XTALFREQW :: _16MHZ ) } # [ doc = "32MHz xtal is used." ] # [ inline ] pub fn _32mhz ( self ) -> & 'a mut W { self . variant ( XTALFREQW :: _32MHZ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - External Xtal frequency selection." ] # [ inline ] pub fn xtalfreq ( & self ) -> XTALFREQR { XTALFREQR :: _from ( { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - External Xtal frequency selection." ] # [ inline ] pub fn xtalfreq ( & mut self ) -> _XTALFREQW { _XTALFREQW { w : self } } } } } # [ doc = "Patch unit." ] pub struct PU { _marker : PhantomData < * const ( ) > } unsafe impl Send for PU { } impl PU { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const pu :: RegisterBlock { 0x4000_0000 as * const _ } } impl Deref for PU { type Target = pu :: RegisterBlock ; fn deref ( & self ) -> & pu :: RegisterBlock { unsafe { & * PU :: ptr ( ) } } } # [ doc = "Patch unit." ] pub mod pu { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1536usize ] , # [ doc = "0x600 - Address of first instruction to replace." ] pub replaceaddr : [ REPLACEADDR ; 8 ] , _reserved1 : [ u8 ; 96usize ] , # [ doc = "0x680 - Relative address of patch instructions." ] pub patchaddr : [ PATCHADDR ; 8 ] , _reserved2 : [ u8 ; 96usize ] , # [ doc = "0x700 - Patch enable register." ] pub patchen : PATCHEN , # [ doc = "0x704 - Patch enable register." ] pub patchenset : PATCHENSET , # [ doc = "0x708 - Patch disable register." ] pub patchenclr : PATCHENCLR , } # [ doc = "Address of first instruction to replace." ] pub struct REPLACEADDR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Address of first instruction to replace." ] pub mod replaceaddr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: REPLACEADDR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Relative address of patch instructions." ] pub struct PATCHADDR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Relative address of patch instructions." ] pub mod patchaddr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PATCHADDR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PATCHADDRR { bits : u32 , } impl PATCHADDRR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _PATCHADDRW < 'a > { w : & 'a mut W , } impl < 'a > _PATCHADDRW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x01ff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:24 - Relative address of patch instructions." ] # [ inline ] pub fn patchaddr ( & self ) -> PATCHADDRR { let bits = { const MASK : u32 = 0x01ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; PATCHADDRR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:24 - Relative address of patch instructions." ] # [ inline ] pub fn patchaddr ( & mut self ) -> _PATCHADDRW { _PATCHADDRW { w : self } } } } # [ doc = "Patch enable register." ] pub struct PATCHEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Patch enable register." ] pub mod patchen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PATCHEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PATCH0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH0R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH0R :: DISABLED => false , PATCH0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH0R { match value { false => PATCH0R :: DISABLED , true => PATCH0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH0R :: ENABLED } } # [ doc = "Possible values of the field `PATCH1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH1R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH1R :: DISABLED => false , PATCH1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH1R { match value { false => PATCH1R :: DISABLED , true => PATCH1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH1R :: ENABLED } } # [ doc = "Possible values of the field `PATCH2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH2R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH2R :: DISABLED => false , PATCH2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH2R { match value { false => PATCH2R :: DISABLED , true => PATCH2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH2R :: ENABLED } } # [ doc = "Possible values of the field `PATCH3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH3R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH3R :: DISABLED => false , PATCH3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH3R { match value { false => PATCH3R :: DISABLED , true => PATCH3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH3R :: ENABLED } } # [ doc = "Possible values of the field `PATCH4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH4R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH4R :: DISABLED => false , PATCH4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH4R { match value { false => PATCH4R :: DISABLED , true => PATCH4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH4R :: ENABLED } } # [ doc = "Possible values of the field `PATCH5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH5R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH5R :: DISABLED => false , PATCH5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH5R { match value { false => PATCH5R :: DISABLED , true => PATCH5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH5R :: ENABLED } } # [ doc = "Possible values of the field `PATCH6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH6R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH6R :: DISABLED => false , PATCH6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH6R { match value { false => PATCH6R :: DISABLED , true => PATCH6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH6R :: ENABLED } } # [ doc = "Possible values of the field `PATCH7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH7R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH7R :: DISABLED => false , PATCH7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH7R { match value { false => PATCH7R :: DISABLED , true => PATCH7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH7R :: ENABLED } } # [ doc = "Values that can be written to the field `PATCH0`" ] pub enum PATCH0W { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH0W :: DISABLED => false , PATCH0W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PATCH0W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Patch disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PATCH0W :: DISABLED ) } # [ doc = "Patch enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PATCH0W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH1`" ] pub enum PATCH1W { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH1W :: DISABLED => false , PATCH1W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PATCH1W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Patch disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PATCH1W :: DISABLED ) } # [ doc = "Patch enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PATCH1W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH2`" ] pub enum PATCH2W { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH2W :: DISABLED => false , PATCH2W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PATCH2W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Patch disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PATCH2W :: DISABLED ) } # [ doc = "Patch enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PATCH2W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH3`" ] pub enum PATCH3W { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH3W :: DISABLED => false , PATCH3W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PATCH3W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Patch disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PATCH3W :: DISABLED ) } # [ doc = "Patch enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PATCH3W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH4`" ] pub enum PATCH4W { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH4W :: DISABLED => false , PATCH4W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PATCH4W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Patch disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PATCH4W :: DISABLED ) } # [ doc = "Patch enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PATCH4W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH5`" ] pub enum PATCH5W { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH5W :: DISABLED => false , PATCH5W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PATCH5W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Patch disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PATCH5W :: DISABLED ) } # [ doc = "Patch enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PATCH5W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH6`" ] pub enum PATCH6W { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH6W :: DISABLED => false , PATCH6W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PATCH6W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Patch disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PATCH6W :: DISABLED ) } # [ doc = "Patch enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PATCH6W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH7`" ] pub enum PATCH7W { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH7W :: DISABLED => false , PATCH7W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PATCH7W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Patch disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PATCH7W :: DISABLED ) } # [ doc = "Patch enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PATCH7W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Patch 0 enabled." ] # [ inline ] pub fn patch0 ( & self ) -> PATCH0R { PATCH0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Patch 1 enabled." ] # [ inline ] pub fn patch1 ( & self ) -> PATCH1R { PATCH1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Patch 2 enabled." ] # [ inline ] pub fn patch2 ( & self ) -> PATCH2R { PATCH2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Patch 3 enabled." ] # [ inline ] pub fn patch3 ( & self ) -> PATCH3R { PATCH3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Patch 4 enabled." ] # [ inline ] pub fn patch4 ( & self ) -> PATCH4R { PATCH4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Patch 5 enabled." ] # [ inline ] pub fn patch5 ( & self ) -> PATCH5R { PATCH5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Patch 6 enabled." ] # [ inline ] pub fn patch6 ( & self ) -> PATCH6R { PATCH6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Patch 7 enabled." ] # [ inline ] pub fn patch7 ( & self ) -> PATCH7R { PATCH7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Patch 0 enabled." ] # [ inline ] pub fn patch0 ( & mut self ) -> _PATCH0W { _PATCH0W { w : self } } # [ doc = "Bit 1 - Patch 1 enabled." ] # [ inline ] pub fn patch1 ( & mut self ) -> _PATCH1W { _PATCH1W { w : self } } # [ doc = "Bit 2 - Patch 2 enabled." ] # [ inline ] pub fn patch2 ( & mut self ) -> _PATCH2W { _PATCH2W { w : self } } # [ doc = "Bit 3 - Patch 3 enabled." ] # [ inline ] pub fn patch3 ( & mut self ) -> _PATCH3W { _PATCH3W { w : self } } # [ doc = "Bit 4 - Patch 4 enabled." ] # [ inline ] pub fn patch4 ( & mut self ) -> _PATCH4W { _PATCH4W { w : self } } # [ doc = "Bit 5 - Patch 5 enabled." ] # [ inline ] pub fn patch5 ( & mut self ) -> _PATCH5W { _PATCH5W { w : self } } # [ doc = "Bit 6 - Patch 6 enabled." ] # [ inline ] pub fn patch6 ( & mut self ) -> _PATCH6W { _PATCH6W { w : self } } # [ doc = "Bit 7 - Patch 7 enabled." ] # [ inline ] pub fn patch7 ( & mut self ) -> _PATCH7W { _PATCH7W { w : self } } } } # [ doc = "Patch enable register." ] pub struct PATCHENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Patch enable register." ] pub mod patchenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PATCHENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PATCH0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH0R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH0R :: DISABLED => false , PATCH0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH0R { match value { false => PATCH0R :: DISABLED , true => PATCH0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH0R :: ENABLED } } # [ doc = "Possible values of the field `PATCH1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH1R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH1R :: DISABLED => false , PATCH1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH1R { match value { false => PATCH1R :: DISABLED , true => PATCH1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH1R :: ENABLED } } # [ doc = "Possible values of the field `PATCH2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH2R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH2R :: DISABLED => false , PATCH2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH2R { match value { false => PATCH2R :: DISABLED , true => PATCH2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH2R :: ENABLED } } # [ doc = "Possible values of the field `PATCH3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH3R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH3R :: DISABLED => false , PATCH3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH3R { match value { false => PATCH3R :: DISABLED , true => PATCH3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH3R :: ENABLED } } # [ doc = "Possible values of the field `PATCH4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH4R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH4R :: DISABLED => false , PATCH4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH4R { match value { false => PATCH4R :: DISABLED , true => PATCH4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH4R :: ENABLED } } # [ doc = "Possible values of the field `PATCH5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH5R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH5R :: DISABLED => false , PATCH5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH5R { match value { false => PATCH5R :: DISABLED , true => PATCH5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH5R :: ENABLED } } # [ doc = "Possible values of the field `PATCH6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH6R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH6R :: DISABLED => false , PATCH6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH6R { match value { false => PATCH6R :: DISABLED , true => PATCH6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH6R :: ENABLED } } # [ doc = "Possible values of the field `PATCH7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH7R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH7R :: DISABLED => false , PATCH7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH7R { match value { false => PATCH7R :: DISABLED , true => PATCH7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH7R :: ENABLED } } # [ doc = "Values that can be written to the field `PATCH0`" ] pub enum PATCH0W { # [ doc = "Enable patch on write." ] SET } impl PATCH0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH0W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PATCH0W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable patch on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PATCH0W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH1`" ] pub enum PATCH1W { # [ doc = "Enable patch on write." ] SET } impl PATCH1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH1W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PATCH1W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable patch on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PATCH1W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH2`" ] pub enum PATCH2W { # [ doc = "Enable patch on write." ] SET } impl PATCH2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH2W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PATCH2W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable patch on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PATCH2W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH3`" ] pub enum PATCH3W { # [ doc = "Enable patch on write." ] SET } impl PATCH3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH3W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PATCH3W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable patch on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PATCH3W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH4`" ] pub enum PATCH4W { # [ doc = "Enable patch on write." ] SET } impl PATCH4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH4W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PATCH4W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable patch on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PATCH4W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH5`" ] pub enum PATCH5W { # [ doc = "Enable patch on write." ] SET } impl PATCH5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH5W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PATCH5W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable patch on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PATCH5W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH6`" ] pub enum PATCH6W { # [ doc = "Enable patch on write." ] SET } impl PATCH6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH6W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PATCH6W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable patch on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PATCH6W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH7`" ] pub enum PATCH7W { # [ doc = "Enable patch on write." ] SET } impl PATCH7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH7W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PATCH7W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable patch on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PATCH7W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Patch 0 enabled." ] # [ inline ] pub fn patch0 ( & self ) -> PATCH0R { PATCH0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Patch 1 enabled." ] # [ inline ] pub fn patch1 ( & self ) -> PATCH1R { PATCH1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Patch 2 enabled." ] # [ inline ] pub fn patch2 ( & self ) -> PATCH2R { PATCH2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Patch 3 enabled." ] # [ inline ] pub fn patch3 ( & self ) -> PATCH3R { PATCH3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Patch 4 enabled." ] # [ inline ] pub fn patch4 ( & self ) -> PATCH4R { PATCH4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Patch 5 enabled." ] # [ inline ] pub fn patch5 ( & self ) -> PATCH5R { PATCH5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Patch 6 enabled." ] # [ inline ] pub fn patch6 ( & self ) -> PATCH6R { PATCH6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Patch 7 enabled." ] # [ inline ] pub fn patch7 ( & self ) -> PATCH7R { PATCH7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Patch 0 enabled." ] # [ inline ] pub fn patch0 ( & mut self ) -> _PATCH0W { _PATCH0W { w : self } } # [ doc = "Bit 1 - Patch 1 enabled." ] # [ inline ] pub fn patch1 ( & mut self ) -> _PATCH1W { _PATCH1W { w : self } } # [ doc = "Bit 2 - Patch 2 enabled." ] # [ inline ] pub fn patch2 ( & mut self ) -> _PATCH2W { _PATCH2W { w : self } } # [ doc = "Bit 3 - Patch 3 enabled." ] # [ inline ] pub fn patch3 ( & mut self ) -> _PATCH3W { _PATCH3W { w : self } } # [ doc = "Bit 4 - Patch 4 enabled." ] # [ inline ] pub fn patch4 ( & mut self ) -> _PATCH4W { _PATCH4W { w : self } } # [ doc = "Bit 5 - Patch 5 enabled." ] # [ inline ] pub fn patch5 ( & mut self ) -> _PATCH5W { _PATCH5W { w : self } } # [ doc = "Bit 6 - Patch 6 enabled." ] # [ inline ] pub fn patch6 ( & mut self ) -> _PATCH6W { _PATCH6W { w : self } } # [ doc = "Bit 7 - Patch 7 enabled." ] # [ inline ] pub fn patch7 ( & mut self ) -> _PATCH7W { _PATCH7W { w : self } } } } # [ doc = "Patch disable register." ] pub struct PATCHENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Patch disable register." ] pub mod patchenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PATCHENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PATCH0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH0R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH0R :: DISABLED => false , PATCH0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH0R { match value { false => PATCH0R :: DISABLED , true => PATCH0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH0R :: ENABLED } } # [ doc = "Possible values of the field `PATCH1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH1R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH1R :: DISABLED => false , PATCH1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH1R { match value { false => PATCH1R :: DISABLED , true => PATCH1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH1R :: ENABLED } } # [ doc = "Possible values of the field `PATCH2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH2R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH2R :: DISABLED => false , PATCH2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH2R { match value { false => PATCH2R :: DISABLED , true => PATCH2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH2R :: ENABLED } } # [ doc = "Possible values of the field `PATCH3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH3R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH3R :: DISABLED => false , PATCH3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH3R { match value { false => PATCH3R :: DISABLED , true => PATCH3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH3R :: ENABLED } } # [ doc = "Possible values of the field `PATCH4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH4R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH4R :: DISABLED => false , PATCH4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH4R { match value { false => PATCH4R :: DISABLED , true => PATCH4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH4R :: ENABLED } } # [ doc = "Possible values of the field `PATCH5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH5R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH5R :: DISABLED => false , PATCH5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH5R { match value { false => PATCH5R :: DISABLED , true => PATCH5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH5R :: ENABLED } } # [ doc = "Possible values of the field `PATCH6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH6R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH6R :: DISABLED => false , PATCH6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH6R { match value { false => PATCH6R :: DISABLED , true => PATCH6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH6R :: ENABLED } } # [ doc = "Possible values of the field `PATCH7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATCH7R { # [ doc = "Patch disabled." ] DISABLED , # [ doc = "Patch enabled." ] ENABLED } impl PATCH7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PATCH7R :: DISABLED => false , PATCH7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PATCH7R { match value { false => PATCH7R :: DISABLED , true => PATCH7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PATCH7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PATCH7R :: ENABLED } } # [ doc = "Values that can be written to the field `PATCH0`" ] pub enum PATCH0W { # [ doc = "Disable patch on write." ] CLEAR } impl PATCH0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH0W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PATCH0W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable patch on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PATCH0W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH1`" ] pub enum PATCH1W { # [ doc = "Disable patch on write." ] CLEAR } impl PATCH1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH1W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PATCH1W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable patch on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PATCH1W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH2`" ] pub enum PATCH2W { # [ doc = "Disable patch on write." ] CLEAR } impl PATCH2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH2W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PATCH2W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable patch on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PATCH2W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH3`" ] pub enum PATCH3W { # [ doc = "Disable patch on write." ] CLEAR } impl PATCH3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH3W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PATCH3W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable patch on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PATCH3W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH4`" ] pub enum PATCH4W { # [ doc = "Disable patch on write." ] CLEAR } impl PATCH4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH4W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PATCH4W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable patch on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PATCH4W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH5`" ] pub enum PATCH5W { # [ doc = "Disable patch on write." ] CLEAR } impl PATCH5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH5W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PATCH5W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable patch on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PATCH5W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH6`" ] pub enum PATCH6W { # [ doc = "Disable patch on write." ] CLEAR } impl PATCH6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH6W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PATCH6W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable patch on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PATCH6W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PATCH7`" ] pub enum PATCH7W { # [ doc = "Disable patch on write." ] CLEAR } impl PATCH7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PATCH7W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PATCH7W < 'a > { w : & 'a mut W , } impl < 'a > _PATCH7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PATCH7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable patch on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PATCH7W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Patch 0 enabled." ] # [ inline ] pub fn patch0 ( & self ) -> PATCH0R { PATCH0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Patch 1 enabled." ] # [ inline ] pub fn patch1 ( & self ) -> PATCH1R { PATCH1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Patch 2 enabled." ] # [ inline ] pub fn patch2 ( & self ) -> PATCH2R { PATCH2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Patch 3 enabled." ] # [ inline ] pub fn patch3 ( & self ) -> PATCH3R { PATCH3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Patch 4 enabled." ] # [ inline ] pub fn patch4 ( & self ) -> PATCH4R { PATCH4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Patch 5 enabled." ] # [ inline ] pub fn patch5 ( & self ) -> PATCH5R { PATCH5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Patch 6 enabled." ] # [ inline ] pub fn patch6 ( & self ) -> PATCH6R { PATCH6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Patch 7 enabled." ] # [ inline ] pub fn patch7 ( & self ) -> PATCH7R { PATCH7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Patch 0 enabled." ] # [ inline ] pub fn patch0 ( & mut self ) -> _PATCH0W { _PATCH0W { w : self } } # [ doc = "Bit 1 - Patch 1 enabled." ] # [ inline ] pub fn patch1 ( & mut self ) -> _PATCH1W { _PATCH1W { w : self } } # [ doc = "Bit 2 - Patch 2 enabled." ] # [ inline ] pub fn patch2 ( & mut self ) -> _PATCH2W { _PATCH2W { w : self } } # [ doc = "Bit 3 - Patch 3 enabled." ] # [ inline ] pub fn patch3 ( & mut self ) -> _PATCH3W { _PATCH3W { w : self } } # [ doc = "Bit 4 - Patch 4 enabled." ] # [ inline ] pub fn patch4 ( & mut self ) -> _PATCH4W { _PATCH4W { w : self } } # [ doc = "Bit 5 - Patch 5 enabled." ] # [ inline ] pub fn patch5 ( & mut self ) -> _PATCH5W { _PATCH5W { w : self } } # [ doc = "Bit 6 - Patch 6 enabled." ] # [ inline ] pub fn patch6 ( & mut self ) -> _PATCH6W { _PATCH6W { w : self } } # [ doc = "Bit 7 - Patch 7 enabled." ] # [ inline ] pub fn patch7 ( & mut self ) -> _PATCH7W { _PATCH7W { w : self } } } } } # [ doc = "The radio." ] pub struct RADIO { _marker : PhantomData < * const ( ) > } unsafe impl Send for RADIO { } impl RADIO { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const radio :: RegisterBlock { 0x4000_1000 as * const _ } } impl Deref for RADIO { type Target = radio :: RegisterBlock ; fn deref ( & self ) -> & radio :: RegisterBlock { unsafe { & * RADIO :: ptr ( ) } } } # [ doc = "The radio." ] pub mod radio { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Enable radio in TX mode." ] pub tasks_txen : TASKS_TXEN , # [ doc = "0x04 - Enable radio in RX mode." ] pub tasks_rxen : TASKS_RXEN , # [ doc = "0x08 - Start radio." ] pub tasks_start : TASKS_START , # [ doc = "0x0c - Stop radio." ] pub tasks_stop : TASKS_STOP , # [ doc = "0x10 - Disable radio." ] pub tasks_disable : TASKS_DISABLE , # [ doc = "0x14 - Start the RSSI and take one sample of the receive signal strength." ] pub tasks_rssistart : TASKS_RSSISTART , # [ doc = "0x18 - Stop the RSSI measurement." ] pub tasks_rssistop : TASKS_RSSISTOP , # [ doc = "0x1c - Start the bit counter." ] pub tasks_bcstart : TASKS_BCSTART , # [ doc = "0x20 - Stop the bit counter." ] pub tasks_bcstop : TASKS_BCSTOP , _reserved0 : [ u8 ; 220usize ] , # [ doc = "0x100 - Ready event." ] pub events_ready : EVENTS_READY , # [ doc = "0x104 - Address event." ] pub events_address : EVENTS_ADDRESS , # [ doc = "0x108 - Payload event." ] pub events_payload : EVENTS_PAYLOAD , # [ doc = "0x10c - End event." ] pub events_end : EVENTS_END , # [ doc = "0x110 - Disable event." ] pub events_disabled : EVENTS_DISABLED , # [ doc = "0x114 - A device address match occurred on the last received packet." ] pub events_devmatch : EVENTS_DEVMATCH , # [ doc = "0x118 - No device address match occurred on the last received packet." ] pub events_devmiss : EVENTS_DEVMISS , # [ doc = "0x11c - Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register." ] pub events_rssiend : EVENTS_RSSIEND , _reserved1 : [ u8 ; 8usize ] , # [ doc = "0x128 - Bit counter reached bit count value specified in BC register." ] pub events_bcmatch : EVENTS_BCMATCH , _reserved2 : [ u8 ; 212usize ] , # [ doc = "0x200 - Shortcut for the radio." ] pub shorts : SHORTS , _reserved3 : [ u8 ; 256usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved4 : [ u8 ; 244usize ] , # [ doc = "0x400 - CRC status of received packet." ] pub crcstatus : CRCSTATUS , _reserved5 : [ u8 ; 4usize ] , # [ doc = "0x408 - Received address." ] pub rxmatch : RXMATCH , # [ doc = "0x40c - Received CRC." ] pub rxcrc : RXCRC , # [ doc = "0x410 - Device address match index." ] pub dai : DAI , _reserved6 : [ u8 ; 240usize ] , # [ doc = "0x504 - Packet pointer. Decision point: START task." ] pub packetptr : PACKETPTR , # [ doc = "0x508 - Frequency." ] pub frequency : FREQUENCY , # [ doc = "0x50c - Output power." ] pub txpower : TXPOWER , # [ doc = "0x510 - Data rate and modulation." ] pub mode : MODE , # [ doc = "0x514 - Packet configuration 0." ] pub pcnf0 : PCNF0 , # [ doc = "0x518 - Packet configuration 1." ] pub pcnf1 : PCNF1 , # [ doc = "0x51c - Radio base address 0. Decision point: START task." ] pub base0 : BASE0 , # [ doc = "0x520 - Radio base address 1. Decision point: START task." ] pub base1 : BASE1 , # [ doc = "0x524 - Prefixes bytes for logical addresses 0 to 3." ] pub prefix0 : PREFIX0 , # [ doc = "0x528 - Prefixes bytes for logical addresses 4 to 7." ] pub prefix1 : PREFIX1 , # [ doc = "0x52c - Transmit address select." ] pub txaddress : TXADDRESS , # [ doc = "0x530 - Receive address select." ] pub rxaddresses : RXADDRESSES , # [ doc = "0x534 - CRC configuration." ] pub crccnf : CRCCNF , # [ doc = "0x538 - CRC polynomial." ] pub crcpoly : CRCPOLY , # [ doc = "0x53c - CRC initial value." ] pub crcinit : CRCINIT , # [ doc = "0x540 - Test features enable register." ] pub test : TEST , # [ doc = "0x544 - Inter Frame Spacing in microseconds." ] pub tifs : TIFS , # [ doc = "0x548 - RSSI sample." ] pub rssisample : RSSISAMPLE , _reserved7 : [ u8 ; 4usize ] , # [ doc = "0x550 - Current radio state." ] pub state : STATE , # [ doc = "0x554 - Data whitening initial value." ] pub datawhiteiv : DATAWHITEIV , _reserved8 : [ u8 ; 8usize ] , # [ doc = "0x560 - Bit counter compare." ] pub bcc : BCC , _reserved9 : [ u8 ; 156usize ] , # [ doc = "0x600 - Device address base segment." ] pub dab : [ DAB ; 8 ] , # [ doc = "0x620 - Device address prefix." ] pub dap : [ DAP ; 8 ] , # [ doc = "0x640 - Device address match configuration." ] pub dacnf : DACNF , _reserved10 : [ u8 ; 2488usize ] , # [ doc = "0xffc - Peripheral power control." ] pub power : POWER , } # [ doc = "Enable radio in TX mode." ] pub struct TASKS_TXEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable radio in TX mode." ] pub mod tasks_txen { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_TXEN { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Enable radio in RX mode." ] pub struct TASKS_RXEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable radio in RX mode." ] pub mod tasks_rxen { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_RXEN { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Start radio." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start radio." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop radio." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop radio." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Disable radio." ] pub struct TASKS_DISABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Disable radio." ] pub mod tasks_disable { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_DISABLE { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Start the RSSI and take one sample of the receive signal strength." ] pub struct TASKS_RSSISTART { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start the RSSI and take one sample of the receive signal strength." ] pub mod tasks_rssistart { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_RSSISTART { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop the RSSI measurement." ] pub struct TASKS_RSSISTOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop the RSSI measurement." ] pub mod tasks_rssistop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_RSSISTOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Start the bit counter." ] pub struct TASKS_BCSTART { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start the bit counter." ] pub mod tasks_bcstart { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_BCSTART { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop the bit counter." ] pub struct TASKS_BCSTOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop the bit counter." ] pub mod tasks_bcstop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_BCSTOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Ready event." ] pub struct EVENTS_READY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Ready event." ] pub mod events_ready { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_READY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Address event." ] pub struct EVENTS_ADDRESS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Address event." ] pub mod events_address { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ADDRESS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Payload event." ] pub struct EVENTS_PAYLOAD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Payload event." ] pub mod events_payload { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_PAYLOAD { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "End event." ] pub struct EVENTS_END { register : :: vcell :: VolatileCell < u32 > } # [ doc = "End event." ] pub mod events_end { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_END { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Disable event." ] pub struct EVENTS_DISABLED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Disable event." ] pub mod events_disabled { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_DISABLED { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "A device address match occurred on the last received packet." ] pub struct EVENTS_DEVMATCH { register : :: vcell :: VolatileCell < u32 > } # [ doc = "A device address match occurred on the last received packet." ] pub mod events_devmatch { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_DEVMATCH { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "No device address match occurred on the last received packet." ] pub struct EVENTS_DEVMISS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "No device address match occurred on the last received packet." ] pub mod events_devmiss { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_DEVMISS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register." ] pub struct EVENTS_RSSIEND { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register." ] pub mod events_rssiend { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_RSSIEND { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Bit counter reached bit count value specified in BC register." ] pub struct EVENTS_BCMATCH { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Bit counter reached bit count value specified in BC register." ] pub mod events_bcmatch { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_BCMATCH { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Shortcut for the radio." ] pub struct SHORTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Shortcut for the radio." ] pub mod shorts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SHORTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY_START`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READY_STARTR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_STARTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READY_STARTR :: DISABLED => false , READY_STARTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READY_STARTR { match value { false => READY_STARTR :: DISABLED , true => READY_STARTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READY_STARTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READY_STARTR :: ENABLED } } # [ doc = "Possible values of the field `END_DISABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum END_DISABLER { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl END_DISABLER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { END_DISABLER :: DISABLED => false , END_DISABLER :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> END_DISABLER { match value { false => END_DISABLER :: DISABLED , true => END_DISABLER :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == END_DISABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == END_DISABLER :: ENABLED } } # [ doc = "Possible values of the field `DISABLED_TXEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DISABLED_TXENR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DISABLED_TXENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DISABLED_TXENR :: DISABLED => false , DISABLED_TXENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DISABLED_TXENR { match value { false => DISABLED_TXENR :: DISABLED , true => DISABLED_TXENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DISABLED_TXENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DISABLED_TXENR :: ENABLED } } # [ doc = "Possible values of the field `DISABLED_RXEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DISABLED_RXENR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DISABLED_RXENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DISABLED_RXENR :: DISABLED => false , DISABLED_RXENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DISABLED_RXENR { match value { false => DISABLED_RXENR :: DISABLED , true => DISABLED_RXENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DISABLED_RXENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DISABLED_RXENR :: ENABLED } } # [ doc = "Possible values of the field `ADDRESS_RSSISTART`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDRESS_RSSISTARTR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl ADDRESS_RSSISTARTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDRESS_RSSISTARTR :: DISABLED => false , ADDRESS_RSSISTARTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDRESS_RSSISTARTR { match value { false => ADDRESS_RSSISTARTR :: DISABLED , true => ADDRESS_RSSISTARTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDRESS_RSSISTARTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDRESS_RSSISTARTR :: ENABLED } } # [ doc = "Possible values of the field `END_START`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum END_STARTR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl END_STARTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { END_STARTR :: DISABLED => false , END_STARTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> END_STARTR { match value { false => END_STARTR :: DISABLED , true => END_STARTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == END_STARTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == END_STARTR :: ENABLED } } # [ doc = "Possible values of the field `ADDRESS_BCSTART`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDRESS_BCSTARTR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl ADDRESS_BCSTARTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDRESS_BCSTARTR :: DISABLED => false , ADDRESS_BCSTARTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDRESS_BCSTARTR { match value { false => ADDRESS_BCSTARTR :: DISABLED , true => ADDRESS_BCSTARTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDRESS_BCSTARTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDRESS_BCSTARTR :: ENABLED } } # [ doc = "Possible values of the field `DISABLED_RSSISTOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DISABLED_RSSISTOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DISABLED_RSSISTOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DISABLED_RSSISTOPR :: DISABLED => false , DISABLED_RSSISTOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DISABLED_RSSISTOPR { match value { false => DISABLED_RSSISTOPR :: DISABLED , true => DISABLED_RSSISTOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DISABLED_RSSISTOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DISABLED_RSSISTOPR :: ENABLED } } # [ doc = "Values that can be written to the field `READY_START`" ] pub enum READY_STARTW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_STARTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READY_STARTW :: DISABLED => false , READY_STARTW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _READY_STARTW < 'a > { w : & 'a mut W , } impl < 'a > _READY_STARTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READY_STARTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( READY_STARTW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( READY_STARTW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `END_DISABLE`" ] pub enum END_DISABLEW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl END_DISABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { END_DISABLEW :: DISABLED => false , END_DISABLEW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _END_DISABLEW < 'a > { w : & 'a mut W , } impl < 'a > _END_DISABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : END_DISABLEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( END_DISABLEW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( END_DISABLEW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DISABLED_TXEN`" ] pub enum DISABLED_TXENW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DISABLED_TXENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DISABLED_TXENW :: DISABLED => false , DISABLED_TXENW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _DISABLED_TXENW < 'a > { w : & 'a mut W , } impl < 'a > _DISABLED_TXENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DISABLED_TXENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( DISABLED_TXENW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( DISABLED_TXENW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DISABLED_RXEN`" ] pub enum DISABLED_RXENW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DISABLED_RXENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DISABLED_RXENW :: DISABLED => false , DISABLED_RXENW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _DISABLED_RXENW < 'a > { w : & 'a mut W , } impl < 'a > _DISABLED_RXENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DISABLED_RXENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( DISABLED_RXENW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( DISABLED_RXENW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDRESS_RSSISTART`" ] pub enum ADDRESS_RSSISTARTW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl ADDRESS_RSSISTARTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDRESS_RSSISTARTW :: DISABLED => false , ADDRESS_RSSISTARTW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDRESS_RSSISTARTW < 'a > { w : & 'a mut W , } impl < 'a > _ADDRESS_RSSISTARTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDRESS_RSSISTARTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDRESS_RSSISTARTW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDRESS_RSSISTARTW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `END_START`" ] pub enum END_STARTW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl END_STARTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { END_STARTW :: DISABLED => false , END_STARTW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _END_STARTW < 'a > { w : & 'a mut W , } impl < 'a > _END_STARTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : END_STARTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( END_STARTW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( END_STARTW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDRESS_BCSTART`" ] pub enum ADDRESS_BCSTARTW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl ADDRESS_BCSTARTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDRESS_BCSTARTW :: DISABLED => false , ADDRESS_BCSTARTW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDRESS_BCSTARTW < 'a > { w : & 'a mut W , } impl < 'a > _ADDRESS_BCSTARTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDRESS_BCSTARTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDRESS_BCSTARTW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDRESS_BCSTARTW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DISABLED_RSSISTOP`" ] pub enum DISABLED_RSSISTOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DISABLED_RSSISTOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DISABLED_RSSISTOPW :: DISABLED => false , DISABLED_RSSISTOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _DISABLED_RSSISTOPW < 'a > { w : & 'a mut W , } impl < 'a > _DISABLED_RSSISTOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DISABLED_RSSISTOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( DISABLED_RSSISTOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( DISABLED_RSSISTOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Shortcut between READY event and START task." ] # [ inline ] pub fn ready_start ( & self ) -> READY_STARTR { READY_STARTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Shortcut between END event and DISABLE task." ] # [ inline ] pub fn end_disable ( & self ) -> END_DISABLER { END_DISABLER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Shortcut between DISABLED event and TXEN task." ] # [ inline ] pub fn disabled_txen ( & self ) -> DISABLED_TXENR { DISABLED_TXENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Shortcut between DISABLED event and RXEN task." ] # [ inline ] pub fn disabled_rxen ( & self ) -> DISABLED_RXENR { DISABLED_RXENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Shortcut between ADDRESS event and RSSISTART task." ] # [ inline ] pub fn address_rssistart ( & self ) -> ADDRESS_RSSISTARTR { ADDRESS_RSSISTARTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Shortcut between END event and START task." ] # [ inline ] pub fn end_start ( & self ) -> END_STARTR { END_STARTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Shortcut between ADDRESS event and BCSTART task." ] # [ inline ] pub fn address_bcstart ( & self ) -> ADDRESS_BCSTARTR { ADDRESS_BCSTARTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Shortcut between DISABLED event and RSSISTOP task." ] # [ inline ] pub fn disabled_rssistop ( & self ) -> DISABLED_RSSISTOPR { DISABLED_RSSISTOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Shortcut between READY event and START task." ] # [ inline ] pub fn ready_start ( & mut self ) -> _READY_STARTW { _READY_STARTW { w : self } } # [ doc = "Bit 1 - Shortcut between END event and DISABLE task." ] # [ inline ] pub fn end_disable ( & mut self ) -> _END_DISABLEW { _END_DISABLEW { w : self } } # [ doc = "Bit 2 - Shortcut between DISABLED event and TXEN task." ] # [ inline ] pub fn disabled_txen ( & mut self ) -> _DISABLED_TXENW { _DISABLED_TXENW { w : self } } # [ doc = "Bit 3 - Shortcut between DISABLED event and RXEN task." ] # [ inline ] pub fn disabled_rxen ( & mut self ) -> _DISABLED_RXENW { _DISABLED_RXENW { w : self } } # [ doc = "Bit 4 - Shortcut between ADDRESS event and RSSISTART task." ] # [ inline ] pub fn address_rssistart ( & mut self ) -> _ADDRESS_RSSISTARTW { _ADDRESS_RSSISTARTW { w : self } } # [ doc = "Bit 5 - Shortcut between END event and START task." ] # [ inline ] pub fn end_start ( & mut self ) -> _END_STARTW { _END_STARTW { w : self } } # [ doc = "Bit 6 - Shortcut between ADDRESS event and BCSTART task." ] # [ inline ] pub fn address_bcstart ( & mut self ) -> _ADDRESS_BCSTARTW { _ADDRESS_BCSTARTW { w : self } } # [ doc = "Bit 8 - Shortcut between DISABLED event and RSSISTOP task." ] # [ inline ] pub fn disabled_rssistop ( & mut self ) -> _DISABLED_RSSISTOPW { _DISABLED_RSSISTOPW { w : self } } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl READYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READYR :: DISABLED => false , READYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READYR { match value { false => READYR :: DISABLED , true => READYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READYR :: ENABLED } } # [ doc = "Possible values of the field `ADDRESS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDRESSR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ADDRESSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDRESSR :: DISABLED => false , ADDRESSR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDRESSR { match value { false => ADDRESSR :: DISABLED , true => ADDRESSR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDRESSR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDRESSR :: ENABLED } } # [ doc = "Possible values of the field `PAYLOAD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PAYLOADR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl PAYLOADR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PAYLOADR :: DISABLED => false , PAYLOADR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PAYLOADR { match value { false => PAYLOADR :: DISABLED , true => PAYLOADR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PAYLOADR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PAYLOADR :: ENABLED } } # [ doc = "Possible values of the field `END`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDR :: DISABLED => false , ENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDR { match value { false => ENDR :: DISABLED , true => ENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDR :: ENABLED } } # [ doc = "Possible values of the field `DISABLED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DISABLEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DISABLEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DISABLEDR :: DISABLED => false , DISABLEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DISABLEDR { match value { false => DISABLEDR :: DISABLED , true => DISABLEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DISABLEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DISABLEDR :: ENABLED } } # [ doc = "Possible values of the field `DEVMATCH`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DEVMATCHR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DEVMATCHR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DEVMATCHR :: DISABLED => false , DEVMATCHR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DEVMATCHR { match value { false => DEVMATCHR :: DISABLED , true => DEVMATCHR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DEVMATCHR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DEVMATCHR :: ENABLED } } # [ doc = "Possible values of the field `DEVMISS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DEVMISSR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DEVMISSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DEVMISSR :: DISABLED => false , DEVMISSR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DEVMISSR { match value { false => DEVMISSR :: DISABLED , true => DEVMISSR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DEVMISSR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DEVMISSR :: ENABLED } } # [ doc = "Possible values of the field `RSSIEND`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RSSIENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RSSIENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RSSIENDR :: DISABLED => false , RSSIENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RSSIENDR { match value { false => RSSIENDR :: DISABLED , true => RSSIENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RSSIENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RSSIENDR :: ENABLED } } # [ doc = "Possible values of the field `BCMATCH`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BCMATCHR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl BCMATCHR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BCMATCHR :: DISABLED => false , BCMATCHR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BCMATCHR { match value { false => BCMATCHR :: DISABLED , true => BCMATCHR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == BCMATCHR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == BCMATCHR :: ENABLED } } # [ doc = "Values that can be written to the field `READY`" ] pub enum READYW { # [ doc = "Enable interrupt on write." ] SET } impl READYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _READYW < 'a > { w : & 'a mut W , } impl < 'a > _READYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( READYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDRESS`" ] pub enum ADDRESSW { # [ doc = "Enable interrupt on write." ] SET } impl ADDRESSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDRESSW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ADDRESSW < 'a > { w : & 'a mut W , } impl < 'a > _ADDRESSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDRESSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ADDRESSW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PAYLOAD`" ] pub enum PAYLOADW { # [ doc = "Enable interrupt on write." ] SET } impl PAYLOADW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PAYLOADW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PAYLOADW < 'a > { w : & 'a mut W , } impl < 'a > _PAYLOADW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PAYLOADW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PAYLOADW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `END`" ] pub enum ENDW { # [ doc = "Enable interrupt on write." ] SET } impl ENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ENDW < 'a > { w : & 'a mut W , } impl < 'a > _ENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ENDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DISABLED`" ] pub enum DISABLEDW { # [ doc = "Enable interrupt on write." ] SET } impl DISABLEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DISABLEDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _DISABLEDW < 'a > { w : & 'a mut W , } impl < 'a > _DISABLEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DISABLEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( DISABLEDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DEVMATCH`" ] pub enum DEVMATCHW { # [ doc = "Enable interrupt on write." ] SET } impl DEVMATCHW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DEVMATCHW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _DEVMATCHW < 'a > { w : & 'a mut W , } impl < 'a > _DEVMATCHW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DEVMATCHW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( DEVMATCHW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DEVMISS`" ] pub enum DEVMISSW { # [ doc = "Enable interrupt on write." ] SET } impl DEVMISSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DEVMISSW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _DEVMISSW < 'a > { w : & 'a mut W , } impl < 'a > _DEVMISSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DEVMISSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( DEVMISSW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RSSIEND`" ] pub enum RSSIENDW { # [ doc = "Enable interrupt on write." ] SET } impl RSSIENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RSSIENDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _RSSIENDW < 'a > { w : & 'a mut W , } impl < 'a > _RSSIENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RSSIENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( RSSIENDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BCMATCH`" ] pub enum BCMATCHW { # [ doc = "Enable interrupt on write." ] SET } impl BCMATCHW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BCMATCHW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _BCMATCHW < 'a > { w : & 'a mut W , } impl < 'a > _BCMATCHW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BCMATCHW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( BCMATCHW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on READY event." ] # [ inline ] pub fn ready ( & self ) -> READYR { READYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on ADDRESS event." ] # [ inline ] pub fn address ( & self ) -> ADDRESSR { ADDRESSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable interrupt on PAYLOAD event." ] # [ inline ] pub fn payload ( & self ) -> PAYLOADR { PAYLOADR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable interrupt on END event." ] # [ inline ] pub fn end ( & self ) -> ENDR { ENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Enable interrupt on DISABLED event." ] # [ inline ] pub fn disabled ( & self ) -> DISABLEDR { DISABLEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Enable interrupt on DEVMATCH event." ] # [ inline ] pub fn devmatch ( & self ) -> DEVMATCHR { DEVMATCHR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Enable interrupt on DEVMISS event." ] # [ inline ] pub fn devmiss ( & self ) -> DEVMISSR { DEVMISSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Enable interrupt on RSSIEND event." ] # [ inline ] pub fn rssiend ( & self ) -> RSSIENDR { RSSIENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Enable interrupt on BCMATCH event." ] # [ inline ] pub fn bcmatch ( & self ) -> BCMATCHR { BCMATCHR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on READY event." ] # [ inline ] pub fn ready ( & mut self ) -> _READYW { _READYW { w : self } } # [ doc = "Bit 1 - Enable interrupt on ADDRESS event." ] # [ inline ] pub fn address ( & mut self ) -> _ADDRESSW { _ADDRESSW { w : self } } # [ doc = "Bit 2 - Enable interrupt on PAYLOAD event." ] # [ inline ] pub fn payload ( & mut self ) -> _PAYLOADW { _PAYLOADW { w : self } } # [ doc = "Bit 3 - Enable interrupt on END event." ] # [ inline ] pub fn end ( & mut self ) -> _ENDW { _ENDW { w : self } } # [ doc = "Bit 4 - Enable interrupt on DISABLED event." ] # [ inline ] pub fn disabled ( & mut self ) -> _DISABLEDW { _DISABLEDW { w : self } } # [ doc = "Bit 5 - Enable interrupt on DEVMATCH event." ] # [ inline ] pub fn devmatch ( & mut self ) -> _DEVMATCHW { _DEVMATCHW { w : self } } # [ doc = "Bit 6 - Enable interrupt on DEVMISS event." ] # [ inline ] pub fn devmiss ( & mut self ) -> _DEVMISSW { _DEVMISSW { w : self } } # [ doc = "Bit 7 - Enable interrupt on RSSIEND event." ] # [ inline ] pub fn rssiend ( & mut self ) -> _RSSIENDW { _RSSIENDW { w : self } } # [ doc = "Bit 10 - Enable interrupt on BCMATCH event." ] # [ inline ] pub fn bcmatch ( & mut self ) -> _BCMATCHW { _BCMATCHW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl READYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READYR :: DISABLED => false , READYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READYR { match value { false => READYR :: DISABLED , true => READYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READYR :: ENABLED } } # [ doc = "Possible values of the field `ADDRESS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDRESSR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ADDRESSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDRESSR :: DISABLED => false , ADDRESSR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDRESSR { match value { false => ADDRESSR :: DISABLED , true => ADDRESSR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDRESSR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDRESSR :: ENABLED } } # [ doc = "Possible values of the field `PAYLOAD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PAYLOADR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl PAYLOADR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PAYLOADR :: DISABLED => false , PAYLOADR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PAYLOADR { match value { false => PAYLOADR :: DISABLED , true => PAYLOADR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PAYLOADR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PAYLOADR :: ENABLED } } # [ doc = "Possible values of the field `END`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDR :: DISABLED => false , ENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDR { match value { false => ENDR :: DISABLED , true => ENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDR :: ENABLED } } # [ doc = "Possible values of the field `DISABLED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DISABLEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DISABLEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DISABLEDR :: DISABLED => false , DISABLEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DISABLEDR { match value { false => DISABLEDR :: DISABLED , true => DISABLEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DISABLEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DISABLEDR :: ENABLED } } # [ doc = "Possible values of the field `DEVMATCH`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DEVMATCHR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DEVMATCHR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DEVMATCHR :: DISABLED => false , DEVMATCHR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DEVMATCHR { match value { false => DEVMATCHR :: DISABLED , true => DEVMATCHR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DEVMATCHR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DEVMATCHR :: ENABLED } } # [ doc = "Possible values of the field `DEVMISS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DEVMISSR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DEVMISSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DEVMISSR :: DISABLED => false , DEVMISSR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DEVMISSR { match value { false => DEVMISSR :: DISABLED , true => DEVMISSR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DEVMISSR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DEVMISSR :: ENABLED } } # [ doc = "Possible values of the field `RSSIEND`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RSSIENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RSSIENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RSSIENDR :: DISABLED => false , RSSIENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RSSIENDR { match value { false => RSSIENDR :: DISABLED , true => RSSIENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RSSIENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RSSIENDR :: ENABLED } } # [ doc = "Possible values of the field `BCMATCH`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BCMATCHR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl BCMATCHR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BCMATCHR :: DISABLED => false , BCMATCHR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BCMATCHR { match value { false => BCMATCHR :: DISABLED , true => BCMATCHR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == BCMATCHR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == BCMATCHR :: ENABLED } } # [ doc = "Values that can be written to the field `READY`" ] pub enum READYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl READYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _READYW < 'a > { w : & 'a mut W , } impl < 'a > _READYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( READYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDRESS`" ] pub enum ADDRESSW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ADDRESSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDRESSW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ADDRESSW < 'a > { w : & 'a mut W , } impl < 'a > _ADDRESSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDRESSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ADDRESSW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PAYLOAD`" ] pub enum PAYLOADW { # [ doc = "Disable interrupt on write." ] CLEAR } impl PAYLOADW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PAYLOADW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PAYLOADW < 'a > { w : & 'a mut W , } impl < 'a > _PAYLOADW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PAYLOADW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PAYLOADW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `END`" ] pub enum ENDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ENDW < 'a > { w : & 'a mut W , } impl < 'a > _ENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ENDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DISABLED`" ] pub enum DISABLEDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl DISABLEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DISABLEDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _DISABLEDW < 'a > { w : & 'a mut W , } impl < 'a > _DISABLEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DISABLEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( DISABLEDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DEVMATCH`" ] pub enum DEVMATCHW { # [ doc = "Disable interrupt on write." ] CLEAR } impl DEVMATCHW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DEVMATCHW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _DEVMATCHW < 'a > { w : & 'a mut W , } impl < 'a > _DEVMATCHW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DEVMATCHW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( DEVMATCHW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DEVMISS`" ] pub enum DEVMISSW { # [ doc = "Disable interrupt on write." ] CLEAR } impl DEVMISSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DEVMISSW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _DEVMISSW < 'a > { w : & 'a mut W , } impl < 'a > _DEVMISSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DEVMISSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( DEVMISSW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RSSIEND`" ] pub enum RSSIENDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl RSSIENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RSSIENDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _RSSIENDW < 'a > { w : & 'a mut W , } impl < 'a > _RSSIENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RSSIENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( RSSIENDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BCMATCH`" ] pub enum BCMATCHW { # [ doc = "Disable interrupt on write." ] CLEAR } impl BCMATCHW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BCMATCHW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _BCMATCHW < 'a > { w : & 'a mut W , } impl < 'a > _BCMATCHW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BCMATCHW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( BCMATCHW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on READY event." ] # [ inline ] pub fn ready ( & self ) -> READYR { READYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on ADDRESS event." ] # [ inline ] pub fn address ( & self ) -> ADDRESSR { ADDRESSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Disable interrupt on PAYLOAD event." ] # [ inline ] pub fn payload ( & self ) -> PAYLOADR { PAYLOADR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Disable interrupt on END event." ] # [ inline ] pub fn end ( & self ) -> ENDR { ENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Disable interrupt on DISABLED event." ] # [ inline ] pub fn disabled ( & self ) -> DISABLEDR { DISABLEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Disable interrupt on DEVMATCH event." ] # [ inline ] pub fn devmatch ( & self ) -> DEVMATCHR { DEVMATCHR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Disable interrupt on DEVMISS event." ] # [ inline ] pub fn devmiss ( & self ) -> DEVMISSR { DEVMISSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Disable interrupt on RSSIEND event." ] # [ inline ] pub fn rssiend ( & self ) -> RSSIENDR { RSSIENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Disable interrupt on BCMATCH event." ] # [ inline ] pub fn bcmatch ( & self ) -> BCMATCHR { BCMATCHR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on READY event." ] # [ inline ] pub fn ready ( & mut self ) -> _READYW { _READYW { w : self } } # [ doc = "Bit 1 - Disable interrupt on ADDRESS event." ] # [ inline ] pub fn address ( & mut self ) -> _ADDRESSW { _ADDRESSW { w : self } } # [ doc = "Bit 2 - Disable interrupt on PAYLOAD event." ] # [ inline ] pub fn payload ( & mut self ) -> _PAYLOADW { _PAYLOADW { w : self } } # [ doc = "Bit 3 - Disable interrupt on END event." ] # [ inline ] pub fn end ( & mut self ) -> _ENDW { _ENDW { w : self } } # [ doc = "Bit 4 - Disable interrupt on DISABLED event." ] # [ inline ] pub fn disabled ( & mut self ) -> _DISABLEDW { _DISABLEDW { w : self } } # [ doc = "Bit 5 - Disable interrupt on DEVMATCH event." ] # [ inline ] pub fn devmatch ( & mut self ) -> _DEVMATCHW { _DEVMATCHW { w : self } } # [ doc = "Bit 6 - Disable interrupt on DEVMISS event." ] # [ inline ] pub fn devmiss ( & mut self ) -> _DEVMISSW { _DEVMISSW { w : self } } # [ doc = "Bit 7 - Disable interrupt on RSSIEND event." ] # [ inline ] pub fn rssiend ( & mut self ) -> _RSSIENDW { _RSSIENDW { w : self } } # [ doc = "Bit 10 - Disable interrupt on BCMATCH event." ] # [ inline ] pub fn bcmatch ( & mut self ) -> _BCMATCHW { _BCMATCHW { w : self } } } } # [ doc = "CRC status of received packet." ] pub struct CRCSTATUS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "CRC status of received packet." ] pub mod crcstatus { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: CRCSTATUS { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `CRCSTATUS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CRCSTATUSR { # [ doc = "Packet received with CRC error." ] CRCERROR , # [ doc = "Packet received with CRC ok." ] CRCOK } impl CRCSTATUSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CRCSTATUSR :: CRCERROR => false , CRCSTATUSR :: CRCOK => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CRCSTATUSR { match value { false => CRCSTATUSR :: CRCERROR , true => CRCSTATUSR :: CRCOK , } } # [ doc = "Checks if the value of the field is `CRCERROR`" ] # [ inline ] pub fn is_crcerror ( & self ) -> bool { * self == CRCSTATUSR :: CRCERROR } # [ doc = "Checks if the value of the field is `CRCOK`" ] # [ inline ] pub fn is_crcok ( & self ) -> bool { * self == CRCSTATUSR :: CRCOK } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - CRC status of received packet." ] # [ inline ] pub fn crcstatus ( & self ) -> CRCSTATUSR { CRCSTATUSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "Received address." ] pub struct RXMATCH { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Received address." ] pub mod rxmatch { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: RXMATCH { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct RXMATCHR { bits : u8 , } impl RXMATCHR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Logical address in which previous packet was received." ] # [ inline ] pub fn rxmatch ( & self ) -> RXMATCHR { let bits = { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; RXMATCHR { bits } } } } # [ doc = "Received CRC." ] pub struct RXCRC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Received CRC." ] pub mod rxcrc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: RXCRC { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct RXCRCR { bits : u32 , } impl RXCRCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:23 - CRC field of previously received packet." ] # [ inline ] pub fn rxcrc ( & self ) -> RXCRCR { let bits = { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; RXCRCR { bits } } } } # [ doc = "Device address match index." ] pub struct DAI { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Device address match index." ] pub mod dai { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DAI { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DAIR { bits : u8 , } impl DAIR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DAIW < 'a > { w : & 'a mut W , } impl < 'a > _DAIW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Index (n) of device address (see DAB\\[n\\] and DAP\\[n\\]) that got an address match." ] # [ inline ] pub fn dai ( & self ) -> DAIR { let bits = { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DAIR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Index (n) of device address (see DAB\\[n\\] and DAP\\[n\\]) that got an address match." ] # [ inline ] pub fn dai ( & mut self ) -> _DAIW { _DAIW { w : self } } } } # [ doc = "Packet pointer. Decision point: START task." ] pub struct PACKETPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Packet pointer. Decision point: START task." ] pub mod packetptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PACKETPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Frequency." ] pub struct FREQUENCY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Frequency." ] pub mod frequency { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FREQUENCY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct FREQUENCYR { bits : u8 , } impl FREQUENCYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _FREQUENCYW < 'a > { w : & 'a mut W , } impl < 'a > _FREQUENCYW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:6 - Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task." ] # [ inline ] pub fn frequency ( & self ) -> FREQUENCYR { let bits = { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; FREQUENCYR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x02 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:6 - Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task." ] # [ inline ] pub fn frequency ( & mut self ) -> _FREQUENCYW { _FREQUENCYW { w : self } } } } # [ doc = "Output power." ] pub struct TXPOWER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Output power." ] pub mod txpower { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TXPOWER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `TXPOWER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TXPOWERR { # [ doc = "+4dBm." ] POS4DBM , # [ doc = "0dBm." ] _0DBM , # [ doc = "-4dBm." ] NEG4DBM , # [ doc = "-8dBm." ] NEG8DBM , # [ doc = "-12dBm." ] NEG12DBM , # [ doc = "-16dBm." ] NEG16DBM , # [ doc = "-20dBm." ] NEG20DBM , # [ doc = "-30dBm." ] NEG30DBM , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl TXPOWERR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { TXPOWERR :: POS4DBM => 0x04 , TXPOWERR :: _0DBM => 0 , TXPOWERR :: NEG4DBM => 0xfc , TXPOWERR :: NEG8DBM => 0xf8 , TXPOWERR :: NEG12DBM => 0xf4 , TXPOWERR :: NEG16DBM => 0xf0 , TXPOWERR :: NEG20DBM => 0xec , TXPOWERR :: NEG30DBM => 0xd8 , TXPOWERR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> TXPOWERR { match value { 4 => TXPOWERR :: POS4DBM , 0 => TXPOWERR :: _0DBM , 252 => TXPOWERR :: NEG4DBM , 248 => TXPOWERR :: NEG8DBM , 244 => TXPOWERR :: NEG12DBM , 240 => TXPOWERR :: NEG16DBM , 236 => TXPOWERR :: NEG20DBM , 216 => TXPOWERR :: NEG30DBM , i => TXPOWERR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `POS4DBM`" ] # [ inline ] pub fn is_pos4d_bm ( & self ) -> bool { * self == TXPOWERR :: POS4DBM } # [ doc = "Checks if the value of the field is `_0DBM`" ] # [ inline ] pub fn is_0d_bm ( & self ) -> bool { * self == TXPOWERR :: _0DBM } # [ doc = "Checks if the value of the field is `NEG4DBM`" ] # [ inline ] pub fn is_neg4d_bm ( & self ) -> bool { * self == TXPOWERR :: NEG4DBM } # [ doc = "Checks if the value of the field is `NEG8DBM`" ] # [ inline ] pub fn is_neg8d_bm ( & self ) -> bool { * self == TXPOWERR :: NEG8DBM } # [ doc = "Checks if the value of the field is `NEG12DBM`" ] # [ inline ] pub fn is_neg12d_bm ( & self ) -> bool { * self == TXPOWERR :: NEG12DBM } # [ doc = "Checks if the value of the field is `NEG16DBM`" ] # [ inline ] pub fn is_neg16d_bm ( & self ) -> bool { * self == TXPOWERR :: NEG16DBM } # [ doc = "Checks if the value of the field is `NEG20DBM`" ] # [ inline ] pub fn is_neg20d_bm ( & self ) -> bool { * self == TXPOWERR :: NEG20DBM } # [ doc = "Checks if the value of the field is `NEG30DBM`" ] # [ inline ] pub fn is_neg30d_bm ( & self ) -> bool { * self == TXPOWERR :: NEG30DBM } } # [ doc = "Values that can be written to the field `TXPOWER`" ] pub enum TXPOWERW { # [ doc = "+4dBm." ] POS4DBM , # [ doc = "0dBm." ] _0DBM , # [ doc = "-4dBm." ] NEG4DBM , # [ doc = "-8dBm." ] NEG8DBM , # [ doc = "-12dBm." ] NEG12DBM , # [ doc = "-16dBm." ] NEG16DBM , # [ doc = "-20dBm." ] NEG20DBM , # [ doc = "-30dBm." ] NEG30DBM } impl TXPOWERW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { TXPOWERW :: POS4DBM => 4 , TXPOWERW :: _0DBM => 0 , TXPOWERW :: NEG4DBM => 252 , TXPOWERW :: NEG8DBM => 248 , TXPOWERW :: NEG12DBM => 244 , TXPOWERW :: NEG16DBM => 240 , TXPOWERW :: NEG20DBM => 236 , TXPOWERW :: NEG30DBM => 216 } } } # [ doc = r" Proxy" ] pub struct _TXPOWERW < 'a > { w : & 'a mut W , } impl < 'a > _TXPOWERW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TXPOWERW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "+4dBm." ] # [ inline ] pub fn pos4d_bm ( self ) -> & 'a mut W { self . variant ( TXPOWERW :: POS4DBM ) } # [ doc = "0dBm." ] # [ inline ] pub fn _0d_bm ( self ) -> & 'a mut W { self . variant ( TXPOWERW :: _0DBM ) } # [ doc = "-4dBm." ] # [ inline ] pub fn neg4d_bm ( self ) -> & 'a mut W { self . variant ( TXPOWERW :: NEG4DBM ) } # [ doc = "-8dBm." ] # [ inline ] pub fn neg8d_bm ( self ) -> & 'a mut W { self . variant ( TXPOWERW :: NEG8DBM ) } # [ doc = "-12dBm." ] # [ inline ] pub fn neg12d_bm ( self ) -> & 'a mut W { self . variant ( TXPOWERW :: NEG12DBM ) } # [ doc = "-16dBm." ] # [ inline ] pub fn neg16d_bm ( self ) -> & 'a mut W { self . variant ( TXPOWERW :: NEG16DBM ) } # [ doc = "-20dBm." ] # [ inline ] pub fn neg20d_bm ( self ) -> & 'a mut W { self . variant ( TXPOWERW :: NEG20DBM ) } # [ doc = "-30dBm." ] # [ inline ] pub fn neg30d_bm ( self ) -> & 'a mut W { self . variant ( TXPOWERW :: NEG30DBM ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Radio output power. Decision point: TXEN task." ] # [ inline ] pub fn txpower ( & self ) -> TXPOWERR { TXPOWERR :: _from ( { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Radio output power. Decision point: TXEN task." ] # [ inline ] pub fn txpower ( & mut self ) -> _TXPOWERW { _TXPOWERW { w : self } } } } # [ doc = "Data rate and modulation." ] pub struct MODE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Data rate and modulation." ] pub mod mode { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MODE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "1Mbit/s Nordic propietary radio mode." ] NRF_1MBIT , # [ doc = "2Mbit/s Nordic propietary radio mode." ] NRF_2MBIT , # [ doc = "250kbit/s Nordic propietary radio mode." ] NRF_250KBIT , # [ doc = "1Mbit/s Bluetooth Low Energy" ] BLE_1MBIT } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: NRF_1MBIT => 0 , MODER :: NRF_2MBIT => 0x01 , MODER :: NRF_250KBIT => 0x02 , MODER :: BLE_1MBIT => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: NRF_1MBIT , 1 => MODER :: NRF_2MBIT , 2 => MODER :: NRF_250KBIT , 3 => MODER :: BLE_1MBIT , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `NRF_1MBIT`" ] # [ inline ] pub fn is_nrf_1mbit ( & self ) -> bool { * self == MODER :: NRF_1MBIT } # [ doc = "Checks if the value of the field is `NRF_2MBIT`" ] # [ inline ] pub fn is_nrf_2mbit ( & self ) -> bool { * self == MODER :: NRF_2MBIT } # [ doc = "Checks if the value of the field is `NRF_250KBIT`" ] # [ inline ] pub fn is_nrf_250kbit ( & self ) -> bool { * self == MODER :: NRF_250KBIT } # [ doc = "Checks if the value of the field is `BLE_1MBIT`" ] # [ inline ] pub fn is_ble_1mbit ( & self ) -> bool { * self == MODER :: BLE_1MBIT } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "1Mbit/s Nordic propietary radio mode." ] NRF_1MBIT , # [ doc = "2Mbit/s Nordic propietary radio mode." ] NRF_2MBIT , # [ doc = "250kbit/s Nordic propietary radio mode." ] NRF_250KBIT , # [ doc = "1Mbit/s Bluetooth Low Energy" ] BLE_1MBIT } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: NRF_1MBIT => 0 , MODEW :: NRF_2MBIT => 1 , MODEW :: NRF_250KBIT => 2 , MODEW :: BLE_1MBIT => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "1Mbit/s Nordic propietary radio mode." ] # [ inline ] pub fn nrf_1mbit ( self ) -> & 'a mut W { self . variant ( MODEW :: NRF_1MBIT ) } # [ doc = "2Mbit/s Nordic propietary radio mode." ] # [ inline ] pub fn nrf_2mbit ( self ) -> & 'a mut W { self . variant ( MODEW :: NRF_2MBIT ) } # [ doc = "250kbit/s Nordic propietary radio mode." ] # [ inline ] pub fn nrf_250kbit ( self ) -> & 'a mut W { self . variant ( MODEW :: NRF_250KBIT ) } # [ doc = "1Mbit/s Bluetooth Low Energy" ] # [ inline ] pub fn ble_1mbit ( self ) -> & 'a mut W { self . variant ( MODEW :: BLE_1MBIT ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Radio data rate and modulation setting. Decision point: TXEN or RXEN task." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Radio data rate and modulation setting. Decision point: TXEN or RXEN task." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } } } # [ doc = "Packet configuration 0." ] pub struct PCNF0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Packet configuration 0." ] pub mod pcnf0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PCNF0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct LFLENR { bits : u8 , } impl LFLENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct S0LENR { bits : bool , } impl S0LENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct S1LENR { bits : u8 , } impl S1LENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _LFLENW < 'a > { w : & 'a mut W , } impl < 'a > _LFLENW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _S0LENW < 'a > { w : & 'a mut W , } impl < 'a > _S0LENW < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _S1LENW < 'a > { w : & 'a mut W , } impl < 'a > _S1LENW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:3 - Length of length field in number of bits. Decision point: START task." ] # [ inline ] pub fn lflen ( & self ) -> LFLENR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; LFLENR { bits } } # [ doc = "Bit 8 - Length of S0 field in number of bytes. Decision point: START task." ] # [ inline ] pub fn s0len ( & self ) -> S0LENR { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; S0LENR { bits } } # [ doc = "Bits 16:19 - Length of S1 field in number of bits. Decision point: START task." ] # [ inline ] pub fn s1len ( & self ) -> S1LENR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; S1LENR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:3 - Length of length field in number of bits. Decision point: START task." ] # [ inline ] pub fn lflen ( & mut self ) -> _LFLENW { _LFLENW { w : self } } # [ doc = "Bit 8 - Length of S0 field in number of bytes. Decision point: START task." ] # [ inline ] pub fn s0len ( & mut self ) -> _S0LENW { _S0LENW { w : self } } # [ doc = "Bits 16:19 - Length of S1 field in number of bits. Decision point: START task." ] # [ inline ] pub fn s1len ( & mut self ) -> _S1LENW { _S1LENW { w : self } } } } # [ doc = "Packet configuration 1." ] pub struct PCNF1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Packet configuration 1." ] pub mod pcnf1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PCNF1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MAXLENR { bits : u8 , } impl MAXLENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct STATLENR { bits : u8 , } impl STATLENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct BALENR { bits : u8 , } impl BALENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = "Possible values of the field `ENDIAN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDIANR { # [ doc = "Least significant bit on air first" ] LITTLE , # [ doc = "Most significant bit on air first" ] BIG } impl ENDIANR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDIANR :: LITTLE => false , ENDIANR :: BIG => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDIANR { match value { false => ENDIANR :: LITTLE , true => ENDIANR :: BIG , } } # [ doc = "Checks if the value of the field is `LITTLE`" ] # [ inline ] pub fn is_little ( & self ) -> bool { * self == ENDIANR :: LITTLE } # [ doc = "Checks if the value of the field is `BIG`" ] # [ inline ] pub fn is_big ( & self ) -> bool { * self == ENDIANR :: BIG } } # [ doc = "Possible values of the field `WHITEEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WHITEENR { # [ doc = "Whitening disabled." ] DISABLED , # [ doc = "Whitening enabled." ] ENABLED } impl WHITEENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { WHITEENR :: DISABLED => false , WHITEENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> WHITEENR { match value { false => WHITEENR :: DISABLED , true => WHITEENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == WHITEENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == WHITEENR :: ENABLED } } # [ doc = r" Proxy" ] pub struct _MAXLENW < 'a > { w : & 'a mut W , } impl < 'a > _MAXLENW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _STATLENW < 'a > { w : & 'a mut W , } impl < 'a > _STATLENW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _BALENW < 'a > { w : & 'a mut W , } impl < 'a > _BALENW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENDIAN`" ] pub enum ENDIANW { # [ doc = "Least significant bit on air first" ] LITTLE , # [ doc = "Most significant bit on air first" ] BIG } impl ENDIANW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDIANW :: LITTLE => false , ENDIANW :: BIG => true } } } # [ doc = r" Proxy" ] pub struct _ENDIANW < 'a > { w : & 'a mut W , } impl < 'a > _ENDIANW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDIANW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Least significant bit on air first" ] # [ inline ] pub fn little ( self ) -> & 'a mut W { self . variant ( ENDIANW :: LITTLE ) } # [ doc = "Most significant bit on air first" ] # [ inline ] pub fn big ( self ) -> & 'a mut W { self . variant ( ENDIANW :: BIG ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `WHITEEN`" ] pub enum WHITEENW { # [ doc = "Whitening disabled." ] DISABLED , # [ doc = "Whitening enabled." ] ENABLED } impl WHITEENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { WHITEENW :: DISABLED => false , WHITEENW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _WHITEENW < 'a > { w : & 'a mut W , } impl < 'a > _WHITEENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WHITEENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Whitening disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( WHITEENW :: DISABLED ) } # [ doc = "Whitening enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( WHITEENW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Maximum length of packet payload in number of bytes." ] # [ inline ] pub fn maxlen ( & self ) -> MAXLENR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; MAXLENR { bits } } # [ doc = "Bits 8:15 - Static length in number of bytes. Decision point: START task." ] # [ inline ] pub fn statlen ( & self ) -> STATLENR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; STATLENR { bits } } # [ doc = "Bits 16:18 - Base address length in number of bytes. Decision point: START task." ] # [ inline ] pub fn balen ( & self ) -> BALENR { let bits = { const MASK : u8 = 0x07 ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; BALENR { bits } } # [ doc = "Bit 24 - On air endianness of packet length field. Decision point: START task." ] # [ inline ] pub fn endian ( & self ) -> ENDIANR { ENDIANR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Packet whitening enable." ] # [ inline ] pub fn whiteen ( & self ) -> WHITEENR { WHITEENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Maximum length of packet payload in number of bytes." ] # [ inline ] pub fn maxlen ( & mut self ) -> _MAXLENW { _MAXLENW { w : self } } # [ doc = "Bits 8:15 - Static length in number of bytes. Decision point: START task." ] # [ inline ] pub fn statlen ( & mut self ) -> _STATLENW { _STATLENW { w : self } } # [ doc = "Bits 16:18 - Base address length in number of bytes. Decision point: START task." ] # [ inline ] pub fn balen ( & mut self ) -> _BALENW { _BALENW { w : self } } # [ doc = "Bit 24 - On air endianness of packet length field. Decision point: START task." ] # [ inline ] pub fn endian ( & mut self ) -> _ENDIANW { _ENDIANW { w : self } } # [ doc = "Bit 25 - Packet whitening enable." ] # [ inline ] pub fn whiteen ( & mut self ) -> _WHITEENW { _WHITEENW { w : self } } } } # [ doc = "Radio base address 0. Decision point: START task." ] pub struct BASE0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Radio base address 0. Decision point: START task." ] pub mod base0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: BASE0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Radio base address 1. Decision point: START task." ] pub struct BASE1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Radio base address 1. Decision point: START task." ] pub mod base1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: BASE1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Prefixes bytes for logical addresses 0 to 3." ] pub struct PREFIX0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prefixes bytes for logical addresses 0 to 3." ] pub mod prefix0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PREFIX0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct AP0R { bits : u8 , } impl AP0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct AP1R { bits : u8 , } impl AP1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct AP2R { bits : u8 , } impl AP2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct AP3R { bits : u8 , } impl AP3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _AP0W < 'a > { w : & 'a mut W , } impl < 'a > _AP0W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _AP1W < 'a > { w : & 'a mut W , } impl < 'a > _AP1W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _AP2W < 'a > { w : & 'a mut W , } impl < 'a > _AP2W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _AP3W < 'a > { w : & 'a mut W , } impl < 'a > _AP3W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Address prefix 0. Decision point: START task." ] # [ inline ] pub fn ap0 ( & self ) -> AP0R { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AP0R { bits } } # [ doc = "Bits 8:15 - Address prefix 1. Decision point: START task." ] # [ inline ] pub fn ap1 ( & self ) -> AP1R { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AP1R { bits } } # [ doc = "Bits 16:23 - Address prefix 2. Decision point: START task." ] # [ inline ] pub fn ap2 ( & self ) -> AP2R { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AP2R { bits } } # [ doc = "Bits 24:31 - Address prefix 3. Decision point: START task." ] # [ inline ] pub fn ap3 ( & self ) -> AP3R { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AP3R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Address prefix 0. Decision point: START task." ] # [ inline ] pub fn ap0 ( & mut self ) -> _AP0W { _AP0W { w : self } } # [ doc = "Bits 8:15 - Address prefix 1. Decision point: START task." ] # [ inline ] pub fn ap1 ( & mut self ) -> _AP1W { _AP1W { w : self } } # [ doc = "Bits 16:23 - Address prefix 2. Decision point: START task." ] # [ inline ] pub fn ap2 ( & mut self ) -> _AP2W { _AP2W { w : self } } # [ doc = "Bits 24:31 - Address prefix 3. Decision point: START task." ] # [ inline ] pub fn ap3 ( & mut self ) -> _AP3W { _AP3W { w : self } } } } # [ doc = "Prefixes bytes for logical addresses 4 to 7." ] pub struct PREFIX1 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Prefixes bytes for logical addresses 4 to 7." ] pub mod prefix1 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PREFIX1 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct AP4R { bits : u8 , } impl AP4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct AP5R { bits : u8 , } impl AP5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct AP6R { bits : u8 , } impl AP6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct AP7R { bits : u8 , } impl AP7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _AP4W < 'a > { w : & 'a mut W , } impl < 'a > _AP4W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _AP5W < 'a > { w : & 'a mut W , } impl < 'a > _AP5W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _AP6W < 'a > { w : & 'a mut W , } impl < 'a > _AP6W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _AP7W < 'a > { w : & 'a mut W , } impl < 'a > _AP7W < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Address prefix 4. Decision point: START task." ] # [ inline ] pub fn ap4 ( & self ) -> AP4R { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AP4R { bits } } # [ doc = "Bits 8:15 - Address prefix 5. Decision point: START task." ] # [ inline ] pub fn ap5 ( & self ) -> AP5R { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AP5R { bits } } # [ doc = "Bits 16:23 - Address prefix 6. Decision point: START task." ] # [ inline ] pub fn ap6 ( & self ) -> AP6R { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AP6R { bits } } # [ doc = "Bits 24:31 - Address prefix 7. Decision point: START task." ] # [ inline ] pub fn ap7 ( & self ) -> AP7R { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AP7R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Address prefix 4. Decision point: START task." ] # [ inline ] pub fn ap4 ( & mut self ) -> _AP4W { _AP4W { w : self } } # [ doc = "Bits 8:15 - Address prefix 5. Decision point: START task." ] # [ inline ] pub fn ap5 ( & mut self ) -> _AP5W { _AP5W { w : self } } # [ doc = "Bits 16:23 - Address prefix 6. Decision point: START task." ] # [ inline ] pub fn ap6 ( & mut self ) -> _AP6W { _AP6W { w : self } } # [ doc = "Bits 24:31 - Address prefix 7. Decision point: START task." ] # [ inline ] pub fn ap7 ( & mut self ) -> _AP7W { _AP7W { w : self } } } } # [ doc = "Transmit address select." ] pub struct TXADDRESS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Transmit address select." ] pub mod txaddress { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TXADDRESS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct TXADDRESSR { bits : u8 , } impl TXADDRESSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _TXADDRESSW < 'a > { w : & 'a mut W , } impl < 'a > _TXADDRESSW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Logical address to be used when transmitting a packet. Decision point: START task." ] # [ inline ] pub fn txaddress ( & self ) -> TXADDRESSR { let bits = { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; TXADDRESSR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Logical address to be used when transmitting a packet. Decision point: START task." ] # [ inline ] pub fn txaddress ( & mut self ) -> _TXADDRESSW { _TXADDRESSW { w : self } } } } # [ doc = "Receive address select." ] pub struct RXADDRESSES { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Receive address select." ] pub mod rxaddresses { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RXADDRESSES { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ADDR0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDR0R { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDR0R :: DISABLED => false , ADDR0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDR0R { match value { false => ADDR0R :: DISABLED , true => ADDR0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDR0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDR0R :: ENABLED } } # [ doc = "Possible values of the field `ADDR1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDR1R { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDR1R :: DISABLED => false , ADDR1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDR1R { match value { false => ADDR1R :: DISABLED , true => ADDR1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDR1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDR1R :: ENABLED } } # [ doc = "Possible values of the field `ADDR2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDR2R { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDR2R :: DISABLED => false , ADDR2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDR2R { match value { false => ADDR2R :: DISABLED , true => ADDR2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDR2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDR2R :: ENABLED } } # [ doc = "Possible values of the field `ADDR3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDR3R { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDR3R :: DISABLED => false , ADDR3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDR3R { match value { false => ADDR3R :: DISABLED , true => ADDR3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDR3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDR3R :: ENABLED } } # [ doc = "Possible values of the field `ADDR4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDR4R { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDR4R :: DISABLED => false , ADDR4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDR4R { match value { false => ADDR4R :: DISABLED , true => ADDR4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDR4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDR4R :: ENABLED } } # [ doc = "Possible values of the field `ADDR5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDR5R { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDR5R :: DISABLED => false , ADDR5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDR5R { match value { false => ADDR5R :: DISABLED , true => ADDR5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDR5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDR5R :: ENABLED } } # [ doc = "Possible values of the field `ADDR6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDR6R { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDR6R :: DISABLED => false , ADDR6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDR6R { match value { false => ADDR6R :: DISABLED , true => ADDR6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDR6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDR6R :: ENABLED } } # [ doc = "Possible values of the field `ADDR7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADDR7R { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ADDR7R :: DISABLED => false , ADDR7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ADDR7R { match value { false => ADDR7R :: DISABLED , true => ADDR7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ADDR7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ADDR7R :: ENABLED } } # [ doc = "Values that can be written to the field `ADDR0`" ] pub enum ADDR0W { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDR0W :: DISABLED => false , ADDR0W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDR0W < 'a > { w : & 'a mut W , } impl < 'a > _ADDR0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDR0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Reception disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDR0W :: DISABLED ) } # [ doc = "Reception enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDR0W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDR1`" ] pub enum ADDR1W { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDR1W :: DISABLED => false , ADDR1W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDR1W < 'a > { w : & 'a mut W , } impl < 'a > _ADDR1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDR1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Reception disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDR1W :: DISABLED ) } # [ doc = "Reception enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDR1W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDR2`" ] pub enum ADDR2W { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDR2W :: DISABLED => false , ADDR2W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDR2W < 'a > { w : & 'a mut W , } impl < 'a > _ADDR2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDR2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Reception disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDR2W :: DISABLED ) } # [ doc = "Reception enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDR2W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDR3`" ] pub enum ADDR3W { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDR3W :: DISABLED => false , ADDR3W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDR3W < 'a > { w : & 'a mut W , } impl < 'a > _ADDR3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDR3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Reception disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDR3W :: DISABLED ) } # [ doc = "Reception enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDR3W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDR4`" ] pub enum ADDR4W { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDR4W :: DISABLED => false , ADDR4W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDR4W < 'a > { w : & 'a mut W , } impl < 'a > _ADDR4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDR4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Reception disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDR4W :: DISABLED ) } # [ doc = "Reception enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDR4W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDR5`" ] pub enum ADDR5W { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDR5W :: DISABLED => false , ADDR5W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDR5W < 'a > { w : & 'a mut W , } impl < 'a > _ADDR5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDR5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Reception disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDR5W :: DISABLED ) } # [ doc = "Reception enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDR5W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDR6`" ] pub enum ADDR6W { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDR6W :: DISABLED => false , ADDR6W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDR6W < 'a > { w : & 'a mut W , } impl < 'a > _ADDR6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDR6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Reception disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDR6W :: DISABLED ) } # [ doc = "Reception enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDR6W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ADDR7`" ] pub enum ADDR7W { # [ doc = "Reception disabled." ] DISABLED , # [ doc = "Reception enabled." ] ENABLED } impl ADDR7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ADDR7W :: DISABLED => false , ADDR7W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ADDR7W < 'a > { w : & 'a mut W , } impl < 'a > _ADDR7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ADDR7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Reception disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ADDR7W :: DISABLED ) } # [ doc = "Reception enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ADDR7W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable reception on logical address 0. Decision point: START task." ] # [ inline ] pub fn addr0 ( & self ) -> ADDR0R { ADDR0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable reception on logical address 1. Decision point: START task." ] # [ inline ] pub fn addr1 ( & self ) -> ADDR1R { ADDR1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable reception on logical address 2. Decision point: START task." ] # [ inline ] pub fn addr2 ( & self ) -> ADDR2R { ADDR2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable reception on logical address 3. Decision point: START task." ] # [ inline ] pub fn addr3 ( & self ) -> ADDR3R { ADDR3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Enable reception on logical address 4. Decision point: START task." ] # [ inline ] pub fn addr4 ( & self ) -> ADDR4R { ADDR4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Enable reception on logical address 5. Decision point: START task." ] # [ inline ] pub fn addr5 ( & self ) -> ADDR5R { ADDR5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Enable reception on logical address 6. Decision point: START task." ] # [ inline ] pub fn addr6 ( & self ) -> ADDR6R { ADDR6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Enable reception on logical address 7. Decision point: START task." ] # [ inline ] pub fn addr7 ( & self ) -> ADDR7R { ADDR7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable reception on logical address 0. Decision point: START task." ] # [ inline ] pub fn addr0 ( & mut self ) -> _ADDR0W { _ADDR0W { w : self } } # [ doc = "Bit 1 - Enable reception on logical address 1. Decision point: START task." ] # [ inline ] pub fn addr1 ( & mut self ) -> _ADDR1W { _ADDR1W { w : self } } # [ doc = "Bit 2 - Enable reception on logical address 2. Decision point: START task." ] # [ inline ] pub fn addr2 ( & mut self ) -> _ADDR2W { _ADDR2W { w : self } } # [ doc = "Bit 3 - Enable reception on logical address 3. Decision point: START task." ] # [ inline ] pub fn addr3 ( & mut self ) -> _ADDR3W { _ADDR3W { w : self } } # [ doc = "Bit 4 - Enable reception on logical address 4. Decision point: START task." ] # [ inline ] pub fn addr4 ( & mut self ) -> _ADDR4W { _ADDR4W { w : self } } # [ doc = "Bit 5 - Enable reception on logical address 5. Decision point: START task." ] # [ inline ] pub fn addr5 ( & mut self ) -> _ADDR5W { _ADDR5W { w : self } } # [ doc = "Bit 6 - Enable reception on logical address 6. Decision point: START task." ] # [ inline ] pub fn addr6 ( & mut self ) -> _ADDR6W { _ADDR6W { w : self } } # [ doc = "Bit 7 - Enable reception on logical address 7. Decision point: START task." ] # [ inline ] pub fn addr7 ( & mut self ) -> _ADDR7W { _ADDR7W { w : self } } } } # [ doc = "CRC configuration." ] pub struct CRCCNF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "CRC configuration." ] pub mod crccnf { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CRCCNF { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `LEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LENR { # [ doc = "CRC calculation disabled." ] DISABLED , # [ doc = "One byte long CRC." ] ONE , # [ doc = "Two bytes long CRC." ] TWO , # [ doc = "Three bytes long CRC." ] THREE } impl LENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { LENR :: DISABLED => 0 , LENR :: ONE => 0x01 , LENR :: TWO => 0x02 , LENR :: THREE => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> LENR { match value { 0 => LENR :: DISABLED , 1 => LENR :: ONE , 2 => LENR :: TWO , 3 => LENR :: THREE , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == LENR :: DISABLED } # [ doc = "Checks if the value of the field is `ONE`" ] # [ inline ] pub fn is_one ( & self ) -> bool { * self == LENR :: ONE } # [ doc = "Checks if the value of the field is `TWO`" ] # [ inline ] pub fn is_two ( & self ) -> bool { * self == LENR :: TWO } # [ doc = "Checks if the value of the field is `THREE`" ] # [ inline ] pub fn is_three ( & self ) -> bool { * self == LENR :: THREE } } # [ doc = "Possible values of the field `SKIP_ADDR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SKIP_ADDRR { # [ doc = "Include packet address in CRC calculation." ] INCLUDE , # [ doc = "Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address." ] SKIP } impl SKIP_ADDRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SKIP_ADDRR :: INCLUDE => false , SKIP_ADDRR :: SKIP => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SKIP_ADDRR { match value { false => SKIP_ADDRR :: INCLUDE , true => SKIP_ADDRR :: SKIP , } } # [ doc = "Checks if the value of the field is `INCLUDE`" ] # [ inline ] pub fn is_include ( & self ) -> bool { * self == SKIP_ADDRR :: INCLUDE } # [ doc = "Checks if the value of the field is `SKIP`" ] # [ inline ] pub fn is_skip ( & self ) -> bool { * self == SKIP_ADDRR :: SKIP } } # [ doc = "Values that can be written to the field `LEN`" ] pub enum LENW { # [ doc = "CRC calculation disabled." ] DISABLED , # [ doc = "One byte long CRC." ] ONE , # [ doc = "Two bytes long CRC." ] TWO , # [ doc = "Three bytes long CRC." ] THREE } impl LENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { LENW :: DISABLED => 0 , LENW :: ONE => 1 , LENW :: TWO => 2 , LENW :: THREE => 3 } } } # [ doc = r" Proxy" ] pub struct _LENW < 'a > { w : & 'a mut W , } impl < 'a > _LENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : LENW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "CRC calculation disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( LENW :: DISABLED ) } # [ doc = "One byte long CRC." ] # [ inline ] pub fn one ( self ) -> & 'a mut W { self . variant ( LENW :: ONE ) } # [ doc = "Two bytes long CRC." ] # [ inline ] pub fn two ( self ) -> & 'a mut W { self . variant ( LENW :: TWO ) } # [ doc = "Three bytes long CRC." ] # [ inline ] pub fn three ( self ) -> & 'a mut W { self . variant ( LENW :: THREE ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SKIP_ADDR`" ] pub enum SKIP_ADDRW { # [ doc = "Include packet address in CRC calculation." ] INCLUDE , # [ doc = "Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address." ] SKIP } impl SKIP_ADDRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SKIP_ADDRW :: INCLUDE => false , SKIP_ADDRW :: SKIP => true } } } # [ doc = r" Proxy" ] pub struct _SKIP_ADDRW < 'a > { w : & 'a mut W , } impl < 'a > _SKIP_ADDRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SKIP_ADDRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Include packet address in CRC calculation." ] # [ inline ] pub fn include ( self ) -> & 'a mut W { self . variant ( SKIP_ADDRW :: INCLUDE ) } # [ doc = "Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address." ] # [ inline ] pub fn skip ( self ) -> & 'a mut W { self . variant ( SKIP_ADDRW :: SKIP ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - CRC length. Decision point: START task." ] # [ inline ] pub fn len ( & self ) -> LENR { LENR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 8 - Leave packet address field out of the CRC calculation. Decision point: START task." ] # [ inline ] pub fn skip_addr ( & self ) -> SKIP_ADDRR { SKIP_ADDRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - CRC length. Decision point: START task." ] # [ inline ] pub fn len ( & mut self ) -> _LENW { _LENW { w : self } } # [ doc = "Bit 8 - Leave packet address field out of the CRC calculation. Decision point: START task." ] # [ inline ] pub fn skip_addr ( & mut self ) -> _SKIP_ADDRW { _SKIP_ADDRW { w : self } } } } # [ doc = "CRC polynomial." ] pub struct CRCPOLY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "CRC polynomial." ] pub mod crcpoly { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CRCPOLY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct CRCPOLYR { bits : u32 , } impl CRCPOLYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _CRCPOLYW < 'a > { w : & 'a mut W , } impl < 'a > _CRCPOLYW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x007f_ffff ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 1:23 - CRC polynomial. Decision point: START task." ] # [ inline ] pub fn crcpoly ( & self ) -> CRCPOLYR { let bits = { const MASK : u32 = 0x007f_ffff ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; CRCPOLYR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 1:23 - CRC polynomial. Decision point: START task." ] # [ inline ] pub fn crcpoly ( & mut self ) -> _CRCPOLYW { _CRCPOLYW { w : self } } } } # [ doc = "CRC initial value." ] pub struct CRCINIT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "CRC initial value." ] pub mod crcinit { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CRCINIT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct CRCINITR { bits : u32 , } impl CRCINITR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _CRCINITW < 'a > { w : & 'a mut W , } impl < 'a > _CRCINITW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:23 - Initial value for CRC calculation. Decision point: START task." ] # [ inline ] pub fn crcinit ( & self ) -> CRCINITR { let bits = { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; CRCINITR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:23 - Initial value for CRC calculation. Decision point: START task." ] # [ inline ] pub fn crcinit ( & mut self ) -> _CRCINITW { _CRCINITW { w : self } } } } # [ doc = "Test features enable register." ] pub struct TEST { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Test features enable register." ] pub mod test { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TEST { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CONST_CARRIER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CONST_CARRIERR { # [ doc = "Constant carrier disabled." ] DISABLED , # [ doc = "Constant carrier enabled." ] ENABLED } impl CONST_CARRIERR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CONST_CARRIERR :: DISABLED => false , CONST_CARRIERR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CONST_CARRIERR { match value { false => CONST_CARRIERR :: DISABLED , true => CONST_CARRIERR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CONST_CARRIERR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CONST_CARRIERR :: ENABLED } } # [ doc = "Possible values of the field `PLL_LOCK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PLL_LOCKR { # [ doc = "PLL lock disabled." ] DISABLED , # [ doc = "PLL lock enabled." ] ENABLED } impl PLL_LOCKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PLL_LOCKR :: DISABLED => false , PLL_LOCKR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PLL_LOCKR { match value { false => PLL_LOCKR :: DISABLED , true => PLL_LOCKR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PLL_LOCKR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PLL_LOCKR :: ENABLED } } # [ doc = "Values that can be written to the field `CONST_CARRIER`" ] pub enum CONST_CARRIERW { # [ doc = "Constant carrier disabled." ] DISABLED , # [ doc = "Constant carrier enabled." ] ENABLED } impl CONST_CARRIERW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CONST_CARRIERW :: DISABLED => false , CONST_CARRIERW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CONST_CARRIERW < 'a > { w : & 'a mut W , } impl < 'a > _CONST_CARRIERW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CONST_CARRIERW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Constant carrier disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CONST_CARRIERW :: DISABLED ) } # [ doc = "Constant carrier enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CONST_CARRIERW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PLL_LOCK`" ] pub enum PLL_LOCKW { # [ doc = "PLL lock disabled." ] DISABLED , # [ doc = "PLL lock enabled." ] ENABLED } impl PLL_LOCKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PLL_LOCKW :: DISABLED => false , PLL_LOCKW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _PLL_LOCKW < 'a > { w : & 'a mut W , } impl < 'a > _PLL_LOCKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PLL_LOCKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "PLL lock disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PLL_LOCKW :: DISABLED ) } # [ doc = "PLL lock enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PLL_LOCKW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Constant carrier. Decision point: TXEN task." ] # [ inline ] pub fn const_carrier ( & self ) -> CONST_CARRIERR { CONST_CARRIERR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - PLL lock. Decision point: TXEN or RXEN task." ] # [ inline ] pub fn pll_lock ( & self ) -> PLL_LOCKR { PLL_LOCKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Constant carrier. Decision point: TXEN task." ] # [ inline ] pub fn const_carrier ( & mut self ) -> _CONST_CARRIERW { _CONST_CARRIERW { w : self } } # [ doc = "Bit 1 - PLL lock. Decision point: TXEN or RXEN task." ] # [ inline ] pub fn pll_lock ( & mut self ) -> _PLL_LOCKW { _PLL_LOCKW { w : self } } } } # [ doc = "Inter Frame Spacing in microseconds." ] pub struct TIFS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Inter Frame Spacing in microseconds." ] pub mod tifs { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TIFS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct TIFSR { bits : u8 , } impl TIFSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _TIFSW < 'a > { w : & 'a mut W , } impl < 'a > _TIFSW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Inter frame spacing in microseconds. Decision point: START rask" ] # [ inline ] pub fn tifs ( & self ) -> TIFSR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; TIFSR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Inter frame spacing in microseconds. Decision point: START rask" ] # [ inline ] pub fn tifs ( & mut self ) -> _TIFSW { _TIFSW { w : self } } } } # [ doc = "RSSI sample." ] pub struct RSSISAMPLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "RSSI sample." ] pub mod rssisample { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RSSISAMPLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct RSSISAMPLER { bits : u8 , } impl RSSISAMPLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _RSSISAMPLEW < 'a > { w : & 'a mut W , } impl < 'a > _RSSISAMPLEW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:6 - RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm" ] # [ inline ] pub fn rssisample ( & self ) -> RSSISAMPLER { let bits = { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; RSSISAMPLER { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:6 - RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm" ] # [ inline ] pub fn rssisample ( & mut self ) -> _RSSISAMPLEW { _RSSISAMPLEW { w : self } } } } # [ doc = "Current radio state." ] pub struct STATE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Current radio state." ] pub mod state { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: STATE { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `STATE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STATER { # [ doc = "Radio is in the Disabled state." ] DISABLED , # [ doc = "Radio is in the Rx Ramp Up state." ] RXRU , # [ doc = "Radio is in the Rx Idle state." ] RXIDLE , # [ doc = "Radio is in the Rx state." ] RX , # [ doc = "Radio is in the Rx Disable state." ] RXDISABLE , # [ doc = "Radio is in the Tx Ramp Up state." ] TXRU , # [ doc = "Radio is in the Tx Idle state." ] TXIDLE , # [ doc = "Radio is in the Tx state." ] TX , # [ doc = "Radio is in the Tx Disable state." ] TXDISABLE , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl STATER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { STATER :: DISABLED => 0 , STATER :: RXRU => 0x01 , STATER :: RXIDLE => 0x02 , STATER :: RX => 0x03 , STATER :: RXDISABLE => 0x04 , STATER :: TXRU => 0x09 , STATER :: TXIDLE => 0x0a , STATER :: TX => 0x0b , STATER :: TXDISABLE => 0x0c , STATER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> STATER { match value { 0 => STATER :: DISABLED , 1 => STATER :: RXRU , 2 => STATER :: RXIDLE , 3 => STATER :: RX , 4 => STATER :: RXDISABLE , 9 => STATER :: TXRU , 10 => STATER :: TXIDLE , 11 => STATER :: TX , 12 => STATER :: TXDISABLE , i => STATER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == STATER :: DISABLED } # [ doc = "Checks if the value of the field is `RXRU`" ] # [ inline ] pub fn is_rx_ru ( & self ) -> bool { * self == STATER :: RXRU } # [ doc = "Checks if the value of the field is `RXIDLE`" ] # [ inline ] pub fn is_rx_idle ( & self ) -> bool { * self == STATER :: RXIDLE } # [ doc = "Checks if the value of the field is `RX`" ] # [ inline ] pub fn is_rx ( & self ) -> bool { * self == STATER :: RX } # [ doc = "Checks if the value of the field is `RXDISABLE`" ] # [ inline ] pub fn is_rx_disable ( & self ) -> bool { * self == STATER :: RXDISABLE } # [ doc = "Checks if the value of the field is `TXRU`" ] # [ inline ] pub fn is_tx_ru ( & self ) -> bool { * self == STATER :: TXRU } # [ doc = "Checks if the value of the field is `TXIDLE`" ] # [ inline ] pub fn is_tx_idle ( & self ) -> bool { * self == STATER :: TXIDLE } # [ doc = "Checks if the value of the field is `TX`" ] # [ inline ] pub fn is_tx ( & self ) -> bool { * self == STATER :: TX } # [ doc = "Checks if the value of the field is `TXDISABLE`" ] # [ inline ] pub fn is_tx_disable ( & self ) -> bool { * self == STATER :: TXDISABLE } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:3 - Current radio state." ] # [ inline ] pub fn state ( & self ) -> STATER { STATER :: _from ( { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } } # [ doc = "Data whitening initial value." ] pub struct DATAWHITEIV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Data whitening initial value." ] pub mod datawhiteiv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DATAWHITEIV { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DATAWHITEIVR { bits : u8 , } impl DATAWHITEIVR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DATAWHITEIVW < 'a > { w : & 'a mut W , } impl < 'a > _DATAWHITEIVW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x3f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:5 - Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task." ] # [ inline ] pub fn datawhiteiv ( & self ) -> DATAWHITEIVR { let bits = { const MASK : u8 = 0x3f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DATAWHITEIVR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x40 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:5 - Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task." ] # [ inline ] pub fn datawhiteiv ( & mut self ) -> _DATAWHITEIVW { _DATAWHITEIVW { w : self } } } } # [ doc = "Device address base segment." ] pub struct DAB { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Device address base segment." ] pub mod dab { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DAB { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Device address prefix." ] pub struct DAP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Device address prefix." ] pub mod dap { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DAP { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DAPR { bits : u16 , } impl DAPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _DAPW < 'a > { w : & 'a mut W , } impl < 'a > _DAPW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Device address prefix." ] # [ inline ] pub fn dap ( & self ) -> DAPR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; DAPR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Device address prefix." ] # [ inline ] pub fn dap ( & mut self ) -> _DAPW { _DAPW { w : self } } } } # [ doc = "Device address match configuration." ] pub struct DACNF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Device address match configuration." ] pub mod dacnf { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DACNF { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENA0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENA0R { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENA0R :: DISABLED => false , ENA0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENA0R { match value { false => ENA0R :: DISABLED , true => ENA0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENA0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENA0R :: ENABLED } } # [ doc = "Possible values of the field `ENA1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENA1R { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENA1R :: DISABLED => false , ENA1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENA1R { match value { false => ENA1R :: DISABLED , true => ENA1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENA1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENA1R :: ENABLED } } # [ doc = "Possible values of the field `ENA2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENA2R { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENA2R :: DISABLED => false , ENA2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENA2R { match value { false => ENA2R :: DISABLED , true => ENA2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENA2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENA2R :: ENABLED } } # [ doc = "Possible values of the field `ENA3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENA3R { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENA3R :: DISABLED => false , ENA3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENA3R { match value { false => ENA3R :: DISABLED , true => ENA3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENA3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENA3R :: ENABLED } } # [ doc = "Possible values of the field `ENA4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENA4R { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENA4R :: DISABLED => false , ENA4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENA4R { match value { false => ENA4R :: DISABLED , true => ENA4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENA4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENA4R :: ENABLED } } # [ doc = "Possible values of the field `ENA5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENA5R { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENA5R :: DISABLED => false , ENA5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENA5R { match value { false => ENA5R :: DISABLED , true => ENA5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENA5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENA5R :: ENABLED } } # [ doc = "Possible values of the field `ENA6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENA6R { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENA6R :: DISABLED => false , ENA6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENA6R { match value { false => ENA6R :: DISABLED , true => ENA6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENA6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENA6R :: ENABLED } } # [ doc = "Possible values of the field `ENA7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENA7R { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENA7R :: DISABLED => false , ENA7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENA7R { match value { false => ENA7R :: DISABLED , true => ENA7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENA7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENA7R :: ENABLED } } # [ doc = r" Value of the field" ] pub struct TXADD0R { bits : bool , } impl TXADD0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXADD1R { bits : bool , } impl TXADD1R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXADD2R { bits : bool , } impl TXADD2R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXADD3R { bits : bool , } impl TXADD3R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXADD4R { bits : bool , } impl TXADD4R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXADD5R { bits : bool , } impl TXADD5R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXADD6R { bits : bool , } impl TXADD6R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = r" Value of the field" ] pub struct TXADD7R { bits : bool , } impl TXADD7R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Values that can be written to the field `ENA0`" ] pub enum ENA0W { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENA0W :: DISABLED => false , ENA0W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENA0W < 'a > { w : & 'a mut W , } impl < 'a > _ENA0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENA0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENA0W :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENA0W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENA1`" ] pub enum ENA1W { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENA1W :: DISABLED => false , ENA1W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENA1W < 'a > { w : & 'a mut W , } impl < 'a > _ENA1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENA1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENA1W :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENA1W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENA2`" ] pub enum ENA2W { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENA2W :: DISABLED => false , ENA2W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENA2W < 'a > { w : & 'a mut W , } impl < 'a > _ENA2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENA2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENA2W :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENA2W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENA3`" ] pub enum ENA3W { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENA3W :: DISABLED => false , ENA3W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENA3W < 'a > { w : & 'a mut W , } impl < 'a > _ENA3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENA3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENA3W :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENA3W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENA4`" ] pub enum ENA4W { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENA4W :: DISABLED => false , ENA4W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENA4W < 'a > { w : & 'a mut W , } impl < 'a > _ENA4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENA4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENA4W :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENA4W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENA5`" ] pub enum ENA5W { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENA5W :: DISABLED => false , ENA5W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENA5W < 'a > { w : & 'a mut W , } impl < 'a > _ENA5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENA5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENA5W :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENA5W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENA6`" ] pub enum ENA6W { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENA6W :: DISABLED => false , ENA6W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENA6W < 'a > { w : & 'a mut W , } impl < 'a > _ENA6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENA6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENA6W :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENA6W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENA7`" ] pub enum ENA7W { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENA7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENA7W :: DISABLED => false , ENA7W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENA7W < 'a > { w : & 'a mut W , } impl < 'a > _ENA7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENA7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENA7W :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENA7W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXADD0W < 'a > { w : & 'a mut W , } impl < 'a > _TXADD0W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXADD1W < 'a > { w : & 'a mut W , } impl < 'a > _TXADD1W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXADD2W < 'a > { w : & 'a mut W , } impl < 'a > _TXADD2W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXADD3W < 'a > { w : & 'a mut W , } impl < 'a > _TXADD3W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXADD4W < 'a > { w : & 'a mut W , } impl < 'a > _TXADD4W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXADD5W < 'a > { w : & 'a mut W , } impl < 'a > _TXADD5W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXADD6W < 'a > { w : & 'a mut W , } impl < 'a > _TXADD6W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _TXADD7W < 'a > { w : & 'a mut W , } impl < 'a > _TXADD7W < 'a > { # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable or disable device address matching using device address 0." ] # [ inline ] pub fn ena0 ( & self ) -> ENA0R { ENA0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable or disable device address matching using device address 1." ] # [ inline ] pub fn ena1 ( & self ) -> ENA1R { ENA1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable or disable device address matching using device address 2." ] # [ inline ] pub fn ena2 ( & self ) -> ENA2R { ENA2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable or disable device address matching using device address 3." ] # [ inline ] pub fn ena3 ( & self ) -> ENA3R { ENA3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Enable or disable device address matching using device address 4." ] # [ inline ] pub fn ena4 ( & self ) -> ENA4R { ENA4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Enable or disable device address matching using device address 5." ] # [ inline ] pub fn ena5 ( & self ) -> ENA5R { ENA5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Enable or disable device address matching using device address 6." ] # [ inline ] pub fn ena6 ( & self ) -> ENA6R { ENA6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Enable or disable device address matching using device address 7." ] # [ inline ] pub fn ena7 ( & self ) -> ENA7R { ENA7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - TxAdd for device address 0." ] # [ inline ] pub fn txadd0 ( & self ) -> TXADD0R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXADD0R { bits } } # [ doc = "Bit 9 - TxAdd for device address 1." ] # [ inline ] pub fn txadd1 ( & self ) -> TXADD1R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXADD1R { bits } } # [ doc = "Bit 10 - TxAdd for device address 2." ] # [ inline ] pub fn txadd2 ( & self ) -> TXADD2R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXADD2R { bits } } # [ doc = "Bit 11 - TxAdd for device address 3." ] # [ inline ] pub fn txadd3 ( & self ) -> TXADD3R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXADD3R { bits } } # [ doc = "Bit 12 - TxAdd for device address 4." ] # [ inline ] pub fn txadd4 ( & self ) -> TXADD4R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXADD4R { bits } } # [ doc = "Bit 13 - TxAdd for device address 5." ] # [ inline ] pub fn txadd5 ( & self ) -> TXADD5R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXADD5R { bits } } # [ doc = "Bit 14 - TxAdd for device address 6." ] # [ inline ] pub fn txadd6 ( & self ) -> TXADD6R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXADD6R { bits } } # [ doc = "Bit 15 - TxAdd for device address 7." ] # [ inline ] pub fn txadd7 ( & self ) -> TXADD7R { let bits = { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ; TXADD7R { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable or disable device address matching using device address 0." ] # [ inline ] pub fn ena0 ( & mut self ) -> _ENA0W { _ENA0W { w : self } } # [ doc = "Bit 1 - Enable or disable device address matching using device address 1." ] # [ inline ] pub fn ena1 ( & mut self ) -> _ENA1W { _ENA1W { w : self } } # [ doc = "Bit 2 - Enable or disable device address matching using device address 2." ] # [ inline ] pub fn ena2 ( & mut self ) -> _ENA2W { _ENA2W { w : self } } # [ doc = "Bit 3 - Enable or disable device address matching using device address 3." ] # [ inline ] pub fn ena3 ( & mut self ) -> _ENA3W { _ENA3W { w : self } } # [ doc = "Bit 4 - Enable or disable device address matching using device address 4." ] # [ inline ] pub fn ena4 ( & mut self ) -> _ENA4W { _ENA4W { w : self } } # [ doc = "Bit 5 - Enable or disable device address matching using device address 5." ] # [ inline ] pub fn ena5 ( & mut self ) -> _ENA5W { _ENA5W { w : self } } # [ doc = "Bit 6 - Enable or disable device address matching using device address 6." ] # [ inline ] pub fn ena6 ( & mut self ) -> _ENA6W { _ENA6W { w : self } } # [ doc = "Bit 7 - Enable or disable device address matching using device address 7." ] # [ inline ] pub fn ena7 ( & mut self ) -> _ENA7W { _ENA7W { w : self } } # [ doc = "Bit 8 - TxAdd for device address 0." ] # [ inline ] pub fn txadd0 ( & mut self ) -> _TXADD0W { _TXADD0W { w : self } } # [ doc = "Bit 9 - TxAdd for device address 1." ] # [ inline ] pub fn txadd1 ( & mut self ) -> _TXADD1W { _TXADD1W { w : self } } # [ doc = "Bit 10 - TxAdd for device address 2." ] # [ inline ] pub fn txadd2 ( & mut self ) -> _TXADD2W { _TXADD2W { w : self } } # [ doc = "Bit 11 - TxAdd for device address 3." ] # [ inline ] pub fn txadd3 ( & mut self ) -> _TXADD3W { _TXADD3W { w : self } } # [ doc = "Bit 12 - TxAdd for device address 4." ] # [ inline ] pub fn txadd4 ( & mut self ) -> _TXADD4W { _TXADD4W { w : self } } # [ doc = "Bit 13 - TxAdd for device address 5." ] # [ inline ] pub fn txadd5 ( & mut self ) -> _TXADD5W { _TXADD5W { w : self } } # [ doc = "Bit 14 - TxAdd for device address 6." ] # [ inline ] pub fn txadd6 ( & mut self ) -> _TXADD6W { _TXADD6W { w : self } } # [ doc = "Bit 15 - TxAdd for device address 7." ] # [ inline ] pub fn txadd7 ( & mut self ) -> _TXADD7W { _TXADD7W { w : self } } } } # [ doc = "Bit counter compare." ] pub struct BCC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Bit counter compare." ] pub mod bcc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: BCC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Peripheral power control." ] pub struct POWER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Peripheral power control." ] pub mod power { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: POWER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `POWER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum POWERR { # [ doc = "Module power disabled." ] DISABLED , # [ doc = "Module power enabled." ] ENABLED } impl POWERR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { POWERR :: DISABLED => false , POWERR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> POWERR { match value { false => POWERR :: DISABLED , true => POWERR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == POWERR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == POWERR :: ENABLED } } # [ doc = "Values that can be written to the field `POWER`" ] pub enum POWERW { # [ doc = "Module power disabled." ] DISABLED , # [ doc = "Module power enabled." ] ENABLED } impl POWERW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { POWERW :: DISABLED => false , POWERW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _POWERW < 'a > { w : & 'a mut W , } impl < 'a > _POWERW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : POWERW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Module power disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( POWERW :: DISABLED ) } # [ doc = "Module power enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( POWERW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Peripheral power control." ] # [ inline ] pub fn power ( & self ) -> POWERR { POWERR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Peripheral power control." ] # [ inline ] pub fn power ( & mut self ) -> _POWERW { _POWERW { w : self } } } } } # [ doc = "Universal Asynchronous Receiver/Transmitter, version 1.0." ] pub struct UART0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for UART0 { } impl UART0 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const uart0 :: RegisterBlock { 0x4000_2000 as * const _ } } impl Deref for UART0 { type Target = uart0 :: RegisterBlock ; fn deref ( & self ) -> & uart0 :: RegisterBlock { unsafe { & * UART0 :: ptr ( ) } } } # [ doc = "Universal Asynchronous Receiver/Transmitter, version 1.0." ] pub mod uart0 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start UART receiver." ] pub tasks_startrx : TASKS_STARTRX , # [ doc = "0x04 - Stop UART receiver." ] pub tasks_stoprx : TASKS_STOPRX , # [ doc = "0x08 - Start UART transmitter." ] pub tasks_starttx : TASKS_STARTTX , # [ doc = "0x0c - Stop UART transmitter." ] pub tasks_stoptx : TASKS_STOPTX , _reserved0 : [ u8 ; 12usize ] , # [ doc = "0x1c - Suspend UART." ] pub tasks_suspend : TASKS_SUSPEND , _reserved1 : [ u8 ; 232usize ] , # [ doc = "0x108 - Data received in RXD." ] pub events_rxdrdy : EVENTS_RXDRDY , _reserved2 : [ u8 ; 16usize ] , # [ doc = "0x11c - Data sent from TXD." ] pub events_txdrdy : EVENTS_TXDRDY , _reserved3 : [ u8 ; 4usize ] , # [ doc = "0x124 - Error detected." ] pub events_error : EVENTS_ERROR , _reserved4 : [ u8 ; 28usize ] , # [ doc = "0x144 - Receiver timeout." ] pub events_rxto : EVENTS_RXTO , _reserved5 : [ u8 ; 444usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved6 : [ u8 ; 372usize ] , # [ doc = "0x480 - Error source. Write error field to 1 to clear error." ] pub errorsrc : ERRORSRC , _reserved7 : [ u8 ; 124usize ] , # [ doc = "0x500 - Enable UART and acquire IOs." ] pub enable : ENABLE , _reserved8 : [ u8 ; 4usize ] , # [ doc = "0x508 - Pin select for RTS." ] pub pselrts : PSELRTS , # [ doc = "0x50c - Pin select for TXD." ] pub pseltxd : PSELTXD , # [ doc = "0x510 - Pin select for CTS." ] pub pselcts : PSELCTS , # [ doc = "0x514 - Pin select for RXD." ] pub pselrxd : PSELRXD , # [ doc = "0x518 - RXD register." ] pub rxd : RXD , # [ doc = "0x51c - TXD register." ] pub txd : TXD , _reserved9 : [ u8 ; 4usize ] , # [ doc = "0x524 - UART Baudrate." ] pub baudrate : BAUDRATE , _reserved10 : [ u8 ; 68usize ] , # [ doc = "0x56c - Configuration of parity and hardware flow control register." ] pub config : CONFIG , } # [ doc = "Start UART receiver." ] pub struct TASKS_STARTRX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start UART receiver." ] pub mod tasks_startrx { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STARTRX { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop UART receiver." ] pub struct TASKS_STOPRX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop UART receiver." ] pub mod tasks_stoprx { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOPRX { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Start UART transmitter." ] pub struct TASKS_STARTTX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start UART transmitter." ] pub mod tasks_starttx { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STARTTX { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop UART transmitter." ] pub struct TASKS_STOPTX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop UART transmitter." ] pub mod tasks_stoptx { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOPTX { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Suspend UART." ] pub struct TASKS_SUSPEND { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Suspend UART." ] pub mod tasks_suspend { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_SUSPEND { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Data received in RXD." ] pub struct EVENTS_RXDRDY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Data received in RXD." ] pub mod events_rxdrdy { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_RXDRDY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Data sent from TXD." ] pub struct EVENTS_TXDRDY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Data sent from TXD." ] pub mod events_txdrdy { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_TXDRDY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Error detected." ] pub struct EVENTS_ERROR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Error detected." ] pub mod events_error { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ERROR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Receiver timeout." ] pub struct EVENTS_RXTO { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Receiver timeout." ] pub mod events_rxto { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_RXTO { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `RXDRDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXDRDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RXDRDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RXDRDYR :: DISABLED => false , RXDRDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RXDRDYR { match value { false => RXDRDYR :: DISABLED , true => RXDRDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RXDRDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RXDRDYR :: ENABLED } } # [ doc = "Possible values of the field `TXDRDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TXDRDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl TXDRDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TXDRDYR :: DISABLED => false , TXDRDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TXDRDYR { match value { false => TXDRDYR :: DISABLED , true => TXDRDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TXDRDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TXDRDYR :: ENABLED } } # [ doc = "Possible values of the field `ERROR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERRORR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ERRORR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERRORR :: DISABLED => false , ERRORR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERRORR { match value { false => ERRORR :: DISABLED , true => ERRORR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ERRORR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ERRORR :: ENABLED } } # [ doc = "Possible values of the field `RXTO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXTOR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RXTOR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RXTOR :: DISABLED => false , RXTOR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RXTOR { match value { false => RXTOR :: DISABLED , true => RXTOR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RXTOR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RXTOR :: ENABLED } } # [ doc = "Values that can be written to the field `RXDRDY`" ] pub enum RXDRDYW { # [ doc = "Enable interrupt on write." ] SET } impl RXDRDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RXDRDYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _RXDRDYW < 'a > { w : & 'a mut W , } impl < 'a > _RXDRDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RXDRDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( RXDRDYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `TXDRDY`" ] pub enum TXDRDYW { # [ doc = "Enable interrupt on write." ] SET } impl TXDRDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TXDRDYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _TXDRDYW < 'a > { w : & 'a mut W , } impl < 'a > _TXDRDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TXDRDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( TXDRDYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ERROR`" ] pub enum ERRORW { # [ doc = "Enable interrupt on write." ] SET } impl ERRORW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERRORW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ERRORW < 'a > { w : & 'a mut W , } impl < 'a > _ERRORW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERRORW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ERRORW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RXTO`" ] pub enum RXTOW { # [ doc = "Enable interrupt on write." ] SET } impl RXTOW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RXTOW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _RXTOW < 'a > { w : & 'a mut W , } impl < 'a > _RXTOW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RXTOW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( RXTOW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 2 - Enable interrupt on RXRDY event." ] # [ inline ] pub fn rxdrdy ( & self ) -> RXDRDYR { RXDRDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Enable interrupt on TXRDY event." ] # [ inline ] pub fn txdrdy ( & self ) -> TXDRDYR { TXDRDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Enable interrupt on ERROR event." ] # [ inline ] pub fn error ( & self ) -> ERRORR { ERRORR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Enable interrupt on RXTO event." ] # [ inline ] pub fn rxto ( & self ) -> RXTOR { RXTOR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Enable interrupt on RXRDY event." ] # [ inline ] pub fn rxdrdy ( & mut self ) -> _RXDRDYW { _RXDRDYW { w : self } } # [ doc = "Bit 7 - Enable interrupt on TXRDY event." ] # [ inline ] pub fn txdrdy ( & mut self ) -> _TXDRDYW { _TXDRDYW { w : self } } # [ doc = "Bit 9 - Enable interrupt on ERROR event." ] # [ inline ] pub fn error ( & mut self ) -> _ERRORW { _ERRORW { w : self } } # [ doc = "Bit 17 - Enable interrupt on RXTO event." ] # [ inline ] pub fn rxto ( & mut self ) -> _RXTOW { _RXTOW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `RXDRDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXDRDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RXDRDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RXDRDYR :: DISABLED => false , RXDRDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RXDRDYR { match value { false => RXDRDYR :: DISABLED , true => RXDRDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RXDRDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RXDRDYR :: ENABLED } } # [ doc = "Possible values of the field `TXDRDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TXDRDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl TXDRDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TXDRDYR :: DISABLED => false , TXDRDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TXDRDYR { match value { false => TXDRDYR :: DISABLED , true => TXDRDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TXDRDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TXDRDYR :: ENABLED } } # [ doc = "Possible values of the field `ERROR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERRORR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ERRORR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERRORR :: DISABLED => false , ERRORR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERRORR { match value { false => ERRORR :: DISABLED , true => ERRORR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ERRORR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ERRORR :: ENABLED } } # [ doc = "Possible values of the field `RXTO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXTOR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RXTOR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RXTOR :: DISABLED => false , RXTOR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RXTOR { match value { false => RXTOR :: DISABLED , true => RXTOR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RXTOR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RXTOR :: ENABLED } } # [ doc = "Values that can be written to the field `RXDRDY`" ] pub enum RXDRDYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl RXDRDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RXDRDYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _RXDRDYW < 'a > { w : & 'a mut W , } impl < 'a > _RXDRDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RXDRDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( RXDRDYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `TXDRDY`" ] pub enum TXDRDYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl TXDRDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TXDRDYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _TXDRDYW < 'a > { w : & 'a mut W , } impl < 'a > _TXDRDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TXDRDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( TXDRDYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ERROR`" ] pub enum ERRORW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ERRORW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERRORW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ERRORW < 'a > { w : & 'a mut W , } impl < 'a > _ERRORW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERRORW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ERRORW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RXTO`" ] pub enum RXTOW { # [ doc = "Disable interrupt on write." ] CLEAR } impl RXTOW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RXTOW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _RXTOW < 'a > { w : & 'a mut W , } impl < 'a > _RXTOW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RXTOW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( RXTOW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 2 - Disable interrupt on RXRDY event." ] # [ inline ] pub fn rxdrdy ( & self ) -> RXDRDYR { RXDRDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Disable interrupt on TXRDY event." ] # [ inline ] pub fn txdrdy ( & self ) -> TXDRDYR { TXDRDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Disable interrupt on ERROR event." ] # [ inline ] pub fn error ( & self ) -> ERRORR { ERRORR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Disable interrupt on RXTO event." ] # [ inline ] pub fn rxto ( & self ) -> RXTOR { RXTOR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Disable interrupt on RXRDY event." ] # [ inline ] pub fn rxdrdy ( & mut self ) -> _RXDRDYW { _RXDRDYW { w : self } } # [ doc = "Bit 7 - Disable interrupt on TXRDY event." ] # [ inline ] pub fn txdrdy ( & mut self ) -> _TXDRDYW { _TXDRDYW { w : self } } # [ doc = "Bit 9 - Disable interrupt on ERROR event." ] # [ inline ] pub fn error ( & mut self ) -> _ERRORW { _ERRORW { w : self } } # [ doc = "Bit 17 - Disable interrupt on RXTO event." ] # [ inline ] pub fn rxto ( & mut self ) -> _RXTOW { _RXTOW { w : self } } } } # [ doc = "Error source. Write error field to 1 to clear error." ] pub struct ERRORSRC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Error source. Write error field to 1 to clear error." ] pub mod errorsrc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ERRORSRC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `OVERRUN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OVERRUNR { # [ doc = "Error not present." ] NOTPRESENT , # [ doc = "Error present." ] PRESENT } impl OVERRUNR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OVERRUNR :: NOTPRESENT => false , OVERRUNR :: PRESENT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OVERRUNR { match value { false => OVERRUNR :: NOTPRESENT , true => OVERRUNR :: PRESENT , } } # [ doc = "Checks if the value of the field is `NOTPRESENT`" ] # [ inline ] pub fn is_not_present ( & self ) -> bool { * self == OVERRUNR :: NOTPRESENT } # [ doc = "Checks if the value of the field is `PRESENT`" ] # [ inline ] pub fn is_present ( & self ) -> bool { * self == OVERRUNR :: PRESENT } } # [ doc = "Possible values of the field `PARITY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PARITYR { # [ doc = "Error not present." ] NOTPRESENT , # [ doc = "Error present." ] PRESENT } impl PARITYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PARITYR :: NOTPRESENT => false , PARITYR :: PRESENT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PARITYR { match value { false => PARITYR :: NOTPRESENT , true => PARITYR :: PRESENT , } } # [ doc = "Checks if the value of the field is `NOTPRESENT`" ] # [ inline ] pub fn is_not_present ( & self ) -> bool { * self == PARITYR :: NOTPRESENT } # [ doc = "Checks if the value of the field is `PRESENT`" ] # [ inline ] pub fn is_present ( & self ) -> bool { * self == PARITYR :: PRESENT } } # [ doc = "Possible values of the field `FRAMING`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FRAMINGR { # [ doc = "Error not present." ] NOTPRESENT , # [ doc = "Error present." ] PRESENT } impl FRAMINGR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { FRAMINGR :: NOTPRESENT => false , FRAMINGR :: PRESENT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> FRAMINGR { match value { false => FRAMINGR :: NOTPRESENT , true => FRAMINGR :: PRESENT , } } # [ doc = "Checks if the value of the field is `NOTPRESENT`" ] # [ inline ] pub fn is_not_present ( & self ) -> bool { * self == FRAMINGR :: NOTPRESENT } # [ doc = "Checks if the value of the field is `PRESENT`" ] # [ inline ] pub fn is_present ( & self ) -> bool { * self == FRAMINGR :: PRESENT } } # [ doc = "Possible values of the field `BREAK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BREAKR { # [ doc = "Error not present." ] NOTPRESENT , # [ doc = "Error present." ] PRESENT } impl BREAKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BREAKR :: NOTPRESENT => false , BREAKR :: PRESENT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BREAKR { match value { false => BREAKR :: NOTPRESENT , true => BREAKR :: PRESENT , } } # [ doc = "Checks if the value of the field is `NOTPRESENT`" ] # [ inline ] pub fn is_not_present ( & self ) -> bool { * self == BREAKR :: NOTPRESENT } # [ doc = "Checks if the value of the field is `PRESENT`" ] # [ inline ] pub fn is_present ( & self ) -> bool { * self == BREAKR :: PRESENT } } # [ doc = "Values that can be written to the field `OVERRUN`" ] pub enum OVERRUNW { # [ doc = "Clear error on write." ] CLEAR } impl OVERRUNW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OVERRUNW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _OVERRUNW < 'a > { w : & 'a mut W , } impl < 'a > _OVERRUNW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OVERRUNW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clear error on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( OVERRUNW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PARITY`" ] pub enum PARITYW { # [ doc = "Clear error on write." ] CLEAR } impl PARITYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PARITYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PARITYW < 'a > { w : & 'a mut W , } impl < 'a > _PARITYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PARITYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clear error on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PARITYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `FRAMING`" ] pub enum FRAMINGW { # [ doc = "Clear error on write." ] CLEAR } impl FRAMINGW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { FRAMINGW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _FRAMINGW < 'a > { w : & 'a mut W , } impl < 'a > _FRAMINGW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FRAMINGW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clear error on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( FRAMINGW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BREAK`" ] pub enum BREAKW { # [ doc = "Clear error on write." ] CLEAR } impl BREAKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BREAKW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _BREAKW < 'a > { w : & 'a mut W , } impl < 'a > _BREAKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BREAKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clear error on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( BREAKW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - A start bit is received while the previous data still lies in RXD. (Data loss)." ] # [ inline ] pub fn overrun ( & self ) -> OVERRUNR { OVERRUNR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - A character with bad parity is received. Only checked if HW parity control is enabled." ] # [ inline ] pub fn parity ( & self ) -> PARITYR { PARITYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - A valid stop bit is not detected on the serial data input after all bits in a character have been received." ] # [ inline ] pub fn framing ( & self ) -> FRAMINGR { FRAMINGR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - The serial data input is '0' for longer than the length of a data frame." ] # [ inline ] pub fn break_ ( & self ) -> BREAKR { BREAKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - A start bit is received while the previous data still lies in RXD. (Data loss)." ] # [ inline ] pub fn overrun ( & mut self ) -> _OVERRUNW { _OVERRUNW { w : self } } # [ doc = "Bit 1 - A character with bad parity is received. Only checked if HW parity control is enabled." ] # [ inline ] pub fn parity ( & mut self ) -> _PARITYW { _PARITYW { w : self } } # [ doc = "Bit 2 - A valid stop bit is not detected on the serial data input after all bits in a character have been received." ] # [ inline ] pub fn framing ( & mut self ) -> _FRAMINGW { _FRAMINGW { w : self } } # [ doc = "Bit 3 - The serial data input is '0' for longer than the length of a data frame." ] # [ inline ] pub fn break_ ( & mut self ) -> _BREAKW { _BREAKW { w : self } } } } # [ doc = "Enable UART and acquire IOs." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable UART and acquire IOs." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "UART disabled." ] DISABLED , # [ doc = "UART enabled." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ENABLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ENABLER :: DISABLED => 0 , ENABLER :: ENABLED => 0x04 , ENABLER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ENABLER { match value { 0 => ENABLER :: DISABLED , 4 => ENABLER :: ENABLED , i => ENABLER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "UART disabled." ] DISABLED , # [ doc = "UART enabled." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ENABLEW :: DISABLED => 0 , ENABLEW :: ENABLED => 4 } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "UART disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "UART enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Enable or disable UART and acquire IOs." ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Enable or disable UART and acquire IOs." ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "Pin select for RTS." ] pub struct PSELRTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for RTS." ] pub mod pselrts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELRTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for TXD." ] pub struct PSELTXD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for TXD." ] pub mod pseltxd { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELTXD { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for CTS." ] pub struct PSELCTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for CTS." ] pub mod pselcts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELCTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for RXD." ] pub struct PSELRXD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for RXD." ] pub mod pselrxd { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELRXD { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "RXD register." ] pub struct RXD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "RXD register." ] pub mod rxd { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: RXD { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct RXDR { bits : u8 , } impl RXDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - RX data from previous transfer. Double buffered." ] # [ inline ] pub fn rxd ( & self ) -> RXDR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; RXDR { bits } } } } # [ doc = "TXD register." ] pub struct TXD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "TXD register." ] pub mod txd { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TXD { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = r" Proxy" ] pub struct _TXDW < 'a > { w : & 'a mut W , } impl < 'a > _TXDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - TX data for transfer." ] # [ inline ] pub fn txd ( & mut self ) -> _TXDW { _TXDW { w : self } } } } # [ doc = "UART Baudrate." ] pub struct BAUDRATE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "UART Baudrate." ] pub mod baudrate { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: BAUDRATE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `BAUDRATE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BAUDRATER { # [ doc = "1200 baud." ] BAUD1200 , # [ doc = "2400 baud." ] BAUD2400 , # [ doc = "4800 baud." ] BAUD4800 , # [ doc = "9600 baud." ] BAUD9600 , # [ doc = "14400 baud." ] BAUD14400 , # [ doc = "19200 baud." ] BAUD19200 , # [ doc = "28800 baud." ] BAUD28800 , # [ doc = "38400 baud." ] BAUD38400 , # [ doc = "57600 baud." ] BAUD57600 , # [ doc = "76800 baud." ] BAUD76800 , # [ doc = "115200 baud." ] BAUD115200 , # [ doc = "230400 baud." ] BAUD230400 , # [ doc = "250000 baud." ] BAUD250000 , # [ doc = "460800 baud." ] BAUD460800 , # [ doc = "921600 baud." ] BAUD921600 , # [ doc = "1M baud." ] BAUD1M , # [ doc = r" Reserved" ] _Reserved ( u32 ) } impl BAUDRATER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { match * self { BAUDRATER :: BAUD1200 => 0x0004_f000 , BAUDRATER :: BAUD2400 => 0x0009_d000 , BAUDRATER :: BAUD4800 => 0x0013_b000 , BAUDRATER :: BAUD9600 => 0x0027_5000 , BAUDRATER :: BAUD14400 => 0x003b_0000 , BAUDRATER :: BAUD19200 => 0x004e_a000 , BAUDRATER :: BAUD28800 => 0x0075_f000 , BAUDRATER :: BAUD38400 => 0x009d_5000 , BAUDRATER :: BAUD57600 => 0x00eb_f000 , BAUDRATER :: BAUD76800 => 0x013a_9000 , BAUDRATER :: BAUD115200 => 0x01d7_e000 , BAUDRATER :: BAUD230400 => 0x03af_b000 , BAUDRATER :: BAUD250000 => 0x0400_0000 , BAUDRATER :: BAUD460800 => 0x075f_7000 , BAUDRATER :: BAUD921600 => 0x0ebe_dfa4 , BAUDRATER :: BAUD1M => 0x1000_0000 , BAUDRATER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u32 ) -> BAUDRATER { match value { 323584 => BAUDRATER :: BAUD1200 , 643072 => BAUDRATER :: BAUD2400 , 1290240 => BAUDRATER :: BAUD4800 , 2576384 => BAUDRATER :: BAUD9600 , 3866624 => BAUDRATER :: BAUD14400 , 5152768 => BAUDRATER :: BAUD19200 , 7729152 => BAUDRATER :: BAUD28800 , 10309632 => BAUDRATER :: BAUD38400 , 15462400 => BAUDRATER :: BAUD57600 , 20615168 => BAUDRATER :: BAUD76800 , 30924800 => BAUDRATER :: BAUD115200 , 61845504 => BAUDRATER :: BAUD230400 , 67108864 => BAUDRATER :: BAUD250000 , 123695104 => BAUDRATER :: BAUD460800 , 247390116 => BAUDRATER :: BAUD921600 , 268435456 => BAUDRATER :: BAUD1M , i => BAUDRATER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `BAUD1200`" ] # [ inline ] pub fn is_baud1200 ( & self ) -> bool { * self == BAUDRATER :: BAUD1200 } # [ doc = "Checks if the value of the field is `BAUD2400`" ] # [ inline ] pub fn is_baud2400 ( & self ) -> bool { * self == BAUDRATER :: BAUD2400 } # [ doc = "Checks if the value of the field is `BAUD4800`" ] # [ inline ] pub fn is_baud4800 ( & self ) -> bool { * self == BAUDRATER :: BAUD4800 } # [ doc = "Checks if the value of the field is `BAUD9600`" ] # [ inline ] pub fn is_baud9600 ( & self ) -> bool { * self == BAUDRATER :: BAUD9600 } # [ doc = "Checks if the value of the field is `BAUD14400`" ] # [ inline ] pub fn is_baud14400 ( & self ) -> bool { * self == BAUDRATER :: BAUD14400 } # [ doc = "Checks if the value of the field is `BAUD19200`" ] # [ inline ] pub fn is_baud19200 ( & self ) -> bool { * self == BAUDRATER :: BAUD19200 } # [ doc = "Checks if the value of the field is `BAUD28800`" ] # [ inline ] pub fn is_baud28800 ( & self ) -> bool { * self == BAUDRATER :: BAUD28800 } # [ doc = "Checks if the value of the field is `BAUD38400`" ] # [ inline ] pub fn is_baud38400 ( & self ) -> bool { * self == BAUDRATER :: BAUD38400 } # [ doc = "Checks if the value of the field is `BAUD57600`" ] # [ inline ] pub fn is_baud57600 ( & self ) -> bool { * self == BAUDRATER :: BAUD57600 } # [ doc = "Checks if the value of the field is `BAUD76800`" ] # [ inline ] pub fn is_baud76800 ( & self ) -> bool { * self == BAUDRATER :: BAUD76800 } # [ doc = "Checks if the value of the field is `BAUD115200`" ] # [ inline ] pub fn is_baud115200 ( & self ) -> bool { * self == BAUDRATER :: BAUD115200 } # [ doc = "Checks if the value of the field is `BAUD230400`" ] # [ inline ] pub fn is_baud230400 ( & self ) -> bool { * self == BAUDRATER :: BAUD230400 } # [ doc = "Checks if the value of the field is `BAUD250000`" ] # [ inline ] pub fn is_baud250000 ( & self ) -> bool { * self == BAUDRATER :: BAUD250000 } # [ doc = "Checks if the value of the field is `BAUD460800`" ] # [ inline ] pub fn is_baud460800 ( & self ) -> bool { * self == BAUDRATER :: BAUD460800 } # [ doc = "Checks if the value of the field is `BAUD921600`" ] # [ inline ] pub fn is_baud921600 ( & self ) -> bool { * self == BAUDRATER :: BAUD921600 } # [ doc = "Checks if the value of the field is `BAUD1M`" ] # [ inline ] pub fn is_baud1m ( & self ) -> bool { * self == BAUDRATER :: BAUD1M } } # [ doc = "Values that can be written to the field `BAUDRATE`" ] pub enum BAUDRATEW { # [ doc = "1200 baud." ] BAUD1200 , # [ doc = "2400 baud." ] BAUD2400 , # [ doc = "4800 baud." ] BAUD4800 , # [ doc = "9600 baud." ] BAUD9600 , # [ doc = "14400 baud." ] BAUD14400 , # [ doc = "19200 baud." ] BAUD19200 , # [ doc = "28800 baud." ] BAUD28800 , # [ doc = "38400 baud." ] BAUD38400 , # [ doc = "57600 baud." ] BAUD57600 , # [ doc = "76800 baud." ] BAUD76800 , # [ doc = "115200 baud." ] BAUD115200 , # [ doc = "230400 baud." ] BAUD230400 , # [ doc = "250000 baud." ] BAUD250000 , # [ doc = "460800 baud." ] BAUD460800 , # [ doc = "921600 baud." ] BAUD921600 , # [ doc = "1M baud." ] BAUD1M } impl BAUDRATEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u32 { match * self { BAUDRATEW :: BAUD1200 => 323584 , BAUDRATEW :: BAUD2400 => 643072 , BAUDRATEW :: BAUD4800 => 1290240 , BAUDRATEW :: BAUD9600 => 2576384 , BAUDRATEW :: BAUD14400 => 3866624 , BAUDRATEW :: BAUD19200 => 5152768 , BAUDRATEW :: BAUD28800 => 7729152 , BAUDRATEW :: BAUD38400 => 10309632 , BAUDRATEW :: BAUD57600 => 15462400 , BAUDRATEW :: BAUD76800 => 20615168 , BAUDRATEW :: BAUD115200 => 30924800 , BAUDRATEW :: BAUD230400 => 61845504 , BAUDRATEW :: BAUD250000 => 67108864 , BAUDRATEW :: BAUD460800 => 123695104 , BAUDRATEW :: BAUD921600 => 247390116 , BAUDRATEW :: BAUD1M => 268435456 } } } # [ doc = r" Proxy" ] pub struct _BAUDRATEW < 'a > { w : & 'a mut W , } impl < 'a > _BAUDRATEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BAUDRATEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "1200 baud." ] # [ inline ] pub fn baud1200 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD1200 ) } # [ doc = "2400 baud." ] # [ inline ] pub fn baud2400 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD2400 ) } # [ doc = "4800 baud." ] # [ inline ] pub fn baud4800 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD4800 ) } # [ doc = "9600 baud." ] # [ inline ] pub fn baud9600 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD9600 ) } # [ doc = "14400 baud." ] # [ inline ] pub fn baud14400 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD14400 ) } # [ doc = "19200 baud." ] # [ inline ] pub fn baud19200 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD19200 ) } # [ doc = "28800 baud." ] # [ inline ] pub fn baud28800 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD28800 ) } # [ doc = "38400 baud." ] # [ inline ] pub fn baud38400 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD38400 ) } # [ doc = "57600 baud." ] # [ inline ] pub fn baud57600 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD57600 ) } # [ doc = "76800 baud." ] # [ inline ] pub fn baud76800 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD76800 ) } # [ doc = "115200 baud." ] # [ inline ] pub fn baud115200 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD115200 ) } # [ doc = "230400 baud." ] # [ inline ] pub fn baud230400 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD230400 ) } # [ doc = "250000 baud." ] # [ inline ] pub fn baud250000 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD250000 ) } # [ doc = "460800 baud." ] # [ inline ] pub fn baud460800 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD460800 ) } # [ doc = "921600 baud." ] # [ inline ] pub fn baud921600 ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD921600 ) } # [ doc = "1M baud." ] # [ inline ] pub fn baud1m ( self ) -> & 'a mut W { self . variant ( BAUDRATEW :: BAUD1M ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - UART baudrate." ] # [ inline ] pub fn baudrate ( & self ) -> BAUDRATER { BAUDRATER :: _from ( { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - UART baudrate." ] # [ inline ] pub fn baudrate ( & mut self ) -> _BAUDRATEW { _BAUDRATEW { w : self } } } } # [ doc = "Configuration of parity and hardware flow control register." ] pub struct CONFIG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Configuration of parity and hardware flow control register." ] pub mod config { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONFIG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `HWFC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HWFCR { # [ doc = "Hardware flow control disabled." ] DISABLED , # [ doc = "Hardware flow control enabled." ] ENABLED } impl HWFCR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HWFCR :: DISABLED => false , HWFCR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HWFCR { match value { false => HWFCR :: DISABLED , true => HWFCR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == HWFCR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == HWFCR :: ENABLED } } # [ doc = "Possible values of the field `PARITY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PARITYR { # [ doc = "Parity bit excluded." ] EXCLUDED , # [ doc = "Parity bit included." ] INCLUDED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl PARITYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PARITYR :: EXCLUDED => 0 , PARITYR :: INCLUDED => 0x07 , PARITYR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PARITYR { match value { 0 => PARITYR :: EXCLUDED , 7 => PARITYR :: INCLUDED , i => PARITYR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == PARITYR :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == PARITYR :: INCLUDED } } # [ doc = "Values that can be written to the field `HWFC`" ] pub enum HWFCW { # [ doc = "Hardware flow control disabled." ] DISABLED , # [ doc = "Hardware flow control enabled." ] ENABLED } impl HWFCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HWFCW :: DISABLED => false , HWFCW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _HWFCW < 'a > { w : & 'a mut W , } impl < 'a > _HWFCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HWFCW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Hardware flow control disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( HWFCW :: DISABLED ) } # [ doc = "Hardware flow control enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( HWFCW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PARITY`" ] pub enum PARITYW { # [ doc = "Parity bit excluded." ] EXCLUDED , # [ doc = "Parity bit included." ] INCLUDED } impl PARITYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PARITYW :: EXCLUDED => 0 , PARITYW :: INCLUDED => 7 } } } # [ doc = r" Proxy" ] pub struct _PARITYW < 'a > { w : & 'a mut W , } impl < 'a > _PARITYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PARITYW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Parity bit excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( PARITYW :: EXCLUDED ) } # [ doc = "Parity bit included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( PARITYW :: INCLUDED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Hardware flow control." ] # [ inline ] pub fn hwfc ( & self ) -> HWFCR { HWFCR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 1:3 - Include parity bit." ] # [ inline ] pub fn parity ( & self ) -> PARITYR { PARITYR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Hardware flow control." ] # [ inline ] pub fn hwfc ( & mut self ) -> _HWFCW { _HWFCW { w : self } } # [ doc = "Bits 1:3 - Include parity bit." ] # [ inline ] pub fn parity ( & mut self ) -> _PARITYW { _PARITYW { w : self } } } } } # [ doc = "SPI master 0." ] pub struct SPI0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SPI0 { } impl SPI0 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const spi0 :: RegisterBlock { 0x4000_3000 as * const _ } } impl Deref for SPI0 { type Target = spi0 :: RegisterBlock ; fn deref ( & self ) -> & spi0 :: RegisterBlock { unsafe { & * SPI0 :: ptr ( ) } } } # [ doc = "SPI master 0." ] pub mod spi0 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 264usize ] , # [ doc = "0x108 - TXD byte sent and RXD byte received." ] pub events_ready : EVENTS_READY , _reserved1 : [ u8 ; 504usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved2 : [ u8 ; 500usize ] , # [ doc = "0x500 - Enable SPI." ] pub enable : ENABLE , _reserved3 : [ u8 ; 4usize ] , # [ doc = "0x508 - Pin select for SCK." ] pub pselsck : PSELSCK , # [ doc = "0x50c - Pin select for MOSI." ] pub pselmosi : PSELMOSI , # [ doc = "0x510 - Pin select for MISO." ] pub pselmiso : PSELMISO , _reserved4 : [ u8 ; 4usize ] , # [ doc = "0x518 - RX data." ] pub rxd : RXD , # [ doc = "0x51c - TX data." ] pub txd : TXD , _reserved5 : [ u8 ; 4usize ] , # [ doc = "0x524 - SPI frequency" ] pub frequency : FREQUENCY , _reserved6 : [ u8 ; 44usize ] , # [ doc = "0x554 - Configuration register." ] pub config : CONFIG , } # [ doc = "TXD byte sent and RXD byte received." ] pub struct EVENTS_READY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "TXD byte sent and RXD byte received." ] pub mod events_ready { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_READY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl READYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READYR :: DISABLED => false , READYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READYR { match value { false => READYR :: DISABLED , true => READYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READYR :: ENABLED } } # [ doc = "Values that can be written to the field `READY`" ] pub enum READYW { # [ doc = "Enable interrupt on write." ] SET } impl READYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _READYW < 'a > { w : & 'a mut W , } impl < 'a > _READYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( READYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 2 - Enable interrupt on READY event." ] # [ inline ] pub fn ready ( & self ) -> READYR { READYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Enable interrupt on READY event." ] # [ inline ] pub fn ready ( & mut self ) -> _READYW { _READYW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl READYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READYR :: DISABLED => false , READYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READYR { match value { false => READYR :: DISABLED , true => READYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READYR :: ENABLED } } # [ doc = "Values that can be written to the field `READY`" ] pub enum READYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl READYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _READYW < 'a > { w : & 'a mut W , } impl < 'a > _READYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( READYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 2 - Disable interrupt on READY event." ] # [ inline ] pub fn ready ( & self ) -> READYR { READYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Disable interrupt on READY event." ] # [ inline ] pub fn ready ( & mut self ) -> _READYW { _READYW { w : self } } } } # [ doc = "Enable SPI." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable SPI." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "Disabled SPI." ] DISABLED , # [ doc = "Enable SPI." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ENABLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ENABLER :: DISABLED => 0 , ENABLER :: ENABLED => 0x01 , ENABLER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ENABLER { match value { 0 => ENABLER :: DISABLED , 1 => ENABLER :: ENABLED , i => ENABLER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "Disabled SPI." ] DISABLED , # [ doc = "Enable SPI." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ENABLEW :: DISABLED => 0 , ENABLEW :: ENABLED => 1 } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled SPI." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "Enable SPI." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Enable or disable SPI." ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Enable or disable SPI." ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "Pin select for SCK." ] pub struct PSELSCK { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for SCK." ] pub mod pselsck { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELSCK { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for MOSI." ] pub struct PSELMOSI { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for MOSI." ] pub mod pselmosi { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELMOSI { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for MISO." ] pub struct PSELMISO { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for MISO." ] pub mod pselmiso { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELMISO { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "RX data." ] pub struct RXD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "RX data." ] pub mod rxd { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RXD { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct RXDR { bits : u8 , } impl RXDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _RXDW < 'a > { w : & 'a mut W , } impl < 'a > _RXDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - RX data from last transfer." ] # [ inline ] pub fn rxd ( & self ) -> RXDR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; RXDR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - RX data from last transfer." ] # [ inline ] pub fn rxd ( & mut self ) -> _RXDW { _RXDW { w : self } } } } # [ doc = "TX data." ] pub struct TXD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "TX data." ] pub mod txd { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TXD { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct TXDR { bits : u8 , } impl TXDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _TXDW < 'a > { w : & 'a mut W , } impl < 'a > _TXDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - TX data for next transfer." ] # [ inline ] pub fn txd ( & self ) -> TXDR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; TXDR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - TX data for next transfer." ] # [ inline ] pub fn txd ( & mut self ) -> _TXDW { _TXDW { w : self } } } } # [ doc = "SPI frequency" ] pub struct FREQUENCY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "SPI frequency" ] pub mod frequency { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FREQUENCY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FREQUENCY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FREQUENCYR { # [ doc = "125kbps." ] K125 , # [ doc = "250kbps." ] K250 , # [ doc = "500kbps." ] K500 , # [ doc = "1Mbps." ] M1 , # [ doc = "2Mbps." ] M2 , # [ doc = "4Mbps." ] M4 , # [ doc = "8Mbps." ] M8 , # [ doc = r" Reserved" ] _Reserved ( u32 ) } impl FREQUENCYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { match * self { FREQUENCYR :: K125 => 0x0200_0000 , FREQUENCYR :: K250 => 0x0400_0000 , FREQUENCYR :: K500 => 0x0800_0000 , FREQUENCYR :: M1 => 0x1000_0000 , FREQUENCYR :: M2 => 0x2000_0000 , FREQUENCYR :: M4 => 0x4000_0000 , FREQUENCYR :: M8 => 0x8000_0000 , FREQUENCYR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u32 ) -> FREQUENCYR { match value { 33554432 => FREQUENCYR :: K125 , 67108864 => FREQUENCYR :: K250 , 134217728 => FREQUENCYR :: K500 , 268435456 => FREQUENCYR :: M1 , 536870912 => FREQUENCYR :: M2 , 1073741824 => FREQUENCYR :: M4 , 2147483648 => FREQUENCYR :: M8 , i => FREQUENCYR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `K125`" ] # [ inline ] pub fn is_k125 ( & self ) -> bool { * self == FREQUENCYR :: K125 } # [ doc = "Checks if the value of the field is `K250`" ] # [ inline ] pub fn is_k250 ( & self ) -> bool { * self == FREQUENCYR :: K250 } # [ doc = "Checks if the value of the field is `K500`" ] # [ inline ] pub fn is_k500 ( & self ) -> bool { * self == FREQUENCYR :: K500 } # [ doc = "Checks if the value of the field is `M1`" ] # [ inline ] pub fn is_m1 ( & self ) -> bool { * self == FREQUENCYR :: M1 } # [ doc = "Checks if the value of the field is `M2`" ] # [ inline ] pub fn is_m2 ( & self ) -> bool { * self == FREQUENCYR :: M2 } # [ doc = "Checks if the value of the field is `M4`" ] # [ inline ] pub fn is_m4 ( & self ) -> bool { * self == FREQUENCYR :: M4 } # [ doc = "Checks if the value of the field is `M8`" ] # [ inline ] pub fn is_m8 ( & self ) -> bool { * self == FREQUENCYR :: M8 } } # [ doc = "Values that can be written to the field `FREQUENCY`" ] pub enum FREQUENCYW { # [ doc = "125kbps." ] K125 , # [ doc = "250kbps." ] K250 , # [ doc = "500kbps." ] K500 , # [ doc = "1Mbps." ] M1 , # [ doc = "2Mbps." ] M2 , # [ doc = "4Mbps." ] M4 , # [ doc = "8Mbps." ] M8 } impl FREQUENCYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u32 { match * self { FREQUENCYW :: K125 => 33554432 , FREQUENCYW :: K250 => 67108864 , FREQUENCYW :: K500 => 134217728 , FREQUENCYW :: M1 => 268435456 , FREQUENCYW :: M2 => 536870912 , FREQUENCYW :: M4 => 1073741824 , FREQUENCYW :: M8 => 2147483648 } } } # [ doc = r" Proxy" ] pub struct _FREQUENCYW < 'a > { w : & 'a mut W , } impl < 'a > _FREQUENCYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FREQUENCYW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "125kbps." ] # [ inline ] pub fn k125 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: K125 ) } # [ doc = "250kbps." ] # [ inline ] pub fn k250 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: K250 ) } # [ doc = "500kbps." ] # [ inline ] pub fn k500 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: K500 ) } # [ doc = "1Mbps." ] # [ inline ] pub fn m1 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: M1 ) } # [ doc = "2Mbps." ] # [ inline ] pub fn m2 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: M2 ) } # [ doc = "4Mbps." ] # [ inline ] pub fn m4 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: M4 ) } # [ doc = "8Mbps." ] # [ inline ] pub fn m8 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: M8 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - SPI data rate." ] # [ inline ] pub fn frequency ( & self ) -> FREQUENCYR { FREQUENCYR :: _from ( { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x0400_0000 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - SPI data rate." ] # [ inline ] pub fn frequency ( & mut self ) -> _FREQUENCYW { _FREQUENCYW { w : self } } } } # [ doc = "Configuration register." ] pub struct CONFIG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Configuration register." ] pub mod config { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONFIG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ORDER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ORDERR { # [ doc = "Most significant bit transmitted out first." ] MSBFIRST , # [ doc = "Least significant bit transmitted out first." ] LSBFIRST } impl ORDERR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ORDERR :: MSBFIRST => false , ORDERR :: LSBFIRST => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ORDERR { match value { false => ORDERR :: MSBFIRST , true => ORDERR :: LSBFIRST , } } # [ doc = "Checks if the value of the field is `MSBFIRST`" ] # [ inline ] pub fn is_msb_first ( & self ) -> bool { * self == ORDERR :: MSBFIRST } # [ doc = "Checks if the value of the field is `LSBFIRST`" ] # [ inline ] pub fn is_lsb_first ( & self ) -> bool { * self == ORDERR :: LSBFIRST } } # [ doc = "Possible values of the field `CPHA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPHAR { # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ] LEADING , # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ] TRAILING } impl CPHAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CPHAR :: LEADING => false , CPHAR :: TRAILING => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CPHAR { match value { false => CPHAR :: LEADING , true => CPHAR :: TRAILING , } } # [ doc = "Checks if the value of the field is `LEADING`" ] # [ inline ] pub fn is_leading ( & self ) -> bool { * self == CPHAR :: LEADING } # [ doc = "Checks if the value of the field is `TRAILING`" ] # [ inline ] pub fn is_trailing ( & self ) -> bool { * self == CPHAR :: TRAILING } } # [ doc = "Possible values of the field `CPOL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPOLR { # [ doc = "Active high." ] ACTIVEHIGH , # [ doc = "Active low." ] ACTIVELOW } impl CPOLR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CPOLR :: ACTIVEHIGH => false , CPOLR :: ACTIVELOW => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CPOLR { match value { false => CPOLR :: ACTIVEHIGH , true => CPOLR :: ACTIVELOW , } } # [ doc = "Checks if the value of the field is `ACTIVEHIGH`" ] # [ inline ] pub fn is_active_high ( & self ) -> bool { * self == CPOLR :: ACTIVEHIGH } # [ doc = "Checks if the value of the field is `ACTIVELOW`" ] # [ inline ] pub fn is_active_low ( & self ) -> bool { * self == CPOLR :: ACTIVELOW } } # [ doc = "Values that can be written to the field `ORDER`" ] pub enum ORDERW { # [ doc = "Most significant bit transmitted out first." ] MSBFIRST , # [ doc = "Least significant bit transmitted out first." ] LSBFIRST } impl ORDERW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ORDERW :: MSBFIRST => false , ORDERW :: LSBFIRST => true } } } # [ doc = r" Proxy" ] pub struct _ORDERW < 'a > { w : & 'a mut W , } impl < 'a > _ORDERW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ORDERW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Most significant bit transmitted out first." ] # [ inline ] pub fn msb_first ( self ) -> & 'a mut W { self . variant ( ORDERW :: MSBFIRST ) } # [ doc = "Least significant bit transmitted out first." ] # [ inline ] pub fn lsb_first ( self ) -> & 'a mut W { self . variant ( ORDERW :: LSBFIRST ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CPHA`" ] pub enum CPHAW { # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ] LEADING , # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ] TRAILING } impl CPHAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CPHAW :: LEADING => false , CPHAW :: TRAILING => true } } } # [ doc = r" Proxy" ] pub struct _CPHAW < 'a > { w : & 'a mut W , } impl < 'a > _CPHAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CPHAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ] # [ inline ] pub fn leading ( self ) -> & 'a mut W { self . variant ( CPHAW :: LEADING ) } # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ] # [ inline ] pub fn trailing ( self ) -> & 'a mut W { self . variant ( CPHAW :: TRAILING ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CPOL`" ] pub enum CPOLW { # [ doc = "Active high." ] ACTIVEHIGH , # [ doc = "Active low." ] ACTIVELOW } impl CPOLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CPOLW :: ACTIVEHIGH => false , CPOLW :: ACTIVELOW => true } } } # [ doc = r" Proxy" ] pub struct _CPOLW < 'a > { w : & 'a mut W , } impl < 'a > _CPOLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CPOLW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Active high." ] # [ inline ] pub fn active_high ( self ) -> & 'a mut W { self . variant ( CPOLW :: ACTIVEHIGH ) } # [ doc = "Active low." ] # [ inline ] pub fn active_low ( self ) -> & 'a mut W { self . variant ( CPOLW :: ACTIVELOW ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Bit order." ] # [ inline ] pub fn order ( & self ) -> ORDERR { ORDERR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Serial clock (SCK) phase." ] # [ inline ] pub fn cpha ( & self ) -> CPHAR { CPHAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Serial clock (SCK) polarity." ] # [ inline ] pub fn cpol ( & self ) -> CPOLR { CPOLR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Bit order." ] # [ inline ] pub fn order ( & mut self ) -> _ORDERW { _ORDERW { w : self } } # [ doc = "Bit 1 - Serial clock (SCK) phase." ] # [ inline ] pub fn cpha ( & mut self ) -> _CPHAW { _CPHAW { w : self } } # [ doc = "Bit 2 - Serial clock (SCK) polarity." ] # [ inline ] pub fn cpol ( & mut self ) -> _CPOLW { _CPOLW { w : self } } } } } # [ doc = "Two-wire interface master 0." ] pub struct TWI0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TWI0 { } impl TWI0 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const twi0 :: RegisterBlock { 0x4000_3000 as * const _ } } impl Deref for TWI0 { type Target = twi0 :: RegisterBlock ; fn deref ( & self ) -> & twi0 :: RegisterBlock { unsafe { & * TWI0 :: ptr ( ) } } } # [ doc = "Two-wire interface master 0." ] pub mod twi0 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start 2-Wire master receive sequence." ] pub tasks_startrx : TASKS_STARTRX , _reserved0 : [ u8 ; 4usize ] , # [ doc = "0x08 - Start 2-Wire master transmit sequence." ] pub tasks_starttx : TASKS_STARTTX , _reserved1 : [ u8 ; 8usize ] , # [ doc = "0x14 - Stop 2-Wire transaction." ] pub tasks_stop : TASKS_STOP , _reserved2 : [ u8 ; 4usize ] , # [ doc = "0x1c - Suspend 2-Wire transaction." ] pub tasks_suspend : TASKS_SUSPEND , # [ doc = "0x20 - Resume 2-Wire transaction." ] pub tasks_resume : TASKS_RESUME , _reserved3 : [ u8 ; 224usize ] , # [ doc = "0x104 - Two-wire stopped." ] pub events_stopped : EVENTS_STOPPED , # [ doc = "0x108 - Two-wire ready to deliver new RXD byte received." ] pub events_rxdready : EVENTS_RXDREADY , _reserved4 : [ u8 ; 16usize ] , # [ doc = "0x11c - Two-wire finished sending last TXD byte." ] pub events_txdsent : EVENTS_TXDSENT , _reserved5 : [ u8 ; 4usize ] , # [ doc = "0x124 - Two-wire error detected." ] pub events_error : EVENTS_ERROR , _reserved6 : [ u8 ; 16usize ] , # [ doc = "0x138 - Two-wire byte boundary." ] pub events_bb : EVENTS_BB , _reserved7 : [ u8 ; 196usize ] , # [ doc = "0x200 - Shortcuts for TWI." ] pub shorts : SHORTS , _reserved8 : [ u8 ; 256usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved9 : [ u8 ; 440usize ] , # [ doc = "0x4c4 - Two-wire error source. Write error field to 1 to clear error." ] pub errorsrc : ERRORSRC , _reserved10 : [ u8 ; 56usize ] , # [ doc = "0x500 - Enable two-wire master." ] pub enable : ENABLE , _reserved11 : [ u8 ; 4usize ] , # [ doc = "0x508 - Pin select for SCL." ] pub pselscl : PSELSCL , # [ doc = "0x50c - Pin select for SDA." ] pub pselsda : PSELSDA , _reserved12 : [ u8 ; 8usize ] , # [ doc = "0x518 - RX data register." ] pub rxd : RXD , # [ doc = "0x51c - TX data register." ] pub txd : TXD , _reserved13 : [ u8 ; 4usize ] , # [ doc = "0x524 - Two-wire frequency." ] pub frequency : FREQUENCY , _reserved14 : [ u8 ; 96usize ] , # [ doc = "0x588 - Address used in the two-wire transfer." ] pub address : ADDRESS , } # [ doc = "Start 2-Wire master receive sequence." ] pub struct TASKS_STARTRX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start 2-Wire master receive sequence." ] pub mod tasks_startrx { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STARTRX { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Start 2-Wire master transmit sequence." ] pub struct TASKS_STARTTX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start 2-Wire master transmit sequence." ] pub mod tasks_starttx { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STARTTX { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop 2-Wire transaction." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop 2-Wire transaction." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Suspend 2-Wire transaction." ] pub struct TASKS_SUSPEND { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Suspend 2-Wire transaction." ] pub mod tasks_suspend { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_SUSPEND { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Resume 2-Wire transaction." ] pub struct TASKS_RESUME { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Resume 2-Wire transaction." ] pub mod tasks_resume { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_RESUME { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Two-wire stopped." ] pub struct EVENTS_STOPPED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Two-wire stopped." ] pub mod events_stopped { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_STOPPED { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Two-wire ready to deliver new RXD byte received." ] pub struct EVENTS_RXDREADY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Two-wire ready to deliver new RXD byte received." ] pub mod events_rxdready { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_RXDREADY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Two-wire finished sending last TXD byte." ] pub struct EVENTS_TXDSENT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Two-wire finished sending last TXD byte." ] pub mod events_txdsent { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_TXDSENT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Two-wire error detected." ] pub struct EVENTS_ERROR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Two-wire error detected." ] pub mod events_error { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ERROR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Two-wire byte boundary." ] pub struct EVENTS_BB { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Two-wire byte boundary." ] pub mod events_bb { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_BB { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Shortcuts for TWI." ] pub struct SHORTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Shortcuts for TWI." ] pub mod shorts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SHORTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `BB_SUSPEND`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BB_SUSPENDR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl BB_SUSPENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BB_SUSPENDR :: DISABLED => false , BB_SUSPENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BB_SUSPENDR { match value { false => BB_SUSPENDR :: DISABLED , true => BB_SUSPENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == BB_SUSPENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == BB_SUSPENDR :: ENABLED } } # [ doc = "Possible values of the field `BB_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BB_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl BB_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BB_STOPR :: DISABLED => false , BB_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BB_STOPR { match value { false => BB_STOPR :: DISABLED , true => BB_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == BB_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == BB_STOPR :: ENABLED } } # [ doc = "Values that can be written to the field `BB_SUSPEND`" ] pub enum BB_SUSPENDW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl BB_SUSPENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BB_SUSPENDW :: DISABLED => false , BB_SUSPENDW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _BB_SUSPENDW < 'a > { w : & 'a mut W , } impl < 'a > _BB_SUSPENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BB_SUSPENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( BB_SUSPENDW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( BB_SUSPENDW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BB_STOP`" ] pub enum BB_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl BB_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BB_STOPW :: DISABLED => false , BB_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _BB_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _BB_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BB_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( BB_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( BB_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Shortcut between BB event and the SUSPEND task." ] # [ inline ] pub fn bb_suspend ( & self ) -> BB_SUSPENDR { BB_SUSPENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Shortcut between BB event and the STOP task." ] # [ inline ] pub fn bb_stop ( & self ) -> BB_STOPR { BB_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Shortcut between BB event and the SUSPEND task." ] # [ inline ] pub fn bb_suspend ( & mut self ) -> _BB_SUSPENDW { _BB_SUSPENDW { w : self } } # [ doc = "Bit 1 - Shortcut between BB event and the STOP task." ] # [ inline ] pub fn bb_stop ( & mut self ) -> _BB_STOPW { _BB_STOPW { w : self } } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `STOPPED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STOPPEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl STOPPEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { STOPPEDR :: DISABLED => false , STOPPEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> STOPPEDR { match value { false => STOPPEDR :: DISABLED , true => STOPPEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == STOPPEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == STOPPEDR :: ENABLED } } # [ doc = "Possible values of the field `RXDREADY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXDREADYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RXDREADYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RXDREADYR :: DISABLED => false , RXDREADYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RXDREADYR { match value { false => RXDREADYR :: DISABLED , true => RXDREADYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RXDREADYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RXDREADYR :: ENABLED } } # [ doc = "Possible values of the field `TXDSENT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TXDSENTR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl TXDSENTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TXDSENTR :: DISABLED => false , TXDSENTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TXDSENTR { match value { false => TXDSENTR :: DISABLED , true => TXDSENTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TXDSENTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TXDSENTR :: ENABLED } } # [ doc = "Possible values of the field `ERROR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERRORR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ERRORR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERRORR :: DISABLED => false , ERRORR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERRORR { match value { false => ERRORR :: DISABLED , true => ERRORR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ERRORR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ERRORR :: ENABLED } } # [ doc = "Possible values of the field `BB`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BBR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl BBR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BBR :: DISABLED => false , BBR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BBR { match value { false => BBR :: DISABLED , true => BBR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == BBR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == BBR :: ENABLED } } # [ doc = "Values that can be written to the field `STOPPED`" ] pub enum STOPPEDW { # [ doc = "Enable interrupt on write." ] SET } impl STOPPEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { STOPPEDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _STOPPEDW < 'a > { w : & 'a mut W , } impl < 'a > _STOPPEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : STOPPEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( STOPPEDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RXDREADY`" ] pub enum RXDREADYW { # [ doc = "Enable interrupt on write." ] SET } impl RXDREADYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RXDREADYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _RXDREADYW < 'a > { w : & 'a mut W , } impl < 'a > _RXDREADYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RXDREADYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( RXDREADYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `TXDSENT`" ] pub enum TXDSENTW { # [ doc = "Enable interrupt on write." ] SET } impl TXDSENTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TXDSENTW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _TXDSENTW < 'a > { w : & 'a mut W , } impl < 'a > _TXDSENTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TXDSENTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( TXDSENTW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ERROR`" ] pub enum ERRORW { # [ doc = "Enable interrupt on write." ] SET } impl ERRORW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERRORW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ERRORW < 'a > { w : & 'a mut W , } impl < 'a > _ERRORW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERRORW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ERRORW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BB`" ] pub enum BBW { # [ doc = "Enable interrupt on write." ] SET } impl BBW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BBW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _BBW < 'a > { w : & 'a mut W , } impl < 'a > _BBW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BBW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( BBW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 1 - Enable interrupt on STOPPED event." ] # [ inline ] pub fn stopped ( & self ) -> STOPPEDR { STOPPEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable interrupt on READY event." ] # [ inline ] pub fn rxdready ( & self ) -> RXDREADYR { RXDREADYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Enable interrupt on TXDSENT event." ] # [ inline ] pub fn txdsent ( & self ) -> TXDSENTR { TXDSENTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Enable interrupt on ERROR event." ] # [ inline ] pub fn error ( & self ) -> ERRORR { ERRORR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Enable interrupt on BB event." ] # [ inline ] pub fn bb ( & self ) -> BBR { BBR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 1 - Enable interrupt on STOPPED event." ] # [ inline ] pub fn stopped ( & mut self ) -> _STOPPEDW { _STOPPEDW { w : self } } # [ doc = "Bit 2 - Enable interrupt on READY event." ] # [ inline ] pub fn rxdready ( & mut self ) -> _RXDREADYW { _RXDREADYW { w : self } } # [ doc = "Bit 7 - Enable interrupt on TXDSENT event." ] # [ inline ] pub fn txdsent ( & mut self ) -> _TXDSENTW { _TXDSENTW { w : self } } # [ doc = "Bit 9 - Enable interrupt on ERROR event." ] # [ inline ] pub fn error ( & mut self ) -> _ERRORW { _ERRORW { w : self } } # [ doc = "Bit 14 - Enable interrupt on BB event." ] # [ inline ] pub fn bb ( & mut self ) -> _BBW { _BBW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `STOPPED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STOPPEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl STOPPEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { STOPPEDR :: DISABLED => false , STOPPEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> STOPPEDR { match value { false => STOPPEDR :: DISABLED , true => STOPPEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == STOPPEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == STOPPEDR :: ENABLED } } # [ doc = "Possible values of the field `RXDREADY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXDREADYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RXDREADYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RXDREADYR :: DISABLED => false , RXDREADYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RXDREADYR { match value { false => RXDREADYR :: DISABLED , true => RXDREADYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RXDREADYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RXDREADYR :: ENABLED } } # [ doc = "Possible values of the field `TXDSENT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TXDSENTR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl TXDSENTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TXDSENTR :: DISABLED => false , TXDSENTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TXDSENTR { match value { false => TXDSENTR :: DISABLED , true => TXDSENTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TXDSENTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TXDSENTR :: ENABLED } } # [ doc = "Possible values of the field `ERROR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERRORR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ERRORR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERRORR :: DISABLED => false , ERRORR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERRORR { match value { false => ERRORR :: DISABLED , true => ERRORR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ERRORR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ERRORR :: ENABLED } } # [ doc = "Possible values of the field `BB`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BBR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl BBR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BBR :: DISABLED => false , BBR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BBR { match value { false => BBR :: DISABLED , true => BBR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == BBR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == BBR :: ENABLED } } # [ doc = "Values that can be written to the field `STOPPED`" ] pub enum STOPPEDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl STOPPEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { STOPPEDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _STOPPEDW < 'a > { w : & 'a mut W , } impl < 'a > _STOPPEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : STOPPEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( STOPPEDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RXDREADY`" ] pub enum RXDREADYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl RXDREADYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RXDREADYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _RXDREADYW < 'a > { w : & 'a mut W , } impl < 'a > _RXDREADYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RXDREADYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( RXDREADYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `TXDSENT`" ] pub enum TXDSENTW { # [ doc = "Disable interrupt on write." ] CLEAR } impl TXDSENTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TXDSENTW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _TXDSENTW < 'a > { w : & 'a mut W , } impl < 'a > _TXDSENTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TXDSENTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( TXDSENTW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ERROR`" ] pub enum ERRORW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ERRORW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERRORW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ERRORW < 'a > { w : & 'a mut W , } impl < 'a > _ERRORW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERRORW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ERRORW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `BB`" ] pub enum BBW { # [ doc = "Disable interrupt on write." ] CLEAR } impl BBW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { BBW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _BBW < 'a > { w : & 'a mut W , } impl < 'a > _BBW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BBW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( BBW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 1 - Disable interrupt on STOPPED event." ] # [ inline ] pub fn stopped ( & self ) -> STOPPEDR { STOPPEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Disable interrupt on RXDREADY event." ] # [ inline ] pub fn rxdready ( & self ) -> RXDREADYR { RXDREADYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Disable interrupt on TXDSENT event." ] # [ inline ] pub fn txdsent ( & self ) -> TXDSENTR { TXDSENTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Disable interrupt on ERROR event." ] # [ inline ] pub fn error ( & self ) -> ERRORR { ERRORR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Disable interrupt on BB event." ] # [ inline ] pub fn bb ( & self ) -> BBR { BBR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 1 - Disable interrupt on STOPPED event." ] # [ inline ] pub fn stopped ( & mut self ) -> _STOPPEDW { _STOPPEDW { w : self } } # [ doc = "Bit 2 - Disable interrupt on RXDREADY event." ] # [ inline ] pub fn rxdready ( & mut self ) -> _RXDREADYW { _RXDREADYW { w : self } } # [ doc = "Bit 7 - Disable interrupt on TXDSENT event." ] # [ inline ] pub fn txdsent ( & mut self ) -> _TXDSENTW { _TXDSENTW { w : self } } # [ doc = "Bit 9 - Disable interrupt on ERROR event." ] # [ inline ] pub fn error ( & mut self ) -> _ERRORW { _ERRORW { w : self } } # [ doc = "Bit 14 - Disable interrupt on BB event." ] # [ inline ] pub fn bb ( & mut self ) -> _BBW { _BBW { w : self } } } } # [ doc = "Two-wire error source. Write error field to 1 to clear error." ] pub struct ERRORSRC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Two-wire error source. Write error field to 1 to clear error." ] pub mod errorsrc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ERRORSRC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ANACK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ANACKR { # [ doc = "Error not present." ] NOTPRESENT , # [ doc = "Error present." ] PRESENT } impl ANACKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ANACKR :: NOTPRESENT => false , ANACKR :: PRESENT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ANACKR { match value { false => ANACKR :: NOTPRESENT , true => ANACKR :: PRESENT , } } # [ doc = "Checks if the value of the field is `NOTPRESENT`" ] # [ inline ] pub fn is_not_present ( & self ) -> bool { * self == ANACKR :: NOTPRESENT } # [ doc = "Checks if the value of the field is `PRESENT`" ] # [ inline ] pub fn is_present ( & self ) -> bool { * self == ANACKR :: PRESENT } } # [ doc = "Possible values of the field `DNACK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DNACKR { # [ doc = "Error not present." ] NOTPRESENT , # [ doc = "Error present." ] PRESENT } impl DNACKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DNACKR :: NOTPRESENT => false , DNACKR :: PRESENT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DNACKR { match value { false => DNACKR :: NOTPRESENT , true => DNACKR :: PRESENT , } } # [ doc = "Checks if the value of the field is `NOTPRESENT`" ] # [ inline ] pub fn is_not_present ( & self ) -> bool { * self == DNACKR :: NOTPRESENT } # [ doc = "Checks if the value of the field is `PRESENT`" ] # [ inline ] pub fn is_present ( & self ) -> bool { * self == DNACKR :: PRESENT } } # [ doc = "Values that can be written to the field `ANACK`" ] pub enum ANACKW { # [ doc = "Clear error on write." ] CLEAR } impl ANACKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ANACKW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ANACKW < 'a > { w : & 'a mut W , } impl < 'a > _ANACKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ANACKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clear error on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ANACKW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DNACK`" ] pub enum DNACKW { # [ doc = "Clear error on write." ] CLEAR } impl DNACKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DNACKW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _DNACKW < 'a > { w : & 'a mut W , } impl < 'a > _DNACKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DNACKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clear error on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( DNACKW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 1 - NACK received after sending the address." ] # [ inline ] pub fn anack ( & self ) -> ANACKR { ANACKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - NACK received after sending a data byte." ] # [ inline ] pub fn dnack ( & self ) -> DNACKR { DNACKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 1 - NACK received after sending the address." ] # [ inline ] pub fn anack ( & mut self ) -> _ANACKW { _ANACKW { w : self } } # [ doc = "Bit 2 - NACK received after sending a data byte." ] # [ inline ] pub fn dnack ( & mut self ) -> _DNACKW { _DNACKW { w : self } } } } # [ doc = "Enable two-wire master." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable two-wire master." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ENABLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ENABLER :: DISABLED => 0 , ENABLER :: ENABLED => 0x05 , ENABLER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ENABLER { match value { 0 => ENABLER :: DISABLED , 5 => ENABLER :: ENABLED , i => ENABLER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ENABLEW :: DISABLED => 0 , ENABLEW :: ENABLED => 5 } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Enable or disable W2M" ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Enable or disable W2M" ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "Pin select for SCL." ] pub struct PSELSCL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for SCL." ] pub mod pselscl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELSCL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for SDA." ] pub struct PSELSDA { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for SDA." ] pub mod pselsda { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELSDA { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "RX data register." ] pub struct RXD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "RX data register." ] pub mod rxd { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RXD { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct RXDR { bits : u8 , } impl RXDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _RXDW < 'a > { w : & 'a mut W , } impl < 'a > _RXDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - RX data from last transfer." ] # [ inline ] pub fn rxd ( & self ) -> RXDR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; RXDR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - RX data from last transfer." ] # [ inline ] pub fn rxd ( & mut self ) -> _RXDW { _RXDW { w : self } } } } # [ doc = "TX data register." ] pub struct TXD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "TX data register." ] pub mod txd { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TXD { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct TXDR { bits : u8 , } impl TXDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _TXDW < 'a > { w : & 'a mut W , } impl < 'a > _TXDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - TX data for next transfer." ] # [ inline ] pub fn txd ( & self ) -> TXDR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; TXDR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - TX data for next transfer." ] # [ inline ] pub fn txd ( & mut self ) -> _TXDW { _TXDW { w : self } } } } # [ doc = "Two-wire frequency." ] pub struct FREQUENCY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Two-wire frequency." ] pub mod frequency { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: FREQUENCY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `FREQUENCY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FREQUENCYR { # [ doc = "100 kbps." ] K100 , # [ doc = "250 kbps." ] K250 , # [ doc = "400 kbps." ] K400 , # [ doc = r" Reserved" ] _Reserved ( u32 ) } impl FREQUENCYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { match * self { FREQUENCYR :: K100 => 0x0198_0000 , FREQUENCYR :: K250 => 0x0400_0000 , FREQUENCYR :: K400 => 0x0668_0000 , FREQUENCYR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u32 ) -> FREQUENCYR { match value { 26738688 => FREQUENCYR :: K100 , 67108864 => FREQUENCYR :: K250 , 107479040 => FREQUENCYR :: K400 , i => FREQUENCYR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `K100`" ] # [ inline ] pub fn is_k100 ( & self ) -> bool { * self == FREQUENCYR :: K100 } # [ doc = "Checks if the value of the field is `K250`" ] # [ inline ] pub fn is_k250 ( & self ) -> bool { * self == FREQUENCYR :: K250 } # [ doc = "Checks if the value of the field is `K400`" ] # [ inline ] pub fn is_k400 ( & self ) -> bool { * self == FREQUENCYR :: K400 } } # [ doc = "Values that can be written to the field `FREQUENCY`" ] pub enum FREQUENCYW { # [ doc = "100 kbps." ] K100 , # [ doc = "250 kbps." ] K250 , # [ doc = "400 kbps." ] K400 } impl FREQUENCYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u32 { match * self { FREQUENCYW :: K100 => 26738688 , FREQUENCYW :: K250 => 67108864 , FREQUENCYW :: K400 => 107479040 } } } # [ doc = r" Proxy" ] pub struct _FREQUENCYW < 'a > { w : & 'a mut W , } impl < 'a > _FREQUENCYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : FREQUENCYW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "100 kbps." ] # [ inline ] pub fn k100 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: K100 ) } # [ doc = "250 kbps." ] # [ inline ] pub fn k250 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: K250 ) } # [ doc = "400 kbps." ] # [ inline ] pub fn k400 ( self ) -> & 'a mut W { self . variant ( FREQUENCYW :: K400 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Two-wire master clock frequency." ] # [ inline ] pub fn frequency ( & self ) -> FREQUENCYR { FREQUENCYR :: _from ( { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x0400_0000 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Two-wire master clock frequency." ] # [ inline ] pub fn frequency ( & mut self ) -> _FREQUENCYW { _FREQUENCYW { w : self } } } } # [ doc = "Address used in the two-wire transfer." ] pub struct ADDRESS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Address used in the two-wire transfer." ] pub mod address { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ADDRESS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct ADDRESSR { bits : u8 , } impl ADDRESSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _ADDRESSW < 'a > { w : & 'a mut W , } impl < 'a > _ADDRESSW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:6 - Two-wire address." ] # [ inline ] pub fn address ( & self ) -> ADDRESSR { let bits = { const MASK : u8 = 0x7f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; ADDRESSR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:6 - Two-wire address." ] # [ inline ] pub fn address ( & mut self ) -> _ADDRESSW { _ADDRESSW { w : self } } } } } # [ doc = "SPI master 1." ] pub struct SPI1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SPI1 { } impl SPI1 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const spi0 :: RegisterBlock { 0x4000_4000 as * const _ } } impl Deref for SPI1 { type Target = spi0 :: RegisterBlock ; fn deref ( & self ) -> & spi0 :: RegisterBlock { unsafe { & * SPI1 :: ptr ( ) } } } # [ doc = "Two-wire interface master 1." ] pub struct TWI1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TWI1 { } impl TWI1 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const twi0 :: RegisterBlock { 0x4000_4000 as * const _ } } impl Deref for TWI1 { type Target = twi0 :: RegisterBlock ; fn deref ( & self ) -> & twi0 :: RegisterBlock { unsafe { & * TWI1 :: ptr ( ) } } } # [ doc = "SPI slave 1." ] pub struct SPIS1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SPIS1 { } impl SPIS1 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const spis1 :: RegisterBlock { 0x4000_4000 as * const _ } } impl Deref for SPIS1 { type Target = spis1 :: RegisterBlock ; fn deref ( & self ) -> & spis1 :: RegisterBlock { unsafe { & * SPIS1 :: ptr ( ) } } } # [ doc = "SPI slave 1." ] pub mod spis1 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 36usize ] , # [ doc = "0x24 - Acquire SPI semaphore." ] pub tasks_acquire : TASKS_ACQUIRE , # [ doc = "0x28 - Release SPI semaphore." ] pub tasks_release : TASKS_RELEASE , _reserved1 : [ u8 ; 216usize ] , # [ doc = "0x104 - Granted transaction completed." ] pub events_end : EVENTS_END , _reserved2 : [ u8 ; 32usize ] , # [ doc = "0x128 - Semaphore acquired." ] pub events_acquired : EVENTS_ACQUIRED , _reserved3 : [ u8 ; 212usize ] , # [ doc = "0x200 - Shortcuts for SPIS." ] pub shorts : SHORTS , _reserved4 : [ u8 ; 256usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved5 : [ u8 ; 244usize ] , # [ doc = "0x400 - Semaphore status." ] pub semstat : SEMSTAT , _reserved6 : [ u8 ; 60usize ] , # [ doc = "0x440 - Status from last transaction." ] pub status : STATUS , _reserved7 : [ u8 ; 188usize ] , # [ doc = "0x500 - Enable SPIS." ] pub enable : ENABLE , _reserved8 : [ u8 ; 4usize ] , # [ doc = "0x508 - Pin select for SCK." ] pub pselsck : PSELSCK , # [ doc = "0x50c - Pin select for MISO." ] pub pselmiso : PSELMISO , # [ doc = "0x510 - Pin select for MOSI." ] pub pselmosi : PSELMOSI , # [ doc = "0x514 - Pin select for CSN." ] pub pselcsn : PSELCSN , _reserved9 : [ u8 ; 28usize ] , # [ doc = "0x534 - RX data pointer." ] pub rxdptr : RXDPTR , # [ doc = "0x538 - Maximum number of bytes in the receive buffer." ] pub maxrx : MAXRX , # [ doc = "0x53c - Number of bytes received in last granted transaction." ] pub amountrx : AMOUNTRX , _reserved10 : [ u8 ; 4usize ] , # [ doc = "0x544 - TX data pointer." ] pub txdptr : TXDPTR , # [ doc = "0x548 - Maximum number of bytes in the transmit buffer." ] pub maxtx : MAXTX , # [ doc = "0x54c - Number of bytes transmitted in last granted transaction." ] pub amounttx : AMOUNTTX , _reserved11 : [ u8 ; 4usize ] , # [ doc = "0x554 - Configuration register." ] pub config : CONFIG , _reserved12 : [ u8 ; 4usize ] , # [ doc = "0x55c - Default character." ] pub def : DEF , _reserved13 : [ u8 ; 96usize ] , # [ doc = "0x5c0 - Over-read character." ] pub orc : ORC , } # [ doc = "Acquire SPI semaphore." ] pub struct TASKS_ACQUIRE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Acquire SPI semaphore." ] pub mod tasks_acquire { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_ACQUIRE { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Release SPI semaphore." ] pub struct TASKS_RELEASE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Release SPI semaphore." ] pub mod tasks_release { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_RELEASE { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Granted transaction completed." ] pub struct EVENTS_END { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Granted transaction completed." ] pub mod events_end { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_END { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Semaphore acquired." ] pub struct EVENTS_ACQUIRED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Semaphore acquired." ] pub mod events_acquired { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ACQUIRED { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Shortcuts for SPIS." ] pub struct SHORTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Shortcuts for SPIS." ] pub mod shorts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SHORTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `END_ACQUIRE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum END_ACQUIRER { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl END_ACQUIRER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { END_ACQUIRER :: DISABLED => false , END_ACQUIRER :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> END_ACQUIRER { match value { false => END_ACQUIRER :: DISABLED , true => END_ACQUIRER :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == END_ACQUIRER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == END_ACQUIRER :: ENABLED } } # [ doc = "Values that can be written to the field `END_ACQUIRE`" ] pub enum END_ACQUIREW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl END_ACQUIREW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { END_ACQUIREW :: DISABLED => false , END_ACQUIREW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _END_ACQUIREW < 'a > { w : & 'a mut W , } impl < 'a > _END_ACQUIREW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : END_ACQUIREW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( END_ACQUIREW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( END_ACQUIREW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 2 - Shortcut between END event and the ACQUIRE task." ] # [ inline ] pub fn end_acquire ( & self ) -> END_ACQUIRER { END_ACQUIRER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 2 - Shortcut between END event and the ACQUIRE task." ] # [ inline ] pub fn end_acquire ( & mut self ) -> _END_ACQUIREW { _END_ACQUIREW { w : self } } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `END`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDR :: DISABLED => false , ENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDR { match value { false => ENDR :: DISABLED , true => ENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDR :: ENABLED } } # [ doc = "Possible values of the field `ACQUIRED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ACQUIREDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ACQUIREDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ACQUIREDR :: DISABLED => false , ACQUIREDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ACQUIREDR { match value { false => ACQUIREDR :: DISABLED , true => ACQUIREDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ACQUIREDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ACQUIREDR :: ENABLED } } # [ doc = "Values that can be written to the field `END`" ] pub enum ENDW { # [ doc = "Enable interrupt on write." ] SET } impl ENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ENDW < 'a > { w : & 'a mut W , } impl < 'a > _ENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ENDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ACQUIRED`" ] pub enum ACQUIREDW { # [ doc = "Enable interrupt on write." ] SET } impl ACQUIREDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ACQUIREDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ACQUIREDW < 'a > { w : & 'a mut W , } impl < 'a > _ACQUIREDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ACQUIREDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ACQUIREDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 1 - Enable interrupt on END event." ] # [ inline ] pub fn end ( & self ) -> ENDR { ENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Enable interrupt on ACQUIRED event." ] # [ inline ] pub fn acquired ( & self ) -> ACQUIREDR { ACQUIREDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 1 - Enable interrupt on END event." ] # [ inline ] pub fn end ( & mut self ) -> _ENDW { _ENDW { w : self } } # [ doc = "Bit 10 - Enable interrupt on ACQUIRED event." ] # [ inline ] pub fn acquired ( & mut self ) -> _ACQUIREDW { _ACQUIREDW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `END`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDR :: DISABLED => false , ENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDR { match value { false => ENDR :: DISABLED , true => ENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDR :: ENABLED } } # [ doc = "Possible values of the field `ACQUIRED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ACQUIREDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ACQUIREDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ACQUIREDR :: DISABLED => false , ACQUIREDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ACQUIREDR { match value { false => ACQUIREDR :: DISABLED , true => ACQUIREDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ACQUIREDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ACQUIREDR :: ENABLED } } # [ doc = "Values that can be written to the field `END`" ] pub enum ENDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ENDW < 'a > { w : & 'a mut W , } impl < 'a > _ENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ENDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ACQUIRED`" ] pub enum ACQUIREDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ACQUIREDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ACQUIREDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ACQUIREDW < 'a > { w : & 'a mut W , } impl < 'a > _ACQUIREDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ACQUIREDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ACQUIREDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 1 - Disable interrupt on END event." ] # [ inline ] pub fn end ( & self ) -> ENDR { ENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Disable interrupt on ACQUIRED event." ] # [ inline ] pub fn acquired ( & self ) -> ACQUIREDR { ACQUIREDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 1 - Disable interrupt on END event." ] # [ inline ] pub fn end ( & mut self ) -> _ENDW { _ENDW { w : self } } # [ doc = "Bit 10 - Disable interrupt on ACQUIRED event." ] # [ inline ] pub fn acquired ( & mut self ) -> _ACQUIREDW { _ACQUIREDW { w : self } } } } # [ doc = "Semaphore status." ] pub struct SEMSTAT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Semaphore status." ] pub mod semstat { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: SEMSTAT { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `SEMSTAT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SEMSTATR { # [ doc = "Semaphore is free." ] FREE , # [ doc = "Semaphore is assigned to the CPU." ] CPU , # [ doc = "Semaphore is assigned to the SPIS." ] SPIS , # [ doc = "Semaphore is assigned to the SPIS, but a handover to the CPU is pending." ] CPUPENDING } impl SEMSTATR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SEMSTATR :: FREE => 0 , SEMSTATR :: CPU => 0x01 , SEMSTATR :: SPIS => 0x02 , SEMSTATR :: CPUPENDING => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SEMSTATR { match value { 0 => SEMSTATR :: FREE , 1 => SEMSTATR :: CPU , 2 => SEMSTATR :: SPIS , 3 => SEMSTATR :: CPUPENDING , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `FREE`" ] # [ inline ] pub fn is_free ( & self ) -> bool { * self == SEMSTATR :: FREE } # [ doc = "Checks if the value of the field is `CPU`" ] # [ inline ] pub fn is_cpu ( & self ) -> bool { * self == SEMSTATR :: CPU } # [ doc = "Checks if the value of the field is `SPIS`" ] # [ inline ] pub fn is_spis ( & self ) -> bool { * self == SEMSTATR :: SPIS } # [ doc = "Checks if the value of the field is `CPUPENDING`" ] # [ inline ] pub fn is_cpupending ( & self ) -> bool { * self == SEMSTATR :: CPUPENDING } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Semaphore status." ] # [ inline ] pub fn semstat ( & self ) -> SEMSTATR { SEMSTATR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } } # [ doc = "Status from last transaction." ] pub struct STATUS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Status from last transaction." ] pub mod status { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: STATUS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `OVERREAD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OVERREADR { # [ doc = "Error not present." ] NOTPRESENT , # [ doc = "Error present." ] PRESENT } impl OVERREADR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OVERREADR :: NOTPRESENT => false , OVERREADR :: PRESENT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OVERREADR { match value { false => OVERREADR :: NOTPRESENT , true => OVERREADR :: PRESENT , } } # [ doc = "Checks if the value of the field is `NOTPRESENT`" ] # [ inline ] pub fn is_not_present ( & self ) -> bool { * self == OVERREADR :: NOTPRESENT } # [ doc = "Checks if the value of the field is `PRESENT`" ] # [ inline ] pub fn is_present ( & self ) -> bool { * self == OVERREADR :: PRESENT } } # [ doc = "Possible values of the field `OVERFLOW`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OVERFLOWR { # [ doc = "Error not present." ] NOTPRESENT , # [ doc = "Error present." ] PRESENT } impl OVERFLOWR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OVERFLOWR :: NOTPRESENT => false , OVERFLOWR :: PRESENT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OVERFLOWR { match value { false => OVERFLOWR :: NOTPRESENT , true => OVERFLOWR :: PRESENT , } } # [ doc = "Checks if the value of the field is `NOTPRESENT`" ] # [ inline ] pub fn is_not_present ( & self ) -> bool { * self == OVERFLOWR :: NOTPRESENT } # [ doc = "Checks if the value of the field is `PRESENT`" ] # [ inline ] pub fn is_present ( & self ) -> bool { * self == OVERFLOWR :: PRESENT } } # [ doc = "Values that can be written to the field `OVERREAD`" ] pub enum OVERREADW { # [ doc = "Clear on write." ] CLEAR } impl OVERREADW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OVERREADW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _OVERREADW < 'a > { w : & 'a mut W , } impl < 'a > _OVERREADW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OVERREADW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clear on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( OVERREADW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OVERFLOW`" ] pub enum OVERFLOWW { # [ doc = "Clear on write." ] CLEAR } impl OVERFLOWW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OVERFLOWW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _OVERFLOWW < 'a > { w : & 'a mut W , } impl < 'a > _OVERFLOWW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OVERFLOWW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clear on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( OVERFLOWW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - TX buffer overread detected, and prevented." ] # [ inline ] pub fn overread ( & self ) -> OVERREADR { OVERREADR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - RX buffer overflow detected, and prevented." ] # [ inline ] pub fn overflow ( & self ) -> OVERFLOWR { OVERFLOWR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - TX buffer overread detected, and prevented." ] # [ inline ] pub fn overread ( & mut self ) -> _OVERREADW { _OVERREADW { w : self } } # [ doc = "Bit 1 - RX buffer overflow detected, and prevented." ] # [ inline ] pub fn overflow ( & mut self ) -> _OVERFLOWW { _OVERFLOWW { w : self } } } } # [ doc = "Enable SPIS." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable SPIS." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "Disabled SPIS." ] DISABLED , # [ doc = "Enable SPIS." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ENABLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ENABLER :: DISABLED => 0 , ENABLER :: ENABLED => 0x02 , ENABLER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ENABLER { match value { 0 => ENABLER :: DISABLED , 2 => ENABLER :: ENABLED , i => ENABLER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "Disabled SPIS." ] DISABLED , # [ doc = "Enable SPIS." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ENABLEW :: DISABLED => 0 , ENABLEW :: ENABLED => 2 } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled SPIS." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "Enable SPIS." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Enable or disable SPIS." ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Enable or disable SPIS." ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "Pin select for SCK." ] pub struct PSELSCK { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for SCK." ] pub mod pselsck { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELSCK { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for MISO." ] pub struct PSELMISO { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for MISO." ] pub mod pselmiso { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELMISO { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for MOSI." ] pub struct PSELMOSI { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for MOSI." ] pub mod pselmosi { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELMOSI { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for CSN." ] pub struct PSELCSN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for CSN." ] pub mod pselcsn { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELCSN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "RX data pointer." ] pub struct RXDPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "RX data pointer." ] pub mod rxdptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RXDPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Maximum number of bytes in the receive buffer." ] pub struct MAXRX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Maximum number of bytes in the receive buffer." ] pub mod maxrx { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MAXRX { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MAXRXR { bits : u8 , } impl MAXRXR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _MAXRXW < 'a > { w : & 'a mut W , } impl < 'a > _MAXRXW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Maximum number of bytes in the receive buffer." ] # [ inline ] pub fn maxrx ( & self ) -> MAXRXR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; MAXRXR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Maximum number of bytes in the receive buffer." ] # [ inline ] pub fn maxrx ( & mut self ) -> _MAXRXW { _MAXRXW { w : self } } } } # [ doc = "Number of bytes received in last granted transaction." ] pub struct AMOUNTRX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Number of bytes received in last granted transaction." ] pub mod amountrx { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: AMOUNTRX { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct AMOUNTRXR { bits : u8 , } impl AMOUNTRXR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _AMOUNTRXW < 'a > { w : & 'a mut W , } impl < 'a > _AMOUNTRXW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Number of bytes received in last granted transaction." ] # [ inline ] pub fn amountrx ( & self ) -> AMOUNTRXR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AMOUNTRXR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Number of bytes received in last granted transaction." ] # [ inline ] pub fn amountrx ( & mut self ) -> _AMOUNTRXW { _AMOUNTRXW { w : self } } } } # [ doc = "TX data pointer." ] pub struct TXDPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "TX data pointer." ] pub mod txdptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TXDPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Maximum number of bytes in the transmit buffer." ] pub struct MAXTX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Maximum number of bytes in the transmit buffer." ] pub mod maxtx { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MAXTX { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct MAXTXR { bits : u8 , } impl MAXTXR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _MAXTXW < 'a > { w : & 'a mut W , } impl < 'a > _MAXTXW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Maximum number of bytes in the transmit buffer." ] # [ inline ] pub fn maxtx ( & self ) -> MAXTXR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; MAXTXR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Maximum number of bytes in the transmit buffer." ] # [ inline ] pub fn maxtx ( & mut self ) -> _MAXTXW { _MAXTXW { w : self } } } } # [ doc = "Number of bytes transmitted in last granted transaction." ] pub struct AMOUNTTX { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Number of bytes transmitted in last granted transaction." ] pub mod amounttx { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: AMOUNTTX { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct AMOUNTTXR { bits : u8 , } impl AMOUNTTXR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _AMOUNTTXW < 'a > { w : & 'a mut W , } impl < 'a > _AMOUNTTXW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Number of bytes transmitted in last granted transaction." ] # [ inline ] pub fn amounttx ( & self ) -> AMOUNTTXR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; AMOUNTTXR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Number of bytes transmitted in last granted transaction." ] # [ inline ] pub fn amounttx ( & mut self ) -> _AMOUNTTXW { _AMOUNTTXW { w : self } } } } # [ doc = "Configuration register." ] pub struct CONFIG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Configuration register." ] pub mod config { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONFIG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ORDER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ORDERR { # [ doc = "Most significant bit transmitted out first." ] MSBFIRST , # [ doc = "Least significant bit transmitted out first." ] LSBFIRST } impl ORDERR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ORDERR :: MSBFIRST => false , ORDERR :: LSBFIRST => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ORDERR { match value { false => ORDERR :: MSBFIRST , true => ORDERR :: LSBFIRST , } } # [ doc = "Checks if the value of the field is `MSBFIRST`" ] # [ inline ] pub fn is_msb_first ( & self ) -> bool { * self == ORDERR :: MSBFIRST } # [ doc = "Checks if the value of the field is `LSBFIRST`" ] # [ inline ] pub fn is_lsb_first ( & self ) -> bool { * self == ORDERR :: LSBFIRST } } # [ doc = "Possible values of the field `CPHA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPHAR { # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ] LEADING , # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ] TRAILING } impl CPHAR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CPHAR :: LEADING => false , CPHAR :: TRAILING => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CPHAR { match value { false => CPHAR :: LEADING , true => CPHAR :: TRAILING , } } # [ doc = "Checks if the value of the field is `LEADING`" ] # [ inline ] pub fn is_leading ( & self ) -> bool { * self == CPHAR :: LEADING } # [ doc = "Checks if the value of the field is `TRAILING`" ] # [ inline ] pub fn is_trailing ( & self ) -> bool { * self == CPHAR :: TRAILING } } # [ doc = "Possible values of the field `CPOL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPOLR { # [ doc = "Active high." ] ACTIVEHIGH , # [ doc = "Active low." ] ACTIVELOW } impl CPOLR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CPOLR :: ACTIVEHIGH => false , CPOLR :: ACTIVELOW => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CPOLR { match value { false => CPOLR :: ACTIVEHIGH , true => CPOLR :: ACTIVELOW , } } # [ doc = "Checks if the value of the field is `ACTIVEHIGH`" ] # [ inline ] pub fn is_active_high ( & self ) -> bool { * self == CPOLR :: ACTIVEHIGH } # [ doc = "Checks if the value of the field is `ACTIVELOW`" ] # [ inline ] pub fn is_active_low ( & self ) -> bool { * self == CPOLR :: ACTIVELOW } } # [ doc = "Values that can be written to the field `ORDER`" ] pub enum ORDERW { # [ doc = "Most significant bit transmitted out first." ] MSBFIRST , # [ doc = "Least significant bit transmitted out first." ] LSBFIRST } impl ORDERW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ORDERW :: MSBFIRST => false , ORDERW :: LSBFIRST => true } } } # [ doc = r" Proxy" ] pub struct _ORDERW < 'a > { w : & 'a mut W , } impl < 'a > _ORDERW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ORDERW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Most significant bit transmitted out first." ] # [ inline ] pub fn msb_first ( self ) -> & 'a mut W { self . variant ( ORDERW :: MSBFIRST ) } # [ doc = "Least significant bit transmitted out first." ] # [ inline ] pub fn lsb_first ( self ) -> & 'a mut W { self . variant ( ORDERW :: LSBFIRST ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CPHA`" ] pub enum CPHAW { # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ] LEADING , # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ] TRAILING } impl CPHAW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CPHAW :: LEADING => false , CPHAW :: TRAILING => true } } } # [ doc = r" Proxy" ] pub struct _CPHAW < 'a > { w : & 'a mut W , } impl < 'a > _CPHAW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CPHAW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ] # [ inline ] pub fn leading ( self ) -> & 'a mut W { self . variant ( CPHAW :: LEADING ) } # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ] # [ inline ] pub fn trailing ( self ) -> & 'a mut W { self . variant ( CPHAW :: TRAILING ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CPOL`" ] pub enum CPOLW { # [ doc = "Active high." ] ACTIVEHIGH , # [ doc = "Active low." ] ACTIVELOW } impl CPOLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CPOLW :: ACTIVEHIGH => false , CPOLW :: ACTIVELOW => true } } } # [ doc = r" Proxy" ] pub struct _CPOLW < 'a > { w : & 'a mut W , } impl < 'a > _CPOLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CPOLW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Active high." ] # [ inline ] pub fn active_high ( self ) -> & 'a mut W { self . variant ( CPOLW :: ACTIVEHIGH ) } # [ doc = "Active low." ] # [ inline ] pub fn active_low ( self ) -> & 'a mut W { self . variant ( CPOLW :: ACTIVELOW ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Bit order." ] # [ inline ] pub fn order ( & self ) -> ORDERR { ORDERR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Serial clock (SCK) phase." ] # [ inline ] pub fn cpha ( & self ) -> CPHAR { CPHAR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Serial clock (SCK) polarity." ] # [ inline ] pub fn cpol ( & self ) -> CPOLR { CPOLR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Bit order." ] # [ inline ] pub fn order ( & mut self ) -> _ORDERW { _ORDERW { w : self } } # [ doc = "Bit 1 - Serial clock (SCK) phase." ] # [ inline ] pub fn cpha ( & mut self ) -> _CPHAW { _CPHAW { w : self } } # [ doc = "Bit 2 - Serial clock (SCK) polarity." ] # [ inline ] pub fn cpol ( & mut self ) -> _CPOLW { _CPOLW { w : self } } } } # [ doc = "Default character." ] pub struct DEF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Default character." ] pub mod def { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DEF { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct DEFR { bits : u8 , } impl DEFR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _DEFW < 'a > { w : & 'a mut W , } impl < 'a > _DEFW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Default character." ] # [ inline ] pub fn def ( & self ) -> DEFR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; DEFR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Default character." ] # [ inline ] pub fn def ( & mut self ) -> _DEFW { _DEFW { w : self } } } } # [ doc = "Over-read character." ] pub struct ORC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Over-read character." ] pub mod orc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ORC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct ORCR { bits : u8 , } impl ORCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _ORCW < 'a > { w : & 'a mut W , } impl < 'a > _ORCW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Over-read character." ] # [ inline ] pub fn orc ( & self ) -> ORCR { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; ORCR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Over-read character." ] # [ inline ] pub fn orc ( & mut self ) -> _ORCW { _ORCW { w : self } } } } } # [ doc = "GPIO tasks and events." ] pub struct GPIOTE { _marker : PhantomData < * const ( ) > } unsafe impl Send for GPIOTE { } impl GPIOTE { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const gpiote :: RegisterBlock { 0x4000_6000 as * const _ } } impl Deref for GPIOTE { type Target = gpiote :: RegisterBlock ; fn deref ( & self ) -> & gpiote :: RegisterBlock { unsafe { & * GPIOTE :: ptr ( ) } } } # [ doc = "GPIO tasks and events." ] pub mod gpiote { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Tasks asssociated with GPIOTE channels." ] pub tasks_out : [ TASKS_OUT ; 4 ] , _reserved0 : [ u8 ; 240usize ] , # [ doc = "0x100 - Tasks asssociated with GPIOTE channels." ] pub events_in : [ EVENTS_IN ; 4 ] , _reserved1 : [ u8 ; 108usize ] , # [ doc = "0x17c - Event generated from multiple pins." ] pub events_port : EVENTS_PORT , _reserved2 : [ u8 ; 388usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 516usize ] , # [ doc = "0x510 - Channel configuration registers." ] pub config : [ CONFIG ; 4 ] , } # [ doc = "Tasks asssociated with GPIOTE channels." ] pub struct TASKS_OUT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Tasks asssociated with GPIOTE channels." ] pub mod tasks_out { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_OUT { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Tasks asssociated with GPIOTE channels." ] pub struct EVENTS_IN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Tasks asssociated with GPIOTE channels." ] pub mod events_in { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_IN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Event generated from multiple pins." ] pub struct EVENTS_PORT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Event generated from multiple pins." ] pub mod events_port { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_PORT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `IN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IN0R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl IN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IN0R :: DISABLED => false , IN0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IN0R { match value { false => IN0R :: DISABLED , true => IN0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == IN0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == IN0R :: ENABLED } } # [ doc = "Possible values of the field `IN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IN1R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl IN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IN1R :: DISABLED => false , IN1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IN1R { match value { false => IN1R :: DISABLED , true => IN1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == IN1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == IN1R :: ENABLED } } # [ doc = "Possible values of the field `IN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IN2R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl IN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IN2R :: DISABLED => false , IN2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IN2R { match value { false => IN2R :: DISABLED , true => IN2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == IN2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == IN2R :: ENABLED } } # [ doc = "Possible values of the field `IN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IN3R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl IN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IN3R :: DISABLED => false , IN3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IN3R { match value { false => IN3R :: DISABLED , true => IN3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == IN3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == IN3R :: ENABLED } } # [ doc = "Possible values of the field `PORT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PORTR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl PORTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PORTR :: DISABLED => false , PORTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PORTR { match value { false => PORTR :: DISABLED , true => PORTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PORTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PORTR :: ENABLED } } # [ doc = "Values that can be written to the field `IN0`" ] pub enum IN0W { # [ doc = "Enable interrupt on write." ] SET } impl IN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IN0W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _IN0W < 'a > { w : & 'a mut W , } impl < 'a > _IN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( IN0W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IN1`" ] pub enum IN1W { # [ doc = "Enable interrupt on write." ] SET } impl IN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IN1W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _IN1W < 'a > { w : & 'a mut W , } impl < 'a > _IN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( IN1W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IN2`" ] pub enum IN2W { # [ doc = "Enable interrupt on write." ] SET } impl IN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IN2W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _IN2W < 'a > { w : & 'a mut W , } impl < 'a > _IN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( IN2W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IN3`" ] pub enum IN3W { # [ doc = "Enable interrupt on write." ] SET } impl IN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IN3W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _IN3W < 'a > { w : & 'a mut W , } impl < 'a > _IN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( IN3W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PORT`" ] pub enum PORTW { # [ doc = "Enable interrupt on write." ] SET } impl PORTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PORTW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PORTW < 'a > { w : & 'a mut W , } impl < 'a > _PORTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PORTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PORTW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on IN\\[0\\] event." ] # [ inline ] pub fn in0 ( & self ) -> IN0R { IN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on IN\\[1\\] event." ] # [ inline ] pub fn in1 ( & self ) -> IN1R { IN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable interrupt on IN\\[2\\] event." ] # [ inline ] pub fn in2 ( & self ) -> IN2R { IN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable interrupt on IN\\[3\\] event." ] # [ inline ] pub fn in3 ( & self ) -> IN3R { IN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Enable interrupt on PORT event." ] # [ inline ] pub fn port ( & self ) -> PORTR { PORTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on IN\\[0\\] event." ] # [ inline ] pub fn in0 ( & mut self ) -> _IN0W { _IN0W { w : self } } # [ doc = "Bit 1 - Enable interrupt on IN\\[1\\] event." ] # [ inline ] pub fn in1 ( & mut self ) -> _IN1W { _IN1W { w : self } } # [ doc = "Bit 2 - Enable interrupt on IN\\[2\\] event." ] # [ inline ] pub fn in2 ( & mut self ) -> _IN2W { _IN2W { w : self } } # [ doc = "Bit 3 - Enable interrupt on IN\\[3\\] event." ] # [ inline ] pub fn in3 ( & mut self ) -> _IN3W { _IN3W { w : self } } # [ doc = "Bit 31 - Enable interrupt on PORT event." ] # [ inline ] pub fn port ( & mut self ) -> _PORTW { _PORTW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `IN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IN0R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl IN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IN0R :: DISABLED => false , IN0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IN0R { match value { false => IN0R :: DISABLED , true => IN0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == IN0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == IN0R :: ENABLED } } # [ doc = "Possible values of the field `IN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IN1R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl IN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IN1R :: DISABLED => false , IN1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IN1R { match value { false => IN1R :: DISABLED , true => IN1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == IN1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == IN1R :: ENABLED } } # [ doc = "Possible values of the field `IN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IN2R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl IN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IN2R :: DISABLED => false , IN2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IN2R { match value { false => IN2R :: DISABLED , true => IN2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == IN2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == IN2R :: ENABLED } } # [ doc = "Possible values of the field `IN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IN3R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl IN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { IN3R :: DISABLED => false , IN3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> IN3R { match value { false => IN3R :: DISABLED , true => IN3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == IN3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == IN3R :: ENABLED } } # [ doc = "Possible values of the field `PORT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PORTR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl PORTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PORTR :: DISABLED => false , PORTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PORTR { match value { false => PORTR :: DISABLED , true => PORTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PORTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PORTR :: ENABLED } } # [ doc = "Values that can be written to the field `IN0`" ] pub enum IN0W { # [ doc = "Disable interrupt on write." ] CLEAR } impl IN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IN0W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _IN0W < 'a > { w : & 'a mut W , } impl < 'a > _IN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( IN0W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IN1`" ] pub enum IN1W { # [ doc = "Disable interrupt on write." ] CLEAR } impl IN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IN1W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _IN1W < 'a > { w : & 'a mut W , } impl < 'a > _IN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( IN1W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IN2`" ] pub enum IN2W { # [ doc = "Disable interrupt on write." ] CLEAR } impl IN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IN2W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _IN2W < 'a > { w : & 'a mut W , } impl < 'a > _IN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( IN2W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `IN3`" ] pub enum IN3W { # [ doc = "Disable interrupt on write." ] CLEAR } impl IN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { IN3W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _IN3W < 'a > { w : & 'a mut W , } impl < 'a > _IN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : IN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( IN3W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PORT`" ] pub enum PORTW { # [ doc = "Disable interrupt on write." ] CLEAR } impl PORTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PORTW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PORTW < 'a > { w : & 'a mut W , } impl < 'a > _PORTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PORTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PORTW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on IN\\[0\\] event." ] # [ inline ] pub fn in0 ( & self ) -> IN0R { IN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on IN\\[1\\] event." ] # [ inline ] pub fn in1 ( & self ) -> IN1R { IN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Disable interrupt on IN\\[2\\] event." ] # [ inline ] pub fn in2 ( & self ) -> IN2R { IN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Disable interrupt on IN\\[3\\] event." ] # [ inline ] pub fn in3 ( & self ) -> IN3R { IN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Disable interrupt on PORT event." ] # [ inline ] pub fn port ( & self ) -> PORTR { PORTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on IN\\[0\\] event." ] # [ inline ] pub fn in0 ( & mut self ) -> _IN0W { _IN0W { w : self } } # [ doc = "Bit 1 - Disable interrupt on IN\\[1\\] event." ] # [ inline ] pub fn in1 ( & mut self ) -> _IN1W { _IN1W { w : self } } # [ doc = "Bit 2 - Disable interrupt on IN\\[2\\] event." ] # [ inline ] pub fn in2 ( & mut self ) -> _IN2W { _IN2W { w : self } } # [ doc = "Bit 3 - Disable interrupt on IN\\[3\\] event." ] # [ inline ] pub fn in3 ( & mut self ) -> _IN3W { _IN3W { w : self } } # [ doc = "Bit 31 - Disable interrupt on PORT event." ] # [ inline ] pub fn port ( & mut self ) -> _PORTW { _PORTW { w : self } } } } # [ doc = "Channel configuration registers." ] pub struct CONFIG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Channel configuration registers." ] pub mod config { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONFIG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Disabled." ] DISABLED , # [ doc = "Channel configure in event mode." ] EVENT , # [ doc = "Channel configure in task mode." ] TASK , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl MODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { MODER :: DISABLED => 0 , MODER :: EVENT => 0x01 , MODER :: TASK => 0x03 , MODER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> MODER { match value { 0 => MODER :: DISABLED , 1 => MODER :: EVENT , 3 => MODER :: TASK , i => MODER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == MODER :: DISABLED } # [ doc = "Checks if the value of the field is `EVENT`" ] # [ inline ] pub fn is_event ( & self ) -> bool { * self == MODER :: EVENT } # [ doc = "Checks if the value of the field is `TASK`" ] # [ inline ] pub fn is_task ( & self ) -> bool { * self == MODER :: TASK } } # [ doc = r" Value of the field" ] pub struct PSELR { bits : u8 , } impl PSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = "Possible values of the field `POLARITY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum POLARITYR { # [ doc = "Low to high." ] LOTOHI , # [ doc = "High to low." ] HITOLO , # [ doc = "Toggle." ] TOGGLE , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl POLARITYR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { POLARITYR :: LOTOHI => 0x01 , POLARITYR :: HITOLO => 0x02 , POLARITYR :: TOGGLE => 0x03 , POLARITYR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> POLARITYR { match value { 1 => POLARITYR :: LOTOHI , 2 => POLARITYR :: HITOLO , 3 => POLARITYR :: TOGGLE , i => POLARITYR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `LOTOHI`" ] # [ inline ] pub fn is_lo_to_hi ( & self ) -> bool { * self == POLARITYR :: LOTOHI } # [ doc = "Checks if the value of the field is `HITOLO`" ] # [ inline ] pub fn is_hi_to_lo ( & self ) -> bool { * self == POLARITYR :: HITOLO } # [ doc = "Checks if the value of the field is `TOGGLE`" ] # [ inline ] pub fn is_toggle ( & self ) -> bool { * self == POLARITYR :: TOGGLE } } # [ doc = "Possible values of the field `OUTINIT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUTINITR { # [ doc = "Initial low output when in task mode." ] LOW , # [ doc = "Initial high output when in task mode." ] HIGH } impl OUTINITR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OUTINITR :: LOW => false , OUTINITR :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OUTINITR { match value { false => OUTINITR :: LOW , true => OUTINITR :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == OUTINITR :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == OUTINITR :: HIGH } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Disabled." ] DISABLED , # [ doc = "Channel configure in event mode." ] EVENT , # [ doc = "Channel configure in task mode." ] TASK } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { MODEW :: DISABLED => 0 , MODEW :: EVENT => 1 , MODEW :: TASK => 3 } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( MODEW :: DISABLED ) } # [ doc = "Channel configure in event mode." ] # [ inline ] pub fn event ( self ) -> & 'a mut W { self . variant ( MODEW :: EVENT ) } # [ doc = "Channel configure in task mode." ] # [ inline ] pub fn task ( self ) -> & 'a mut W { self . variant ( MODEW :: TASK ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _PSELW < 'a > { w : & 'a mut W , } impl < 'a > _PSELW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x1f ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `POLARITY`" ] pub enum POLARITYW { # [ doc = "Low to high." ] LOTOHI , # [ doc = "High to low." ] HITOLO , # [ doc = "Toggle." ] TOGGLE } impl POLARITYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { POLARITYW :: LOTOHI => 1 , POLARITYW :: HITOLO => 2 , POLARITYW :: TOGGLE => 3 } } } # [ doc = r" Proxy" ] pub struct _POLARITYW < 'a > { w : & 'a mut W , } impl < 'a > _POLARITYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : POLARITYW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Low to high." ] # [ inline ] pub fn lo_to_hi ( self ) -> & 'a mut W { self . variant ( POLARITYW :: LOTOHI ) } # [ doc = "High to low." ] # [ inline ] pub fn hi_to_lo ( self ) -> & 'a mut W { self . variant ( POLARITYW :: HITOLO ) } # [ doc = "Toggle." ] # [ inline ] pub fn toggle ( self ) -> & 'a mut W { self . variant ( POLARITYW :: TOGGLE ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OUTINIT`" ] pub enum OUTINITW { # [ doc = "Initial low output when in task mode." ] LOW , # [ doc = "Initial high output when in task mode." ] HIGH } impl OUTINITW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OUTINITW :: LOW => false , OUTINITW :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _OUTINITW < 'a > { w : & 'a mut W , } impl < 'a > _OUTINITW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OUTINITW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Initial low output when in task mode." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUTINITW :: LOW ) } # [ doc = "Initial high output when in task mode." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUTINITW :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Mode" ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:12 - Pin select." ] # [ inline ] pub fn psel ( & self ) -> PSELR { let bits = { const MASK : u8 = 0x1f ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; PSELR { bits } } # [ doc = "Bits 16:17 - Effects on output when in Task mode, or events on input that generates an event." ] # [ inline ] pub fn polarity ( & self ) -> POLARITYR { POLARITYR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 20 - Initial value of the output when the GPIOTE channel is configured as a Task." ] # [ inline ] pub fn outinit ( & self ) -> OUTINITR { OUTINITR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Mode" ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } # [ doc = "Bits 8:12 - Pin select." ] # [ inline ] pub fn psel ( & mut self ) -> _PSELW { _PSELW { w : self } } # [ doc = "Bits 16:17 - Effects on output when in Task mode, or events on input that generates an event." ] # [ inline ] pub fn polarity ( & mut self ) -> _POLARITYW { _POLARITYW { w : self } } # [ doc = "Bit 20 - Initial value of the output when the GPIOTE channel is configured as a Task." ] # [ inline ] pub fn outinit ( & mut self ) -> _OUTINITW { _OUTINITW { w : self } } } } } # [ doc = "Analog to digital converter." ] pub struct ADC { _marker : PhantomData < * const ( ) > } unsafe impl Send for ADC { } impl ADC { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const adc :: RegisterBlock { 0x4000_7000 as * const _ } } impl Deref for ADC { type Target = adc :: RegisterBlock ; fn deref ( & self ) -> & adc :: RegisterBlock { unsafe { & * ADC :: ptr ( ) } } } # [ doc = "Analog to digital converter." ] pub mod adc { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start an ADC conversion." ] pub tasks_start : TASKS_START , # [ doc = "0x04 - Stop ADC." ] pub tasks_stop : TASKS_STOP , _reserved0 : [ u8 ; 248usize ] , # [ doc = "0x100 - ADC conversion complete." ] pub events_end : EVENTS_END , _reserved1 : [ u8 ; 512usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved2 : [ u8 ; 244usize ] , # [ doc = "0x400 - ADC busy register." ] pub busy : BUSY , _reserved3 : [ u8 ; 252usize ] , # [ doc = "0x500 - ADC enable." ] pub enable : ENABLE , # [ doc = "0x504 - ADC configuration register." ] pub config : CONFIG , # [ doc = "0x508 - Result of ADC conversion." ] pub result : RESULT , } # [ doc = "Start an ADC conversion." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start an ADC conversion." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop ADC." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop ADC." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "ADC conversion complete." ] pub struct EVENTS_END { register : :: vcell :: VolatileCell < u32 > } # [ doc = "ADC conversion complete." ] pub mod events_end { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_END { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `END`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDR :: DISABLED => false , ENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDR { match value { false => ENDR :: DISABLED , true => ENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDR :: ENABLED } } # [ doc = "Values that can be written to the field `END`" ] pub enum ENDW { # [ doc = "Enable interrupt on write." ] SET } impl ENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ENDW < 'a > { w : & 'a mut W , } impl < 'a > _ENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ENDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on END event." ] # [ inline ] pub fn end ( & self ) -> ENDR { ENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on END event." ] # [ inline ] pub fn end ( & mut self ) -> _ENDW { _ENDW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `END`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDR :: DISABLED => false , ENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDR { match value { false => ENDR :: DISABLED , true => ENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDR :: ENABLED } } # [ doc = "Values that can be written to the field `END`" ] pub enum ENDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ENDW < 'a > { w : & 'a mut W , } impl < 'a > _ENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ENDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on END event." ] # [ inline ] pub fn end ( & self ) -> ENDR { ENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on END event." ] # [ inline ] pub fn end ( & mut self ) -> _ENDW { _ENDW { w : self } } } } # [ doc = "ADC busy register." ] pub struct BUSY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "ADC busy register." ] pub mod busy { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: BUSY { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `BUSY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BUSYR { # [ doc = "No ongoing ADC conversion is taking place. ADC is ready." ] READY , # [ doc = "An ADC conversion is taking place. ADC is busy." ] BUSY } impl BUSYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { BUSYR :: READY => false , BUSYR :: BUSY => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> BUSYR { match value { false => BUSYR :: READY , true => BUSYR :: BUSY , } } # [ doc = "Checks if the value of the field is `READY`" ] # [ inline ] pub fn is_ready ( & self ) -> bool { * self == BUSYR :: READY } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ] pub fn is_busy ( & self ) -> bool { * self == BUSYR :: BUSY } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - ADC busy register." ] # [ inline ] pub fn busy ( & self ) -> BUSYR { BUSYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "ADC enable." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "ADC enable." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "ADC is disabled." ] DISABLED , # [ doc = "ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ENABLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ENABLER :: DISABLED => 0 , ENABLER :: ENABLED => 0x01 , ENABLER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ENABLER { match value { 0 => ENABLER :: DISABLED , 1 => ENABLER :: ENABLED , i => ENABLER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "ADC is disabled." ] DISABLED , # [ doc = "ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ENABLEW :: DISABLED => 0 , ENABLEW :: ENABLED => 1 } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "ADC is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - ADC enable." ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - ADC enable." ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "ADC configuration register." ] pub struct CONFIG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "ADC configuration register." ] pub mod config { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONFIG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `RES`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RESR { # [ doc = "8bit ADC resolution." ] _8BIT , # [ doc = "9bit ADC resolution." ] _9BIT , # [ doc = "10bit ADC resolution." ] _10BIT , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl RESR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { RESR :: _8BIT => 0 , RESR :: _9BIT => 0x01 , RESR :: _10BIT => 0x02 , RESR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> RESR { match value { 0 => RESR :: _8BIT , 1 => RESR :: _9BIT , 2 => RESR :: _10BIT , i => RESR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ] pub fn is_8bit ( & self ) -> bool { * self == RESR :: _8BIT } # [ doc = "Checks if the value of the field is `_9BIT`" ] # [ inline ] pub fn is_9bit ( & self ) -> bool { * self == RESR :: _9BIT } # [ doc = "Checks if the value of the field is `_10BIT`" ] # [ inline ] pub fn is_10bit ( & self ) -> bool { * self == RESR :: _10BIT } } # [ doc = "Possible values of the field `INPSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INPSELR { # [ doc = "Analog input specified by PSEL with no prescaling used as input for the conversion." ] ANALOGINPUTNOPRESCALING , # [ doc = "Analog input specified by PSEL with 2/3 prescaling used as input for the conversion." ] ANALOGINPUTTWOTHIRDSPRESCALING , # [ doc = "Analog input specified by PSEL with 1/3 prescaling used as input for the conversion." ] ANALOGINPUTONETHIRDPRESCALING , # [ doc = "Supply voltage with 2/3 prescaling used as input for the conversion." ] SUPPLYTWOTHIRDSPRESCALING , # [ doc = "Supply voltage with 1/3 prescaling used as input for the conversion." ] SUPPLYONETHIRDPRESCALING , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl INPSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { INPSELR :: ANALOGINPUTNOPRESCALING => 0 , INPSELR :: ANALOGINPUTTWOTHIRDSPRESCALING => 0x01 , INPSELR :: ANALOGINPUTONETHIRDPRESCALING => 0x02 , INPSELR :: SUPPLYTWOTHIRDSPRESCALING => 0x05 , INPSELR :: SUPPLYONETHIRDPRESCALING => 0x06 , INPSELR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> INPSELR { match value { 0 => INPSELR :: ANALOGINPUTNOPRESCALING , 1 => INPSELR :: ANALOGINPUTTWOTHIRDSPRESCALING , 2 => INPSELR :: ANALOGINPUTONETHIRDPRESCALING , 5 => INPSELR :: SUPPLYTWOTHIRDSPRESCALING , 6 => INPSELR :: SUPPLYONETHIRDPRESCALING , i => INPSELR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `ANALOGINPUTNOPRESCALING`" ] # [ inline ] pub fn is_analog_input_no_prescaling ( & self ) -> bool { * self == INPSELR :: ANALOGINPUTNOPRESCALING } # [ doc = "Checks if the value of the field is `ANALOGINPUTTWOTHIRDSPRESCALING`" ] # [ inline ] pub fn is_analog_input_two_thirds_prescaling ( & self ) -> bool { * self == INPSELR :: ANALOGINPUTTWOTHIRDSPRESCALING } # [ doc = "Checks if the value of the field is `ANALOGINPUTONETHIRDPRESCALING`" ] # [ inline ] pub fn is_analog_input_one_third_prescaling ( & self ) -> bool { * self == INPSELR :: ANALOGINPUTONETHIRDPRESCALING } # [ doc = "Checks if the value of the field is `SUPPLYTWOTHIRDSPRESCALING`" ] # [ inline ] pub fn is_supply_two_thirds_prescaling ( & self ) -> bool { * self == INPSELR :: SUPPLYTWOTHIRDSPRESCALING } # [ doc = "Checks if the value of the field is `SUPPLYONETHIRDPRESCALING`" ] # [ inline ] pub fn is_supply_one_third_prescaling ( & self ) -> bool { * self == INPSELR :: SUPPLYONETHIRDPRESCALING } } # [ doc = "Possible values of the field `REFSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFSELR { # [ doc = "Use internal 1.2V bandgap voltage as reference for conversion." ] VBG , # [ doc = "Use external source configured by EXTREFSEL as reference for conversion." ] EXTERNAL , # [ doc = "Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V." ] SUPPLYONEHALFPRESCALING , # [ doc = "Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V." ] SUPPLYONETHIRDPRESCALING } impl REFSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { REFSELR :: VBG => 0 , REFSELR :: EXTERNAL => 0x01 , REFSELR :: SUPPLYONEHALFPRESCALING => 0x02 , REFSELR :: SUPPLYONETHIRDPRESCALING => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> REFSELR { match value { 0 => REFSELR :: VBG , 1 => REFSELR :: EXTERNAL , 2 => REFSELR :: SUPPLYONEHALFPRESCALING , 3 => REFSELR :: SUPPLYONETHIRDPRESCALING , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `VBG`" ] # [ inline ] pub fn is_vbg ( & self ) -> bool { * self == REFSELR :: VBG } # [ doc = "Checks if the value of the field is `EXTERNAL`" ] # [ inline ] pub fn is_external ( & self ) -> bool { * self == REFSELR :: EXTERNAL } # [ doc = "Checks if the value of the field is `SUPPLYONEHALFPRESCALING`" ] # [ inline ] pub fn is_supply_one_half_prescaling ( & self ) -> bool { * self == REFSELR :: SUPPLYONEHALFPRESCALING } # [ doc = "Checks if the value of the field is `SUPPLYONETHIRDPRESCALING`" ] # [ inline ] pub fn is_supply_one_third_prescaling ( & self ) -> bool { * self == REFSELR :: SUPPLYONETHIRDPRESCALING } } # [ doc = "Possible values of the field `PSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PSELR { # [ doc = "Analog input pins disabled." ] DISABLED , # [ doc = "Use analog input 0 as analog input." ] ANALOGINPUT0 , # [ doc = "Use analog input 1 as analog input." ] ANALOGINPUT1 , # [ doc = "Use analog input 2 as analog input." ] ANALOGINPUT2 , # [ doc = "Use analog input 3 as analog input." ] ANALOGINPUT3 , # [ doc = "Use analog input 4 as analog input." ] ANALOGINPUT4 , # [ doc = "Use analog input 5 as analog input." ] ANALOGINPUT5 , # [ doc = "Use analog input 6 as analog input." ] ANALOGINPUT6 , # [ doc = "Use analog input 7 as analog input." ] ANALOGINPUT7 , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl PSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PSELR :: DISABLED => 0 , PSELR :: ANALOGINPUT0 => 0x01 , PSELR :: ANALOGINPUT1 => 0x02 , PSELR :: ANALOGINPUT2 => 0x04 , PSELR :: ANALOGINPUT3 => 0x08 , PSELR :: ANALOGINPUT4 => 0x10 , PSELR :: ANALOGINPUT5 => 0x20 , PSELR :: ANALOGINPUT6 => 0x40 , PSELR :: ANALOGINPUT7 => 0x80 , PSELR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PSELR { match value { 0 => PSELR :: DISABLED , 1 => PSELR :: ANALOGINPUT0 , 2 => PSELR :: ANALOGINPUT1 , 4 => PSELR :: ANALOGINPUT2 , 8 => PSELR :: ANALOGINPUT3 , 16 => PSELR :: ANALOGINPUT4 , 32 => PSELR :: ANALOGINPUT5 , 64 => PSELR :: ANALOGINPUT6 , 128 => PSELR :: ANALOGINPUT7 , i => PSELR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PSELR :: DISABLED } # [ doc = "Checks if the value of the field is `ANALOGINPUT0`" ] # [ inline ] pub fn is_analog_input0 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT0 } # [ doc = "Checks if the value of the field is `ANALOGINPUT1`" ] # [ inline ] pub fn is_analog_input1 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT1 } # [ doc = "Checks if the value of the field is `ANALOGINPUT2`" ] # [ inline ] pub fn is_analog_input2 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT2 } # [ doc = "Checks if the value of the field is `ANALOGINPUT3`" ] # [ inline ] pub fn is_analog_input3 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT3 } # [ doc = "Checks if the value of the field is `ANALOGINPUT4`" ] # [ inline ] pub fn is_analog_input4 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT4 } # [ doc = "Checks if the value of the field is `ANALOGINPUT5`" ] # [ inline ] pub fn is_analog_input5 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT5 } # [ doc = "Checks if the value of the field is `ANALOGINPUT6`" ] # [ inline ] pub fn is_analog_input6 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT6 } # [ doc = "Checks if the value of the field is `ANALOGINPUT7`" ] # [ inline ] pub fn is_analog_input7 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT7 } } # [ doc = "Possible values of the field `EXTREFSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EXTREFSELR { # [ doc = "Analog external reference inputs disabled." ] NONE , # [ doc = "Use analog reference 0 as reference." ] ANALOGREFERENCE0 , # [ doc = "Use analog reference 1 as reference." ] ANALOGREFERENCE1 , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl EXTREFSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { EXTREFSELR :: NONE => 0 , EXTREFSELR :: ANALOGREFERENCE0 => 0x01 , EXTREFSELR :: ANALOGREFERENCE1 => 0x02 , EXTREFSELR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> EXTREFSELR { match value { 0 => EXTREFSELR :: NONE , 1 => EXTREFSELR :: ANALOGREFERENCE0 , 2 => EXTREFSELR :: ANALOGREFERENCE1 , i => EXTREFSELR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ] pub fn is_none ( & self ) -> bool { * self == EXTREFSELR :: NONE } # [ doc = "Checks if the value of the field is `ANALOGREFERENCE0`" ] # [ inline ] pub fn is_analog_reference0 ( & self ) -> bool { * self == EXTREFSELR :: ANALOGREFERENCE0 } # [ doc = "Checks if the value of the field is `ANALOGREFERENCE1`" ] # [ inline ] pub fn is_analog_reference1 ( & self ) -> bool { * self == EXTREFSELR :: ANALOGREFERENCE1 } } # [ doc = "Values that can be written to the field `RES`" ] pub enum RESW { # [ doc = "8bit ADC resolution." ] _8BIT , # [ doc = "9bit ADC resolution." ] _9BIT , # [ doc = "10bit ADC resolution." ] _10BIT } impl RESW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { RESW :: _8BIT => 0 , RESW :: _9BIT => 1 , RESW :: _10BIT => 2 } } } # [ doc = r" Proxy" ] pub struct _RESW < 'a > { w : & 'a mut W , } impl < 'a > _RESW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RESW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "8bit ADC resolution." ] # [ inline ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( RESW :: _8BIT ) } # [ doc = "9bit ADC resolution." ] # [ inline ] pub fn _9bit ( self ) -> & 'a mut W { self . variant ( RESW :: _9BIT ) } # [ doc = "10bit ADC resolution." ] # [ inline ] pub fn _10bit ( self ) -> & 'a mut W { self . variant ( RESW :: _10BIT ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INPSEL`" ] pub enum INPSELW { # [ doc = "Analog input specified by PSEL with no prescaling used as input for the conversion." ] ANALOGINPUTNOPRESCALING , # [ doc = "Analog input specified by PSEL with 2/3 prescaling used as input for the conversion." ] ANALOGINPUTTWOTHIRDSPRESCALING , # [ doc = "Analog input specified by PSEL with 1/3 prescaling used as input for the conversion." ] ANALOGINPUTONETHIRDPRESCALING , # [ doc = "Supply voltage with 2/3 prescaling used as input for the conversion." ] SUPPLYTWOTHIRDSPRESCALING , # [ doc = "Supply voltage with 1/3 prescaling used as input for the conversion." ] SUPPLYONETHIRDPRESCALING } impl INPSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { INPSELW :: ANALOGINPUTNOPRESCALING => 0 , INPSELW :: ANALOGINPUTTWOTHIRDSPRESCALING => 1 , INPSELW :: ANALOGINPUTONETHIRDPRESCALING => 2 , INPSELW :: SUPPLYTWOTHIRDSPRESCALING => 5 , INPSELW :: SUPPLYONETHIRDPRESCALING => 6 } } } # [ doc = r" Proxy" ] pub struct _INPSELW < 'a > { w : & 'a mut W , } impl < 'a > _INPSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INPSELW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Analog input specified by PSEL with no prescaling used as input for the conversion." ] # [ inline ] pub fn analog_input_no_prescaling ( self ) -> & 'a mut W { self . variant ( INPSELW :: ANALOGINPUTNOPRESCALING ) } # [ doc = "Analog input specified by PSEL with 2/3 prescaling used as input for the conversion." ] # [ inline ] pub fn analog_input_two_thirds_prescaling ( self ) -> & 'a mut W { self . variant ( INPSELW :: ANALOGINPUTTWOTHIRDSPRESCALING ) } # [ doc = "Analog input specified by PSEL with 1/3 prescaling used as input for the conversion." ] # [ inline ] pub fn analog_input_one_third_prescaling ( self ) -> & 'a mut W { self . variant ( INPSELW :: ANALOGINPUTONETHIRDPRESCALING ) } # [ doc = "Supply voltage with 2/3 prescaling used as input for the conversion." ] # [ inline ] pub fn supply_two_thirds_prescaling ( self ) -> & 'a mut W { self . variant ( INPSELW :: SUPPLYTWOTHIRDSPRESCALING ) } # [ doc = "Supply voltage with 1/3 prescaling used as input for the conversion." ] # [ inline ] pub fn supply_one_third_prescaling ( self ) -> & 'a mut W { self . variant ( INPSELW :: SUPPLYONETHIRDPRESCALING ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `REFSEL`" ] pub enum REFSELW { # [ doc = "Use internal 1.2V bandgap voltage as reference for conversion." ] VBG , # [ doc = "Use external source configured by EXTREFSEL as reference for conversion." ] EXTERNAL , # [ doc = "Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V." ] SUPPLYONEHALFPRESCALING , # [ doc = "Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V." ] SUPPLYONETHIRDPRESCALING } impl REFSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { REFSELW :: VBG => 0 , REFSELW :: EXTERNAL => 1 , REFSELW :: SUPPLYONEHALFPRESCALING => 2 , REFSELW :: SUPPLYONETHIRDPRESCALING => 3 } } } # [ doc = r" Proxy" ] pub struct _REFSELW < 'a > { w : & 'a mut W , } impl < 'a > _REFSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : REFSELW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Use internal 1.2V bandgap voltage as reference for conversion." ] # [ inline ] pub fn vbg ( self ) -> & 'a mut W { self . variant ( REFSELW :: VBG ) } # [ doc = "Use external source configured by EXTREFSEL as reference for conversion." ] # [ inline ] pub fn external ( self ) -> & 'a mut W { self . variant ( REFSELW :: EXTERNAL ) } # [ doc = "Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V." ] # [ inline ] pub fn supply_one_half_prescaling ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLYONEHALFPRESCALING ) } # [ doc = "Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V." ] # [ inline ] pub fn supply_one_third_prescaling ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLYONETHIRDPRESCALING ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PSEL`" ] pub enum PSELW { # [ doc = "Analog input pins disabled." ] DISABLED , # [ doc = "Use analog input 0 as analog input." ] ANALOGINPUT0 , # [ doc = "Use analog input 1 as analog input." ] ANALOGINPUT1 , # [ doc = "Use analog input 2 as analog input." ] ANALOGINPUT2 , # [ doc = "Use analog input 3 as analog input." ] ANALOGINPUT3 , # [ doc = "Use analog input 4 as analog input." ] ANALOGINPUT4 , # [ doc = "Use analog input 5 as analog input." ] ANALOGINPUT5 , # [ doc = "Use analog input 6 as analog input." ] ANALOGINPUT6 , # [ doc = "Use analog input 7 as analog input." ] ANALOGINPUT7 } impl PSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PSELW :: DISABLED => 0 , PSELW :: ANALOGINPUT0 => 1 , PSELW :: ANALOGINPUT1 => 2 , PSELW :: ANALOGINPUT2 => 4 , PSELW :: ANALOGINPUT3 => 8 , PSELW :: ANALOGINPUT4 => 16 , PSELW :: ANALOGINPUT5 => 32 , PSELW :: ANALOGINPUT6 => 64 , PSELW :: ANALOGINPUT7 => 128 } } } # [ doc = r" Proxy" ] pub struct _PSELW < 'a > { w : & 'a mut W , } impl < 'a > _PSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PSELW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Analog input pins disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PSELW :: DISABLED ) } # [ doc = "Use analog input 0 as analog input." ] # [ inline ] pub fn analog_input0 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT0 ) } # [ doc = "Use analog input 1 as analog input." ] # [ inline ] pub fn analog_input1 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT1 ) } # [ doc = "Use analog input 2 as analog input." ] # [ inline ] pub fn analog_input2 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT2 ) } # [ doc = "Use analog input 3 as analog input." ] # [ inline ] pub fn analog_input3 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT3 ) } # [ doc = "Use analog input 4 as analog input." ] # [ inline ] pub fn analog_input4 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT4 ) } # [ doc = "Use analog input 5 as analog input." ] # [ inline ] pub fn analog_input5 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT5 ) } # [ doc = "Use analog input 6 as analog input." ] # [ inline ] pub fn analog_input6 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT6 ) } # [ doc = "Use analog input 7 as analog input." ] # [ inline ] pub fn analog_input7 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT7 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `EXTREFSEL`" ] pub enum EXTREFSELW { # [ doc = "Analog external reference inputs disabled." ] NONE , # [ doc = "Use analog reference 0 as reference." ] ANALOGREFERENCE0 , # [ doc = "Use analog reference 1 as reference." ] ANALOGREFERENCE1 } impl EXTREFSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { EXTREFSELW :: NONE => 0 , EXTREFSELW :: ANALOGREFERENCE0 => 1 , EXTREFSELW :: ANALOGREFERENCE1 => 2 } } } # [ doc = r" Proxy" ] pub struct _EXTREFSELW < 'a > { w : & 'a mut W , } impl < 'a > _EXTREFSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EXTREFSELW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Analog external reference inputs disabled." ] # [ inline ] pub fn none ( self ) -> & 'a mut W { self . variant ( EXTREFSELW :: NONE ) } # [ doc = "Use analog reference 0 as reference." ] # [ inline ] pub fn analog_reference0 ( self ) -> & 'a mut W { self . variant ( EXTREFSELW :: ANALOGREFERENCE0 ) } # [ doc = "Use analog reference 1 as reference." ] # [ inline ] pub fn analog_reference1 ( self ) -> & 'a mut W { self . variant ( EXTREFSELW :: ANALOGREFERENCE1 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - ADC resolution." ] # [ inline ] pub fn res ( & self ) -> RESR { RESR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 2:4 - ADC input selection." ] # [ inline ] pub fn inpsel ( & self ) -> INPSELR { INPSELR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 5:6 - ADC reference selection." ] # [ inline ] pub fn refsel ( & self ) -> REFSELR { REFSELR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:15 - ADC analog pin selection." ] # [ inline ] pub fn psel ( & self ) -> PSELR { PSELR :: _from ( { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 16:17 - ADC external reference pin selection." ] # [ inline ] pub fn extrefsel ( & self ) -> EXTREFSELR { EXTREFSELR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x18 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - ADC resolution." ] # [ inline ] pub fn res ( & mut self ) -> _RESW { _RESW { w : self } } # [ doc = "Bits 2:4 - ADC input selection." ] # [ inline ] pub fn inpsel ( & mut self ) -> _INPSELW { _INPSELW { w : self } } # [ doc = "Bits 5:6 - ADC reference selection." ] # [ inline ] pub fn refsel ( & mut self ) -> _REFSELW { _REFSELW { w : self } } # [ doc = "Bits 8:15 - ADC analog pin selection." ] # [ inline ] pub fn psel ( & mut self ) -> _PSELW { _PSELW { w : self } } # [ doc = "Bits 16:17 - ADC external reference pin selection." ] # [ inline ] pub fn extrefsel ( & mut self ) -> _EXTREFSELW { _EXTREFSELW { w : self } } } } # [ doc = "Result of ADC conversion." ] pub struct RESULT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Result of ADC conversion." ] pub mod result { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: RESULT { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct RESULTR { bits : u16 , } impl RESULTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:9 - Result of ADC conversion." ] # [ inline ] pub fn result ( & self ) -> RESULTR { let bits = { const MASK : u16 = 0x03ff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; RESULTR { bits } } } } } # [ doc = "Timer 0." ] pub struct TIMER0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TIMER0 { } impl TIMER0 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const timer0 :: RegisterBlock { 0x4000_8000 as * const _ } } impl Deref for TIMER0 { type Target = timer0 :: RegisterBlock ; fn deref ( & self ) -> & timer0 :: RegisterBlock { unsafe { & * TIMER0 :: ptr ( ) } } } # [ doc = "Timer 0." ] pub mod timer0 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start Timer." ] pub tasks_start : TASKS_START , # [ doc = "0x04 - Stop Timer." ] pub tasks_stop : TASKS_STOP , # [ doc = "0x08 - Increment Timer (In counter mode)." ] pub tasks_count : TASKS_COUNT , # [ doc = "0x0c - Clear timer." ] pub tasks_clear : TASKS_CLEAR , _reserved0 : [ u8 ; 48usize ] , # [ doc = "0x40 - Capture Timer value to CC\\[n\\] registers." ] pub tasks_capture : [ TASKS_CAPTURE ; 4 ] , _reserved1 : [ u8 ; 240usize ] , # [ doc = "0x140 - Compare event on CC\\[n\\] match." ] pub events_compare : [ EVENTS_COMPARE ; 4 ] , _reserved2 : [ u8 ; 176usize ] , # [ doc = "0x200 - Shortcuts for Timer." ] pub shorts : SHORTS , _reserved3 : [ u8 ; 256usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved4 : [ u8 ; 504usize ] , # [ doc = "0x504 - Timer Mode selection." ] pub mode : MODE , # [ doc = "0x508 - Sets timer behaviour." ] pub bitmode : BITMODE , _reserved5 : [ u8 ; 4usize ] , # [ doc = "0x510 - 4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE." ] pub prescaler : PRESCALER , _reserved6 : [ u8 ; 44usize ] , # [ doc = "0x540 - Capture/compare registers." ] pub cc : [ CC ; 4 ] , } # [ doc = "Start Timer." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start Timer." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop Timer." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop Timer." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Increment Timer (In counter mode)." ] pub struct TASKS_COUNT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Increment Timer (In counter mode)." ] pub mod tasks_count { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_COUNT { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Clear timer." ] pub struct TASKS_CLEAR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Clear timer." ] pub mod tasks_clear { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_CLEAR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Capture Timer value to CC\\[n\\] registers." ] pub struct TASKS_CAPTURE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture Timer value to CC\\[n\\] registers." ] pub mod tasks_capture { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_CAPTURE { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Compare event on CC\\[n\\] match." ] pub struct EVENTS_COMPARE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Compare event on CC\\[n\\] match." ] pub mod events_compare { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_COMPARE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Shortcuts for Timer." ] pub struct SHORTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Shortcuts for Timer." ] pub mod shorts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SHORTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `COMPARE0_CLEAR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE0_CLEARR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE0_CLEARR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE0_CLEARR :: DISABLED => false , COMPARE0_CLEARR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE0_CLEARR { match value { false => COMPARE0_CLEARR :: DISABLED , true => COMPARE0_CLEARR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE0_CLEARR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE0_CLEARR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE1_CLEAR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE1_CLEARR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE1_CLEARR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE1_CLEARR :: DISABLED => false , COMPARE1_CLEARR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE1_CLEARR { match value { false => COMPARE1_CLEARR :: DISABLED , true => COMPARE1_CLEARR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE1_CLEARR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE1_CLEARR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE2_CLEAR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE2_CLEARR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE2_CLEARR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE2_CLEARR :: DISABLED => false , COMPARE2_CLEARR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE2_CLEARR { match value { false => COMPARE2_CLEARR :: DISABLED , true => COMPARE2_CLEARR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE2_CLEARR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE2_CLEARR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE3_CLEAR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE3_CLEARR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE3_CLEARR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE3_CLEARR :: DISABLED => false , COMPARE3_CLEARR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE3_CLEARR { match value { false => COMPARE3_CLEARR :: DISABLED , true => COMPARE3_CLEARR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE3_CLEARR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE3_CLEARR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE0_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE0_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE0_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE0_STOPR :: DISABLED => false , COMPARE0_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE0_STOPR { match value { false => COMPARE0_STOPR :: DISABLED , true => COMPARE0_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE0_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE0_STOPR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE1_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE1_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE1_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE1_STOPR :: DISABLED => false , COMPARE1_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE1_STOPR { match value { false => COMPARE1_STOPR :: DISABLED , true => COMPARE1_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE1_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE1_STOPR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE2_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE2_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE2_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE2_STOPR :: DISABLED => false , COMPARE2_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE2_STOPR { match value { false => COMPARE2_STOPR :: DISABLED , true => COMPARE2_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE2_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE2_STOPR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE3_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE3_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE3_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE3_STOPR :: DISABLED => false , COMPARE3_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE3_STOPR { match value { false => COMPARE3_STOPR :: DISABLED , true => COMPARE3_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE3_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE3_STOPR :: ENABLED } } # [ doc = "Values that can be written to the field `COMPARE0_CLEAR`" ] pub enum COMPARE0_CLEARW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE0_CLEARW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE0_CLEARW :: DISABLED => false , COMPARE0_CLEARW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE0_CLEARW < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE0_CLEARW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE0_CLEARW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE0_CLEARW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE0_CLEARW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE1_CLEAR`" ] pub enum COMPARE1_CLEARW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE1_CLEARW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE1_CLEARW :: DISABLED => false , COMPARE1_CLEARW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE1_CLEARW < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE1_CLEARW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE1_CLEARW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE1_CLEARW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE1_CLEARW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE2_CLEAR`" ] pub enum COMPARE2_CLEARW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE2_CLEARW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE2_CLEARW :: DISABLED => false , COMPARE2_CLEARW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE2_CLEARW < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE2_CLEARW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE2_CLEARW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE2_CLEARW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE2_CLEARW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE3_CLEAR`" ] pub enum COMPARE3_CLEARW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE3_CLEARW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE3_CLEARW :: DISABLED => false , COMPARE3_CLEARW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE3_CLEARW < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE3_CLEARW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE3_CLEARW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE3_CLEARW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE3_CLEARW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE0_STOP`" ] pub enum COMPARE0_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE0_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE0_STOPW :: DISABLED => false , COMPARE0_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE0_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE0_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE0_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE0_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE0_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE1_STOP`" ] pub enum COMPARE1_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE1_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE1_STOPW :: DISABLED => false , COMPARE1_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE1_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE1_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE1_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE1_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE1_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE2_STOP`" ] pub enum COMPARE2_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE2_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE2_STOPW :: DISABLED => false , COMPARE2_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE2_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE2_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE2_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE2_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE2_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE3_STOP`" ] pub enum COMPARE3_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl COMPARE3_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE3_STOPW :: DISABLED => false , COMPARE3_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE3_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE3_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE3_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE3_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE3_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Shortcut between CC\\[0\\] event and the CLEAR task." ] # [ inline ] pub fn compare0_clear ( & self ) -> COMPARE0_CLEARR { COMPARE0_CLEARR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Shortcut between CC\\[1\\] event and the CLEAR task." ] # [ inline ] pub fn compare1_clear ( & self ) -> COMPARE1_CLEARR { COMPARE1_CLEARR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Shortcut between CC\\[2\\] event and the CLEAR task." ] # [ inline ] pub fn compare2_clear ( & self ) -> COMPARE2_CLEARR { COMPARE2_CLEARR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Shortcut between CC\\[3\\] event and the CLEAR task." ] # [ inline ] pub fn compare3_clear ( & self ) -> COMPARE3_CLEARR { COMPARE3_CLEARR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Shortcut between CC\\[0\\] event and the STOP task." ] # [ inline ] pub fn compare0_stop ( & self ) -> COMPARE0_STOPR { COMPARE0_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Shortcut between CC\\[1\\] event and the STOP task." ] # [ inline ] pub fn compare1_stop ( & self ) -> COMPARE1_STOPR { COMPARE1_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Shortcut between CC\\[2\\] event and the STOP task." ] # [ inline ] pub fn compare2_stop ( & self ) -> COMPARE2_STOPR { COMPARE2_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Shortcut between CC\\[3\\] event and the STOP task." ] # [ inline ] pub fn compare3_stop ( & self ) -> COMPARE3_STOPR { COMPARE3_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Shortcut between CC\\[0\\] event and the CLEAR task." ] # [ inline ] pub fn compare0_clear ( & mut self ) -> _COMPARE0_CLEARW { _COMPARE0_CLEARW { w : self } } # [ doc = "Bit 1 - Shortcut between CC\\[1\\] event and the CLEAR task." ] # [ inline ] pub fn compare1_clear ( & mut self ) -> _COMPARE1_CLEARW { _COMPARE1_CLEARW { w : self } } # [ doc = "Bit 2 - Shortcut between CC\\[2\\] event and the CLEAR task." ] # [ inline ] pub fn compare2_clear ( & mut self ) -> _COMPARE2_CLEARW { _COMPARE2_CLEARW { w : self } } # [ doc = "Bit 3 - Shortcut between CC\\[3\\] event and the CLEAR task." ] # [ inline ] pub fn compare3_clear ( & mut self ) -> _COMPARE3_CLEARW { _COMPARE3_CLEARW { w : self } } # [ doc = "Bit 8 - Shortcut between CC\\[0\\] event and the STOP task." ] # [ inline ] pub fn compare0_stop ( & mut self ) -> _COMPARE0_STOPW { _COMPARE0_STOPW { w : self } } # [ doc = "Bit 9 - Shortcut between CC\\[1\\] event and the STOP task." ] # [ inline ] pub fn compare1_stop ( & mut self ) -> _COMPARE1_STOPW { _COMPARE1_STOPW { w : self } } # [ doc = "Bit 10 - Shortcut between CC\\[2\\] event and the STOP task." ] # [ inline ] pub fn compare2_stop ( & mut self ) -> _COMPARE2_STOPW { _COMPARE2_STOPW { w : self } } # [ doc = "Bit 11 - Shortcut between CC\\[3\\] event and the STOP task." ] # [ inline ] pub fn compare3_stop ( & mut self ) -> _COMPARE3_STOPW { _COMPARE3_STOPW { w : self } } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `COMPARE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE0R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE0R :: DISABLED => false , COMPARE0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE0R { match value { false => COMPARE0R :: DISABLED , true => COMPARE0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE0R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE1R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE1R :: DISABLED => false , COMPARE1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE1R { match value { false => COMPARE1R :: DISABLED , true => COMPARE1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE1R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE2R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE2R :: DISABLED => false , COMPARE2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE2R { match value { false => COMPARE2R :: DISABLED , true => COMPARE2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE2R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE3R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE3R :: DISABLED => false , COMPARE3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE3R { match value { false => COMPARE3R :: DISABLED , true => COMPARE3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE3R :: ENABLED } } # [ doc = "Values that can be written to the field `COMPARE0`" ] pub enum COMPARE0W { # [ doc = "Enable interrupt on write." ] SET } impl COMPARE0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE0W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE0W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE0W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE1`" ] pub enum COMPARE1W { # [ doc = "Enable interrupt on write." ] SET } impl COMPARE1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE1W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE1W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE1W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE2`" ] pub enum COMPARE2W { # [ doc = "Enable interrupt on write." ] SET } impl COMPARE2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE2W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE2W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE2W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE3`" ] pub enum COMPARE3W { # [ doc = "Enable interrupt on write." ] SET } impl COMPARE3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE3W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE3W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE3W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 16 - Enable interrupt on COMPARE\\[0\\]" ] # [ inline ] pub fn compare0 ( & self ) -> COMPARE0R { COMPARE0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Enable interrupt on COMPARE\\[1\\]" ] # [ inline ] pub fn compare1 ( & self ) -> COMPARE1R { COMPARE1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Enable interrupt on COMPARE\\[2\\]" ] # [ inline ] pub fn compare2 ( & self ) -> COMPARE2R { COMPARE2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Enable interrupt on COMPARE\\[3\\]" ] # [ inline ] pub fn compare3 ( & self ) -> COMPARE3R { COMPARE3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 16 - Enable interrupt on COMPARE\\[0\\]" ] # [ inline ] pub fn compare0 ( & mut self ) -> _COMPARE0W { _COMPARE0W { w : self } } # [ doc = "Bit 17 - Enable interrupt on COMPARE\\[1\\]" ] # [ inline ] pub fn compare1 ( & mut self ) -> _COMPARE1W { _COMPARE1W { w : self } } # [ doc = "Bit 18 - Enable interrupt on COMPARE\\[2\\]" ] # [ inline ] pub fn compare2 ( & mut self ) -> _COMPARE2W { _COMPARE2W { w : self } } # [ doc = "Bit 19 - Enable interrupt on COMPARE\\[3\\]" ] # [ inline ] pub fn compare3 ( & mut self ) -> _COMPARE3W { _COMPARE3W { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `COMPARE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE0R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE0R :: DISABLED => false , COMPARE0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE0R { match value { false => COMPARE0R :: DISABLED , true => COMPARE0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE0R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE1R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE1R :: DISABLED => false , COMPARE1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE1R { match value { false => COMPARE1R :: DISABLED , true => COMPARE1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE1R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE2R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE2R :: DISABLED => false , COMPARE2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE2R { match value { false => COMPARE2R :: DISABLED , true => COMPARE2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE2R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE3R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE3R :: DISABLED => false , COMPARE3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE3R { match value { false => COMPARE3R :: DISABLED , true => COMPARE3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE3R :: ENABLED } } # [ doc = "Values that can be written to the field `COMPARE0`" ] pub enum COMPARE0W { # [ doc = "Disable interrupt on write." ] CLEAR } impl COMPARE0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE0W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE0W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE0W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE1`" ] pub enum COMPARE1W { # [ doc = "Disable interrupt on write." ] CLEAR } impl COMPARE1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE1W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE1W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE1W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE2`" ] pub enum COMPARE2W { # [ doc = "Disable interrupt on write." ] CLEAR } impl COMPARE2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE2W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE2W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE2W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE3`" ] pub enum COMPARE3W { # [ doc = "Disable interrupt on write." ] CLEAR } impl COMPARE3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE3W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE3W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE3W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 16 - Disable interrupt on COMPARE\\[0\\]" ] # [ inline ] pub fn compare0 ( & self ) -> COMPARE0R { COMPARE0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Disable interrupt on COMPARE\\[1\\]" ] # [ inline ] pub fn compare1 ( & self ) -> COMPARE1R { COMPARE1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Disable interrupt on COMPARE\\[2\\]" ] # [ inline ] pub fn compare2 ( & self ) -> COMPARE2R { COMPARE2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Disable interrupt on COMPARE\\[3\\]" ] # [ inline ] pub fn compare3 ( & self ) -> COMPARE3R { COMPARE3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 16 - Disable interrupt on COMPARE\\[0\\]" ] # [ inline ] pub fn compare0 ( & mut self ) -> _COMPARE0W { _COMPARE0W { w : self } } # [ doc = "Bit 17 - Disable interrupt on COMPARE\\[1\\]" ] # [ inline ] pub fn compare1 ( & mut self ) -> _COMPARE1W { _COMPARE1W { w : self } } # [ doc = "Bit 18 - Disable interrupt on COMPARE\\[2\\]" ] # [ inline ] pub fn compare2 ( & mut self ) -> _COMPARE2W { _COMPARE2W { w : self } } # [ doc = "Bit 19 - Disable interrupt on COMPARE\\[3\\]" ] # [ inline ] pub fn compare3 ( & mut self ) -> _COMPARE3W { _COMPARE3W { w : self } } } } # [ doc = "Timer Mode selection." ] pub struct MODE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Timer Mode selection." ] pub mod mode { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MODE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "Timer in Counter mode." ] COUNTER , # [ doc = "Timer in Normal mode." ] TIMER } impl MODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MODER :: COUNTER => true , MODER :: TIMER => false } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MODER { match value { true => MODER :: COUNTER , false => MODER :: TIMER , } } # [ doc = "Checks if the value of the field is `COUNTER`" ] # [ inline ] pub fn is_counter ( & self ) -> bool { * self == MODER :: COUNTER } # [ doc = "Checks if the value of the field is `TIMER`" ] # [ inline ] pub fn is_timer ( & self ) -> bool { * self == MODER :: TIMER } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "Timer in Counter mode." ] COUNTER , # [ doc = "Timer in Normal mode." ] TIMER } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MODEW :: COUNTER => true , MODEW :: TIMER => false } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Timer in Counter mode." ] # [ inline ] pub fn counter ( self ) -> & 'a mut W { self . variant ( MODEW :: COUNTER ) } # [ doc = "Timer in Normal mode." ] # [ inline ] pub fn timer ( self ) -> & 'a mut W { self . variant ( MODEW :: TIMER ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Select Normal or Counter mode." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Select Normal or Counter mode." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } } } # [ doc = "Sets timer behaviour." ] pub struct BITMODE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Sets timer behaviour." ] pub mod bitmode { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: BITMODE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `BITMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BITMODER { # [ doc = "16-bit timer behaviour." ] _16BIT , # [ doc = "8-bit timer behaviour." ] _08BIT , # [ doc = "24-bit timer behaviour." ] _24BIT , # [ doc = "32-bit timer behaviour." ] _32BIT } impl BITMODER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { BITMODER :: _16BIT => 0 , BITMODER :: _08BIT => 0x01 , BITMODER :: _24BIT => 0x02 , BITMODER :: _32BIT => 0x03 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> BITMODER { match value { 0 => BITMODER :: _16BIT , 1 => BITMODER :: _08BIT , 2 => BITMODER :: _24BIT , 3 => BITMODER :: _32BIT , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `_16BIT`" ] # [ inline ] pub fn is_16bit ( & self ) -> bool { * self == BITMODER :: _16BIT } # [ doc = "Checks if the value of the field is `_08BIT`" ] # [ inline ] pub fn is_08bit ( & self ) -> bool { * self == BITMODER :: _08BIT } # [ doc = "Checks if the value of the field is `_24BIT`" ] # [ inline ] pub fn is_24bit ( & self ) -> bool { * self == BITMODER :: _24BIT } # [ doc = "Checks if the value of the field is `_32BIT`" ] # [ inline ] pub fn is_32bit ( & self ) -> bool { * self == BITMODER :: _32BIT } } # [ doc = "Values that can be written to the field `BITMODE`" ] pub enum BITMODEW { # [ doc = "16-bit timer behaviour." ] _16BIT , # [ doc = "8-bit timer behaviour." ] _08BIT , # [ doc = "24-bit timer behaviour." ] _24BIT , # [ doc = "32-bit timer behaviour." ] _32BIT } impl BITMODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { BITMODEW :: _16BIT => 0 , BITMODEW :: _08BIT => 1 , BITMODEW :: _24BIT => 2 , BITMODEW :: _32BIT => 3 } } } # [ doc = r" Proxy" ] pub struct _BITMODEW < 'a > { w : & 'a mut W , } impl < 'a > _BITMODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : BITMODEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "16-bit timer behaviour." ] # [ inline ] pub fn _16bit ( self ) -> & 'a mut W { self . variant ( BITMODEW :: _16BIT ) } # [ doc = "8-bit timer behaviour." ] # [ inline ] pub fn _08bit ( self ) -> & 'a mut W { self . variant ( BITMODEW :: _08BIT ) } # [ doc = "24-bit timer behaviour." ] # [ inline ] pub fn _24bit ( self ) -> & 'a mut W { self . variant ( BITMODEW :: _24BIT ) } # [ doc = "32-bit timer behaviour." ] # [ inline ] pub fn _32bit ( self ) -> & 'a mut W { self . variant ( BITMODEW :: _32BIT ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Sets timer behaviour ro be like the implementation of a timer with width as indicated." ] # [ inline ] pub fn bitmode ( & self ) -> BITMODER { BITMODER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Sets timer behaviour ro be like the implementation of a timer with width as indicated." ] # [ inline ] pub fn bitmode ( & mut self ) -> _BITMODEW { _BITMODEW { w : self } } } } # [ doc = "4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE." ] pub struct PRESCALER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE." ] pub mod prescaler { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PRESCALER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PRESCALERR { bits : u8 , } impl PRESCALERR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _PRESCALERW < 'a > { w : & 'a mut W , } impl < 'a > _PRESCALERW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:3 - Timer PRESCALER value. Max value is 9." ] # [ inline ] pub fn prescaler ( & self ) -> PRESCALERR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; PRESCALERR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x04 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:3 - Timer PRESCALER value. Max value is 9." ] # [ inline ] pub fn prescaler ( & mut self ) -> _PRESCALERW { _PRESCALERW { w : self } } } } # [ doc = "Capture/compare registers." ] pub struct CC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture/compare registers." ] pub mod cc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } } # [ doc = "Timer 1." ] pub struct TIMER1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TIMER1 { } impl TIMER1 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const timer0 :: RegisterBlock { 0x4000_9000 as * const _ } } impl Deref for TIMER1 { type Target = timer0 :: RegisterBlock ; fn deref ( & self ) -> & timer0 :: RegisterBlock { unsafe { & * TIMER1 :: ptr ( ) } } } # [ doc = "Timer 2." ] pub struct TIMER2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TIMER2 { } impl TIMER2 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const timer0 :: RegisterBlock { 0x4000_a000 as * const _ } } impl Deref for TIMER2 { type Target = timer0 :: RegisterBlock ; fn deref ( & self ) -> & timer0 :: RegisterBlock { unsafe { & * TIMER2 :: ptr ( ) } } } # [ doc = "Real time counter 0." ] pub struct RTC0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for RTC0 { } impl RTC0 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const rtc0 :: RegisterBlock { 0x4000_b000 as * const _ } } impl Deref for RTC0 { type Target = rtc0 :: RegisterBlock ; fn deref ( & self ) -> & rtc0 :: RegisterBlock { unsafe { & * RTC0 :: ptr ( ) } } } # [ doc = "Real time counter 0." ] pub mod rtc0 { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start RTC Counter." ] pub tasks_start : TASKS_START , # [ doc = "0x04 - Stop RTC Counter." ] pub tasks_stop : TASKS_STOP , # [ doc = "0x08 - Clear RTC Counter." ] pub tasks_clear : TASKS_CLEAR , # [ doc = "0x0c - Set COUNTER to 0xFFFFFFF0." ] pub tasks_trigovrflw : TASKS_TRIGOVRFLW , _reserved0 : [ u8 ; 240usize ] , # [ doc = "0x100 - Event on COUNTER increment." ] pub events_tick : EVENTS_TICK , # [ doc = "0x104 - Event on COUNTER overflow." ] pub events_ovrflw : EVENTS_OVRFLW , _reserved1 : [ u8 ; 56usize ] , # [ doc = "0x140 - Compare event on CC\\[n\\] match." ] pub events_compare : [ EVENTS_COMPARE ; 4 ] , _reserved2 : [ u8 ; 436usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 52usize ] , # [ doc = "0x340 - Configures event enable state for each RTC event." ] pub evten : EVTEN , # [ doc = "0x344 - Enable events. The reading of this register gives the value of EVTEN." ] pub evtenset : EVTENSET , # [ doc = "0x348 - Disable events. The reading of this register gives the value of EVTEN." ] pub evtenclr : EVTENCLR , _reserved4 : [ u8 ; 440usize ] , # [ doc = "0x504 - Current COUNTER value." ] pub counter : COUNTER , # [ doc = "0x508 - 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed." ] pub prescaler : PRESCALER , _reserved5 : [ u8 ; 52usize ] , # [ doc = "0x540 - Capture/compare registers." ] pub cc : [ CC ; 4 ] , } # [ doc = "Start RTC Counter." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start RTC Counter." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop RTC Counter." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop RTC Counter." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Clear RTC Counter." ] pub struct TASKS_CLEAR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Clear RTC Counter." ] pub mod tasks_clear { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_CLEAR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Set COUNTER to 0xFFFFFFF0." ] pub struct TASKS_TRIGOVRFLW { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Set COUNTER to 0xFFFFFFF0." ] pub mod tasks_trigovrflw { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_TRIGOVRFLW { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Event on COUNTER increment." ] pub struct EVENTS_TICK { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Event on COUNTER increment." ] pub mod events_tick { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_TICK { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Event on COUNTER overflow." ] pub struct EVENTS_OVRFLW { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Event on COUNTER overflow." ] pub mod events_ovrflw { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_OVRFLW { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Compare event on CC\\[n\\] match." ] pub struct EVENTS_COMPARE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Compare event on CC\\[n\\] match." ] pub mod events_compare { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_COMPARE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `TICK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TICKR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl TICKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TICKR :: DISABLED => false , TICKR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TICKR { match value { false => TICKR :: DISABLED , true => TICKR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TICKR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TICKR :: ENABLED } } # [ doc = "Possible values of the field `OVRFLW`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OVRFLWR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl OVRFLWR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OVRFLWR :: DISABLED => false , OVRFLWR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OVRFLWR { match value { false => OVRFLWR :: DISABLED , true => OVRFLWR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == OVRFLWR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == OVRFLWR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE0R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE0R :: DISABLED => false , COMPARE0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE0R { match value { false => COMPARE0R :: DISABLED , true => COMPARE0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE0R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE1R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE1R :: DISABLED => false , COMPARE1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE1R { match value { false => COMPARE1R :: DISABLED , true => COMPARE1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE1R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE2R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE2R :: DISABLED => false , COMPARE2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE2R { match value { false => COMPARE2R :: DISABLED , true => COMPARE2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE2R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE3R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE3R :: DISABLED => false , COMPARE3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE3R { match value { false => COMPARE3R :: DISABLED , true => COMPARE3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE3R :: ENABLED } } # [ doc = "Values that can be written to the field `TICK`" ] pub enum TICKW { # [ doc = "Enable interrupt on write." ] SET } impl TICKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TICKW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _TICKW < 'a > { w : & 'a mut W , } impl < 'a > _TICKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TICKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( TICKW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OVRFLW`" ] pub enum OVRFLWW { # [ doc = "Enable interrupt on write." ] SET } impl OVRFLWW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OVRFLWW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _OVRFLWW < 'a > { w : & 'a mut W , } impl < 'a > _OVRFLWW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OVRFLWW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( OVRFLWW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE0`" ] pub enum COMPARE0W { # [ doc = "Enable interrupt on write." ] SET } impl COMPARE0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE0W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE0W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE0W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE1`" ] pub enum COMPARE1W { # [ doc = "Enable interrupt on write." ] SET } impl COMPARE1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE1W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE1W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE1W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE2`" ] pub enum COMPARE2W { # [ doc = "Enable interrupt on write." ] SET } impl COMPARE2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE2W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE2W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE2W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE3`" ] pub enum COMPARE3W { # [ doc = "Enable interrupt on write." ] SET } impl COMPARE3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE3W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE3W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE3W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on TICK event." ] # [ inline ] pub fn tick ( & self ) -> TICKR { TICKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on OVRFLW event." ] # [ inline ] pub fn ovrflw ( & self ) -> OVRFLWR { OVRFLWR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Enable interrupt on COMPARE\\[0\\] event." ] # [ inline ] pub fn compare0 ( & self ) -> COMPARE0R { COMPARE0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Enable interrupt on COMPARE\\[1\\] event." ] # [ inline ] pub fn compare1 ( & self ) -> COMPARE1R { COMPARE1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Enable interrupt on COMPARE\\[2\\] event." ] # [ inline ] pub fn compare2 ( & self ) -> COMPARE2R { COMPARE2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Enable interrupt on COMPARE\\[3\\] event." ] # [ inline ] pub fn compare3 ( & self ) -> COMPARE3R { COMPARE3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on TICK event." ] # [ inline ] pub fn tick ( & mut self ) -> _TICKW { _TICKW { w : self } } # [ doc = "Bit 1 - Enable interrupt on OVRFLW event." ] # [ inline ] pub fn ovrflw ( & mut self ) -> _OVRFLWW { _OVRFLWW { w : self } } # [ doc = "Bit 16 - Enable interrupt on COMPARE\\[0\\] event." ] # [ inline ] pub fn compare0 ( & mut self ) -> _COMPARE0W { _COMPARE0W { w : self } } # [ doc = "Bit 17 - Enable interrupt on COMPARE\\[1\\] event." ] # [ inline ] pub fn compare1 ( & mut self ) -> _COMPARE1W { _COMPARE1W { w : self } } # [ doc = "Bit 18 - Enable interrupt on COMPARE\\[2\\] event." ] # [ inline ] pub fn compare2 ( & mut self ) -> _COMPARE2W { _COMPARE2W { w : self } } # [ doc = "Bit 19 - Enable interrupt on COMPARE\\[3\\] event." ] # [ inline ] pub fn compare3 ( & mut self ) -> _COMPARE3W { _COMPARE3W { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `TICK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TICKR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl TICKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TICKR :: DISABLED => false , TICKR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TICKR { match value { false => TICKR :: DISABLED , true => TICKR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TICKR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TICKR :: ENABLED } } # [ doc = "Possible values of the field `OVRFLW`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OVRFLWR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl OVRFLWR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OVRFLWR :: DISABLED => false , OVRFLWR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OVRFLWR { match value { false => OVRFLWR :: DISABLED , true => OVRFLWR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == OVRFLWR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == OVRFLWR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE0R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE0R :: DISABLED => false , COMPARE0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE0R { match value { false => COMPARE0R :: DISABLED , true => COMPARE0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE0R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE1R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE1R :: DISABLED => false , COMPARE1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE1R { match value { false => COMPARE1R :: DISABLED , true => COMPARE1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE1R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE2R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE2R :: DISABLED => false , COMPARE2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE2R { match value { false => COMPARE2R :: DISABLED , true => COMPARE2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE2R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE3R { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl COMPARE3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE3R :: DISABLED => false , COMPARE3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE3R { match value { false => COMPARE3R :: DISABLED , true => COMPARE3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE3R :: ENABLED } } # [ doc = "Values that can be written to the field `TICK`" ] pub enum TICKW { # [ doc = "Disable interrupt on write." ] CLEAR } impl TICKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TICKW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _TICKW < 'a > { w : & 'a mut W , } impl < 'a > _TICKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TICKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( TICKW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OVRFLW`" ] pub enum OVRFLWW { # [ doc = "Disable interrupt on write." ] CLEAR } impl OVRFLWW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OVRFLWW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _OVRFLWW < 'a > { w : & 'a mut W , } impl < 'a > _OVRFLWW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OVRFLWW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( OVRFLWW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE0`" ] pub enum COMPARE0W { # [ doc = "Disable interrupt on write." ] CLEAR } impl COMPARE0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE0W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE0W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE0W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE1`" ] pub enum COMPARE1W { # [ doc = "Disable interrupt on write." ] CLEAR } impl COMPARE1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE1W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE1W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE1W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE2`" ] pub enum COMPARE2W { # [ doc = "Disable interrupt on write." ] CLEAR } impl COMPARE2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE2W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE2W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE2W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE3`" ] pub enum COMPARE3W { # [ doc = "Disable interrupt on write." ] CLEAR } impl COMPARE3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE3W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE3W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE3W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on TICK event." ] # [ inline ] pub fn tick ( & self ) -> TICKR { TICKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on OVRFLW event." ] # [ inline ] pub fn ovrflw ( & self ) -> OVRFLWR { OVRFLWR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Disable interrupt on COMPARE\\[0\\] event." ] # [ inline ] pub fn compare0 ( & self ) -> COMPARE0R { COMPARE0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Disable interrupt on COMPARE\\[1\\] event." ] # [ inline ] pub fn compare1 ( & self ) -> COMPARE1R { COMPARE1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Disable interrupt on COMPARE\\[2\\] event." ] # [ inline ] pub fn compare2 ( & self ) -> COMPARE2R { COMPARE2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Disable interrupt on COMPARE\\[3\\] event." ] # [ inline ] pub fn compare3 ( & self ) -> COMPARE3R { COMPARE3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on TICK event." ] # [ inline ] pub fn tick ( & mut self ) -> _TICKW { _TICKW { w : self } } # [ doc = "Bit 1 - Disable interrupt on OVRFLW event." ] # [ inline ] pub fn ovrflw ( & mut self ) -> _OVRFLWW { _OVRFLWW { w : self } } # [ doc = "Bit 16 - Disable interrupt on COMPARE\\[0\\] event." ] # [ inline ] pub fn compare0 ( & mut self ) -> _COMPARE0W { _COMPARE0W { w : self } } # [ doc = "Bit 17 - Disable interrupt on COMPARE\\[1\\] event." ] # [ inline ] pub fn compare1 ( & mut self ) -> _COMPARE1W { _COMPARE1W { w : self } } # [ doc = "Bit 18 - Disable interrupt on COMPARE\\[2\\] event." ] # [ inline ] pub fn compare2 ( & mut self ) -> _COMPARE2W { _COMPARE2W { w : self } } # [ doc = "Bit 19 - Disable interrupt on COMPARE\\[3\\] event." ] # [ inline ] pub fn compare3 ( & mut self ) -> _COMPARE3W { _COMPARE3W { w : self } } } } # [ doc = "Configures event enable state for each RTC event." ] pub struct EVTEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Configures event enable state for each RTC event." ] pub mod evten { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVTEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `TICK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TICKR { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl TICKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TICKR :: DISABLED => false , TICKR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TICKR { match value { false => TICKR :: DISABLED , true => TICKR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TICKR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TICKR :: ENABLED } } # [ doc = "Possible values of the field `OVRFLW`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OVRFLWR { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl OVRFLWR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OVRFLWR :: DISABLED => false , OVRFLWR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OVRFLWR { match value { false => OVRFLWR :: DISABLED , true => OVRFLWR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == OVRFLWR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == OVRFLWR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE0R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE0R :: DISABLED => false , COMPARE0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE0R { match value { false => COMPARE0R :: DISABLED , true => COMPARE0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE0R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE1R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE1R :: DISABLED => false , COMPARE1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE1R { match value { false => COMPARE1R :: DISABLED , true => COMPARE1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE1R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE2R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE2R :: DISABLED => false , COMPARE2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE2R { match value { false => COMPARE2R :: DISABLED , true => COMPARE2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE2R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE3R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE3R :: DISABLED => false , COMPARE3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE3R { match value { false => COMPARE3R :: DISABLED , true => COMPARE3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE3R :: ENABLED } } # [ doc = "Values that can be written to the field `TICK`" ] pub enum TICKW { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl TICKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TICKW :: DISABLED => false , TICKW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _TICKW < 'a > { w : & 'a mut W , } impl < 'a > _TICKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TICKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Event disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( TICKW :: DISABLED ) } # [ doc = "Event enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( TICKW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OVRFLW`" ] pub enum OVRFLWW { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl OVRFLWW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OVRFLWW :: DISABLED => false , OVRFLWW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _OVRFLWW < 'a > { w : & 'a mut W , } impl < 'a > _OVRFLWW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OVRFLWW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Event disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( OVRFLWW :: DISABLED ) } # [ doc = "Event enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( OVRFLWW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE0`" ] pub enum COMPARE0W { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE0W :: DISABLED => false , COMPARE0W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE0W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Event disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE0W :: DISABLED ) } # [ doc = "Event enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE0W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE1`" ] pub enum COMPARE1W { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE1W :: DISABLED => false , COMPARE1W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE1W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Event disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE1W :: DISABLED ) } # [ doc = "Event enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE1W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE2`" ] pub enum COMPARE2W { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE2W :: DISABLED => false , COMPARE2W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE2W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Event disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE2W :: DISABLED ) } # [ doc = "Event enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE2W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE3`" ] pub enum COMPARE3W { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE3W :: DISABLED => false , COMPARE3W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE3W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Event disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( COMPARE3W :: DISABLED ) } # [ doc = "Event enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( COMPARE3W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - TICK event enable." ] # [ inline ] pub fn tick ( & self ) -> TICKR { TICKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - OVRFLW event enable." ] # [ inline ] pub fn ovrflw ( & self ) -> OVRFLWR { OVRFLWR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - COMPARE\\[0\\] event enable." ] # [ inline ] pub fn compare0 ( & self ) -> COMPARE0R { COMPARE0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - COMPARE\\[1\\] event enable." ] # [ inline ] pub fn compare1 ( & self ) -> COMPARE1R { COMPARE1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - COMPARE\\[2\\] event enable." ] # [ inline ] pub fn compare2 ( & self ) -> COMPARE2R { COMPARE2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - COMPARE\\[3\\] event enable." ] # [ inline ] pub fn compare3 ( & self ) -> COMPARE3R { COMPARE3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x000f_0000 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - TICK event enable." ] # [ inline ] pub fn tick ( & mut self ) -> _TICKW { _TICKW { w : self } } # [ doc = "Bit 1 - OVRFLW event enable." ] # [ inline ] pub fn ovrflw ( & mut self ) -> _OVRFLWW { _OVRFLWW { w : self } } # [ doc = "Bit 16 - COMPARE\\[0\\] event enable." ] # [ inline ] pub fn compare0 ( & mut self ) -> _COMPARE0W { _COMPARE0W { w : self } } # [ doc = "Bit 17 - COMPARE\\[1\\] event enable." ] # [ inline ] pub fn compare1 ( & mut self ) -> _COMPARE1W { _COMPARE1W { w : self } } # [ doc = "Bit 18 - COMPARE\\[2\\] event enable." ] # [ inline ] pub fn compare2 ( & mut self ) -> _COMPARE2W { _COMPARE2W { w : self } } # [ doc = "Bit 19 - COMPARE\\[3\\] event enable." ] # [ inline ] pub fn compare3 ( & mut self ) -> _COMPARE3W { _COMPARE3W { w : self } } } } # [ doc = "Enable events. The reading of this register gives the value of EVTEN." ] pub struct EVTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable events. The reading of this register gives the value of EVTEN." ] pub mod evtenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `TICK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TICKR { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl TICKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TICKR :: DISABLED => false , TICKR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TICKR { match value { false => TICKR :: DISABLED , true => TICKR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TICKR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TICKR :: ENABLED } } # [ doc = "Possible values of the field `OVRFLW`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OVRFLWR { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl OVRFLWR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OVRFLWR :: DISABLED => false , OVRFLWR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OVRFLWR { match value { false => OVRFLWR :: DISABLED , true => OVRFLWR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == OVRFLWR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == OVRFLWR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE0R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE0R :: DISABLED => false , COMPARE0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE0R { match value { false => COMPARE0R :: DISABLED , true => COMPARE0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE0R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE1R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE1R :: DISABLED => false , COMPARE1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE1R { match value { false => COMPARE1R :: DISABLED , true => COMPARE1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE1R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE2R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE2R :: DISABLED => false , COMPARE2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE2R { match value { false => COMPARE2R :: DISABLED , true => COMPARE2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE2R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE3R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE3R :: DISABLED => false , COMPARE3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE3R { match value { false => COMPARE3R :: DISABLED , true => COMPARE3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE3R :: ENABLED } } # [ doc = "Values that can be written to the field `TICK`" ] pub enum TICKW { # [ doc = "Enable event on write." ] SET } impl TICKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TICKW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _TICKW < 'a > { w : & 'a mut W , } impl < 'a > _TICKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TICKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable event on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( TICKW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OVRFLW`" ] pub enum OVRFLWW { # [ doc = "Enable event on write." ] SET } impl OVRFLWW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OVRFLWW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _OVRFLWW < 'a > { w : & 'a mut W , } impl < 'a > _OVRFLWW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OVRFLWW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable event on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( OVRFLWW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE0`" ] pub enum COMPARE0W { # [ doc = "Enable event on write." ] SET } impl COMPARE0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE0W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE0W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable event on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE0W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE1`" ] pub enum COMPARE1W { # [ doc = "Enable event on write." ] SET } impl COMPARE1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE1W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE1W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable event on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE1W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE2`" ] pub enum COMPARE2W { # [ doc = "Enable event on write." ] SET } impl COMPARE2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE2W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE2W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable event on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE2W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE3`" ] pub enum COMPARE3W { # [ doc = "Enable event on write." ] SET } impl COMPARE3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE3W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE3W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable event on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( COMPARE3W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable TICK event." ] # [ inline ] pub fn tick ( & self ) -> TICKR { TICKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable OVRFLW event." ] # [ inline ] pub fn ovrflw ( & self ) -> OVRFLWR { OVRFLWR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Enable COMPARE\\[0\\] event." ] # [ inline ] pub fn compare0 ( & self ) -> COMPARE0R { COMPARE0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Enable COMPARE\\[1\\] event." ] # [ inline ] pub fn compare1 ( & self ) -> COMPARE1R { COMPARE1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Enable COMPARE\\[2\\] event." ] # [ inline ] pub fn compare2 ( & self ) -> COMPARE2R { COMPARE2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Enable COMPARE\\[3\\] event." ] # [ inline ] pub fn compare3 ( & self ) -> COMPARE3R { COMPARE3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable TICK event." ] # [ inline ] pub fn tick ( & mut self ) -> _TICKW { _TICKW { w : self } } # [ doc = "Bit 1 - Enable OVRFLW event." ] # [ inline ] pub fn ovrflw ( & mut self ) -> _OVRFLWW { _OVRFLWW { w : self } } # [ doc = "Bit 16 - Enable COMPARE\\[0\\] event." ] # [ inline ] pub fn compare0 ( & mut self ) -> _COMPARE0W { _COMPARE0W { w : self } } # [ doc = "Bit 17 - Enable COMPARE\\[1\\] event." ] # [ inline ] pub fn compare1 ( & mut self ) -> _COMPARE1W { _COMPARE1W { w : self } } # [ doc = "Bit 18 - Enable COMPARE\\[2\\] event." ] # [ inline ] pub fn compare2 ( & mut self ) -> _COMPARE2W { _COMPARE2W { w : self } } # [ doc = "Bit 19 - Enable COMPARE\\[3\\] event." ] # [ inline ] pub fn compare3 ( & mut self ) -> _COMPARE3W { _COMPARE3W { w : self } } } } # [ doc = "Disable events. The reading of this register gives the value of EVTEN." ] pub struct EVTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Disable events. The reading of this register gives the value of EVTEN." ] pub mod evtenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `TICK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TICKR { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl TICKR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TICKR :: DISABLED => false , TICKR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TICKR { match value { false => TICKR :: DISABLED , true => TICKR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TICKR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TICKR :: ENABLED } } # [ doc = "Possible values of the field `OVRFLW`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OVRFLWR { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl OVRFLWR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { OVRFLWR :: DISABLED => false , OVRFLWR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> OVRFLWR { match value { false => OVRFLWR :: DISABLED , true => OVRFLWR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == OVRFLWR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == OVRFLWR :: ENABLED } } # [ doc = "Possible values of the field `COMPARE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE0R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE0R :: DISABLED => false , COMPARE0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE0R { match value { false => COMPARE0R :: DISABLED , true => COMPARE0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE0R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE1R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE1R :: DISABLED => false , COMPARE1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE1R { match value { false => COMPARE1R :: DISABLED , true => COMPARE1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE1R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE2R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE2R :: DISABLED => false , COMPARE2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE2R { match value { false => COMPARE2R :: DISABLED , true => COMPARE2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE2R :: ENABLED } } # [ doc = "Possible values of the field `COMPARE3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COMPARE3R { # [ doc = "Event disabled." ] DISABLED , # [ doc = "Event enabled." ] ENABLED } impl COMPARE3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { COMPARE3R :: DISABLED => false , COMPARE3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> COMPARE3R { match value { false => COMPARE3R :: DISABLED , true => COMPARE3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == COMPARE3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == COMPARE3R :: ENABLED } } # [ doc = "Values that can be written to the field `TICK`" ] pub enum TICKW { # [ doc = "Disable event on write." ] CLEAR } impl TICKW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TICKW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _TICKW < 'a > { w : & 'a mut W , } impl < 'a > _TICKW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TICKW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable event on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( TICKW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `OVRFLW`" ] pub enum OVRFLWW { # [ doc = "Disable event on write." ] CLEAR } impl OVRFLWW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { OVRFLWW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _OVRFLWW < 'a > { w : & 'a mut W , } impl < 'a > _OVRFLWW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : OVRFLWW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable event on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( OVRFLWW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE0`" ] pub enum COMPARE0W { # [ doc = "Disable event on write." ] CLEAR } impl COMPARE0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE0W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE0W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable event on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE0W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE1`" ] pub enum COMPARE1W { # [ doc = "Disable event on write." ] CLEAR } impl COMPARE1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE1W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE1W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable event on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE1W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE2`" ] pub enum COMPARE2W { # [ doc = "Disable event on write." ] CLEAR } impl COMPARE2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE2W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE2W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable event on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE2W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `COMPARE3`" ] pub enum COMPARE3W { # [ doc = "Disable event on write." ] CLEAR } impl COMPARE3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { COMPARE3W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _COMPARE3W < 'a > { w : & 'a mut W , } impl < 'a > _COMPARE3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : COMPARE3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable event on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( COMPARE3W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable TICK event." ] # [ inline ] pub fn tick ( & self ) -> TICKR { TICKR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable OVRFLW event." ] # [ inline ] pub fn ovrflw ( & self ) -> OVRFLWR { OVRFLWR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Disable COMPARE\\[0\\] event." ] # [ inline ] pub fn compare0 ( & self ) -> COMPARE0R { COMPARE0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Disable COMPARE\\[1\\] event." ] # [ inline ] pub fn compare1 ( & self ) -> COMPARE1R { COMPARE1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Disable COMPARE\\[2\\] event." ] # [ inline ] pub fn compare2 ( & self ) -> COMPARE2R { COMPARE2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Disable COMPARE\\[3\\] event." ] # [ inline ] pub fn compare3 ( & self ) -> COMPARE3R { COMPARE3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable TICK event." ] # [ inline ] pub fn tick ( & mut self ) -> _TICKW { _TICKW { w : self } } # [ doc = "Bit 1 - Disable OVRFLW event." ] # [ inline ] pub fn ovrflw ( & mut self ) -> _OVRFLWW { _OVRFLWW { w : self } } # [ doc = "Bit 16 - Disable COMPARE\\[0\\] event." ] # [ inline ] pub fn compare0 ( & mut self ) -> _COMPARE0W { _COMPARE0W { w : self } } # [ doc = "Bit 17 - Disable COMPARE\\[1\\] event." ] # [ inline ] pub fn compare1 ( & mut self ) -> _COMPARE1W { _COMPARE1W { w : self } } # [ doc = "Bit 18 - Disable COMPARE\\[2\\] event." ] # [ inline ] pub fn compare2 ( & mut self ) -> _COMPARE2W { _COMPARE2W { w : self } } # [ doc = "Bit 19 - Disable COMPARE\\[3\\] event." ] # [ inline ] pub fn compare3 ( & mut self ) -> _COMPARE3W { _COMPARE3W { w : self } } } } # [ doc = "Current COUNTER value." ] pub struct COUNTER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Current COUNTER value." ] pub mod counter { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: COUNTER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct COUNTERR { bits : u32 , } impl COUNTERR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _COUNTERW < 'a > { w : & 'a mut W , } impl < 'a > _COUNTERW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:23 - Counter value." ] # [ inline ] pub fn counter ( & self ) -> COUNTERR { let bits = { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; COUNTERR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:23 - Counter value." ] # [ inline ] pub fn counter ( & mut self ) -> _COUNTERW { _COUNTERW { w : self } } } } # [ doc = "12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed." ] pub struct PRESCALER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed." ] pub mod prescaler { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PRESCALER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct PRESCALERR { bits : u16 , } impl PRESCALERR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _PRESCALERW < 'a > { w : & 'a mut W , } impl < 'a > _PRESCALERW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0x0fff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:11 - RTC PRESCALER value." ] # [ inline ] pub fn prescaler ( & self ) -> PRESCALERR { let bits = { const MASK : u16 = 0x0fff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; PRESCALERR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:11 - RTC PRESCALER value." ] # [ inline ] pub fn prescaler ( & mut self ) -> _PRESCALERW { _PRESCALERW { w : self } } } } # [ doc = "Capture/compare registers." ] pub struct CC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Capture/compare registers." ] pub mod cc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct COMPARER { bits : u32 , } impl COMPARER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } # [ doc = r" Proxy" ] pub struct _COMPAREW < 'a > { w : & 'a mut W , } impl < 'a > _COMPAREW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:23 - Compare value." ] # [ inline ] pub fn compare ( & self ) -> COMPARER { let bits = { const MASK : u32 = 0x00ff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; COMPARER { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:23 - Compare value." ] # [ inline ] pub fn compare ( & mut self ) -> _COMPAREW { _COMPAREW { w : self } } } } } # [ doc = "Temperature Sensor." ] pub struct TEMP { _marker : PhantomData < * const ( ) > } unsafe impl Send for TEMP { } impl TEMP { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const temp :: RegisterBlock { 0x4000_c000 as * const _ } } impl Deref for TEMP { type Target = temp :: RegisterBlock ; fn deref ( & self ) -> & temp :: RegisterBlock { unsafe { & * TEMP :: ptr ( ) } } } # [ doc = "Temperature Sensor." ] pub mod temp { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start temperature measurement." ] pub tasks_start : TASKS_START , # [ doc = "0x04 - Stop temperature measurement." ] pub tasks_stop : TASKS_STOP , _reserved0 : [ u8 ; 248usize ] , # [ doc = "0x100 - Temperature measurement complete, data ready event." ] pub events_datardy : EVENTS_DATARDY , _reserved1 : [ u8 ; 512usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved2 : [ u8 ; 508usize ] , # [ doc = "0x508 - Die temperature in degC, 2's complement format, 0.25 degC pecision." ] pub temp : TEMP , } # [ doc = "Start temperature measurement." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start temperature measurement." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop temperature measurement." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop temperature measurement." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Temperature measurement complete, data ready event." ] pub struct EVENTS_DATARDY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Temperature measurement complete, data ready event." ] pub mod events_datardy { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_DATARDY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `DATARDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DATARDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DATARDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DATARDYR :: DISABLED => false , DATARDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DATARDYR { match value { false => DATARDYR :: DISABLED , true => DATARDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DATARDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DATARDYR :: ENABLED } } # [ doc = "Values that can be written to the field `DATARDY`" ] pub enum DATARDYW { # [ doc = "Enable interrupt on write." ] SET } impl DATARDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DATARDYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _DATARDYW < 'a > { w : & 'a mut W , } impl < 'a > _DATARDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DATARDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( DATARDYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on DATARDY event." ] # [ inline ] pub fn datardy ( & self ) -> DATARDYR { DATARDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on DATARDY event." ] # [ inline ] pub fn datardy ( & mut self ) -> _DATARDYW { _DATARDYW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `DATARDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DATARDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DATARDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DATARDYR :: DISABLED => false , DATARDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DATARDYR { match value { false => DATARDYR :: DISABLED , true => DATARDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DATARDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DATARDYR :: ENABLED } } # [ doc = "Values that can be written to the field `DATARDY`" ] pub enum DATARDYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl DATARDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DATARDYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _DATARDYW < 'a > { w : & 'a mut W , } impl < 'a > _DATARDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DATARDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( DATARDYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on DATARDY event." ] # [ inline ] pub fn datardy ( & self ) -> DATARDYR { DATARDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on DATARDY event." ] # [ inline ] pub fn datardy ( & mut self ) -> _DATARDYW { _DATARDYW { w : self } } } } # [ doc = "Die temperature in degC, 2's complement format, 0.25 degC pecision." ] pub struct TEMP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Die temperature in degC, 2's complement format, 0.25 degC pecision." ] pub mod temp { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: TEMP { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } } } # [ doc = "Random Number Generator." ] pub struct RNG { _marker : PhantomData < * const ( ) > } unsafe impl Send for RNG { } impl RNG { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const rng :: RegisterBlock { 0x4000_d000 as * const _ } } impl Deref for RNG { type Target = rng :: RegisterBlock ; fn deref ( & self ) -> & rng :: RegisterBlock { unsafe { & * RNG :: ptr ( ) } } } # [ doc = "Random Number Generator." ] pub mod rng { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start the random number generator." ] pub tasks_start : TASKS_START , # [ doc = "0x04 - Stop the random number generator." ] pub tasks_stop : TASKS_STOP , _reserved0 : [ u8 ; 248usize ] , # [ doc = "0x100 - New random number generated and written to VALUE register." ] pub events_valrdy : EVENTS_VALRDY , _reserved1 : [ u8 ; 252usize ] , # [ doc = "0x200 - Shortcut for the RNG." ] pub shorts : SHORTS , _reserved2 : [ u8 ; 256usize ] , # [ doc = "0x304 - Interrupt enable set register" ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register" ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 504usize ] , # [ doc = "0x504 - Configuration register." ] pub config : CONFIG , # [ doc = "0x508 - RNG random number." ] pub value : VALUE , } # [ doc = "Start the random number generator." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start the random number generator." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop the random number generator." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop the random number generator." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "New random number generated and written to VALUE register." ] pub struct EVENTS_VALRDY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "New random number generated and written to VALUE register." ] pub mod events_valrdy { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_VALRDY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Shortcut for the RNG." ] pub struct SHORTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Shortcut for the RNG." ] pub mod shorts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SHORTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `VALRDY_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VALRDY_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl VALRDY_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { VALRDY_STOPR :: DISABLED => false , VALRDY_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> VALRDY_STOPR { match value { false => VALRDY_STOPR :: DISABLED , true => VALRDY_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == VALRDY_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == VALRDY_STOPR :: ENABLED } } # [ doc = "Values that can be written to the field `VALRDY_STOP`" ] pub enum VALRDY_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl VALRDY_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { VALRDY_STOPW :: DISABLED => false , VALRDY_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _VALRDY_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _VALRDY_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : VALRDY_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( VALRDY_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( VALRDY_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Short-cut between VALRDY event and STOP task." ] # [ inline ] pub fn valrdy_stop ( & self ) -> VALRDY_STOPR { VALRDY_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Short-cut between VALRDY event and STOP task." ] # [ inline ] pub fn valrdy_stop ( & mut self ) -> _VALRDY_STOPW { _VALRDY_STOPW { w : self } } } } # [ doc = "Interrupt enable set register" ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register" ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `VALRDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VALRDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl VALRDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { VALRDYR :: DISABLED => false , VALRDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> VALRDYR { match value { false => VALRDYR :: DISABLED , true => VALRDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == VALRDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == VALRDYR :: ENABLED } } # [ doc = "Values that can be written to the field `VALRDY`" ] pub enum VALRDYW { # [ doc = "Enable interrupt on write." ] SET } impl VALRDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { VALRDYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _VALRDYW < 'a > { w : & 'a mut W , } impl < 'a > _VALRDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : VALRDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( VALRDYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on VALRDY event." ] # [ inline ] pub fn valrdy ( & self ) -> VALRDYR { VALRDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on VALRDY event." ] # [ inline ] pub fn valrdy ( & mut self ) -> _VALRDYW { _VALRDYW { w : self } } } } # [ doc = "Interrupt enable clear register" ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register" ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `VALRDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VALRDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl VALRDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { VALRDYR :: DISABLED => false , VALRDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> VALRDYR { match value { false => VALRDYR :: DISABLED , true => VALRDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == VALRDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == VALRDYR :: ENABLED } } # [ doc = "Values that can be written to the field `VALRDY`" ] pub enum VALRDYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl VALRDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { VALRDYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _VALRDYW < 'a > { w : & 'a mut W , } impl < 'a > _VALRDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : VALRDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( VALRDYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on VALRDY event." ] # [ inline ] pub fn valrdy ( & self ) -> VALRDYR { VALRDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on VALRDY event." ] # [ inline ] pub fn valrdy ( & mut self ) -> _VALRDYW { _VALRDYW { w : self } } } } # [ doc = "Configuration register." ] pub struct CONFIG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Configuration register." ] pub mod config { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONFIG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `DERCEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DERCENR { # [ doc = "Digital error correction disabled." ] DISABLED , # [ doc = "Digital error correction enabled." ] ENABLED } impl DERCENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DERCENR :: DISABLED => false , DERCENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DERCENR { match value { false => DERCENR :: DISABLED , true => DERCENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DERCENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DERCENR :: ENABLED } } # [ doc = "Values that can be written to the field `DERCEN`" ] pub enum DERCENW { # [ doc = "Digital error correction disabled." ] DISABLED , # [ doc = "Digital error correction enabled." ] ENABLED } impl DERCENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DERCENW :: DISABLED => false , DERCENW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _DERCENW < 'a > { w : & 'a mut W , } impl < 'a > _DERCENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DERCENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Digital error correction disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( DERCENW :: DISABLED ) } # [ doc = "Digital error correction enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( DERCENW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Digital error correction enable." ] # [ inline ] pub fn dercen ( & self ) -> DERCENR { DERCENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Digital error correction enable." ] # [ inline ] pub fn dercen ( & mut self ) -> _DERCENW { _DERCENW { w : self } } } } # [ doc = "RNG random number." ] pub struct VALUE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "RNG random number." ] pub mod value { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: VALUE { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct VALUER { bits : u8 , } impl VALUER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Generated random number." ] # [ inline ] pub fn value ( & self ) -> VALUER { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; VALUER { bits } } } } } # [ doc = "AES ECB Mode Encryption." ] pub struct ECB { _marker : PhantomData < * const ( ) > } unsafe impl Send for ECB { } impl ECB { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ecb :: RegisterBlock { 0x4000_e000 as * const _ } } impl Deref for ECB { type Target = ecb :: RegisterBlock ; fn deref ( & self ) -> & ecb :: RegisterBlock { unsafe { & * ECB :: ptr ( ) } } } # [ doc = "AES ECB Mode Encryption." ] pub mod ecb { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start ECB block encrypt. If a crypto operation is running, this will not initiate a new encryption and the ERRORECB event will be triggered." ] pub tasks_startecb : TASKS_STARTECB , # [ doc = "0x04 - Stop current ECB encryption. If a crypto operation is running, this will will trigger the ERRORECB event." ] pub tasks_stopecb : TASKS_STOPECB , _reserved0 : [ u8 ; 248usize ] , # [ doc = "0x100 - ECB block encrypt complete." ] pub events_endecb : EVENTS_ENDECB , # [ doc = "0x104 - ECB block encrypt aborted due to a STOPECB task or due to an error." ] pub events_errorecb : EVENTS_ERRORECB , _reserved1 : [ u8 ; 508usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved2 : [ u8 ; 504usize ] , # [ doc = "0x504 - ECB block encrypt memory pointer." ] pub ecbdataptr : ECBDATAPTR , } # [ doc = "Start ECB block encrypt. If a crypto operation is running, this will not initiate a new encryption and the ERRORECB event will be triggered." ] pub struct TASKS_STARTECB { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start ECB block encrypt. If a crypto operation is running, this will not initiate a new encryption and the ERRORECB event will be triggered." ] pub mod tasks_startecb { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STARTECB { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop current ECB encryption. If a crypto operation is running, this will will trigger the ERRORECB event." ] pub struct TASKS_STOPECB { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop current ECB encryption. If a crypto operation is running, this will will trigger the ERRORECB event." ] pub mod tasks_stopecb { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOPECB { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "ECB block encrypt complete." ] pub struct EVENTS_ENDECB { register : :: vcell :: VolatileCell < u32 > } # [ doc = "ECB block encrypt complete." ] pub mod events_endecb { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ENDECB { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "ECB block encrypt aborted due to a STOPECB task or due to an error." ] pub struct EVENTS_ERRORECB { register : :: vcell :: VolatileCell < u32 > } # [ doc = "ECB block encrypt aborted due to a STOPECB task or due to an error." ] pub mod events_errorecb { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ERRORECB { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENDECB`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDECBR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDECBR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDECBR :: DISABLED => false , ENDECBR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDECBR { match value { false => ENDECBR :: DISABLED , true => ENDECBR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDECBR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDECBR :: ENABLED } } # [ doc = "Possible values of the field `ERRORECB`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERRORECBR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ERRORECBR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERRORECBR :: DISABLED => false , ERRORECBR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERRORECBR { match value { false => ERRORECBR :: DISABLED , true => ERRORECBR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ERRORECBR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ERRORECBR :: ENABLED } } # [ doc = "Values that can be written to the field `ENDECB`" ] pub enum ENDECBW { # [ doc = "Enable interrupt on write." ] SET } impl ENDECBW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDECBW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ENDECBW < 'a > { w : & 'a mut W , } impl < 'a > _ENDECBW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDECBW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ENDECBW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ERRORECB`" ] pub enum ERRORECBW { # [ doc = "Enable interrupt on write." ] SET } impl ERRORECBW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERRORECBW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ERRORECBW < 'a > { w : & 'a mut W , } impl < 'a > _ERRORECBW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERRORECBW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ERRORECBW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on ENDECB event." ] # [ inline ] pub fn endecb ( & self ) -> ENDECBR { ENDECBR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on ERRORECB event." ] # [ inline ] pub fn errorecb ( & self ) -> ERRORECBR { ERRORECBR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on ENDECB event." ] # [ inline ] pub fn endecb ( & mut self ) -> _ENDECBW { _ENDECBW { w : self } } # [ doc = "Bit 1 - Enable interrupt on ERRORECB event." ] # [ inline ] pub fn errorecb ( & mut self ) -> _ERRORECBW { _ERRORECBW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENDECB`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDECBR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDECBR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDECBR :: DISABLED => false , ENDECBR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDECBR { match value { false => ENDECBR :: DISABLED , true => ENDECBR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDECBR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDECBR :: ENABLED } } # [ doc = "Possible values of the field `ERRORECB`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERRORECBR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ERRORECBR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERRORECBR :: DISABLED => false , ERRORECBR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERRORECBR { match value { false => ERRORECBR :: DISABLED , true => ERRORECBR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ERRORECBR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ERRORECBR :: ENABLED } } # [ doc = "Values that can be written to the field `ENDECB`" ] pub enum ENDECBW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ENDECBW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDECBW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ENDECBW < 'a > { w : & 'a mut W , } impl < 'a > _ENDECBW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDECBW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ENDECBW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ERRORECB`" ] pub enum ERRORECBW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ERRORECBW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERRORECBW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ERRORECBW < 'a > { w : & 'a mut W , } impl < 'a > _ERRORECBW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERRORECBW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ERRORECBW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on ENDECB event." ] # [ inline ] pub fn endecb ( & self ) -> ENDECBR { ENDECBR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on ERRORECB event." ] # [ inline ] pub fn errorecb ( & self ) -> ERRORECBR { ERRORECBR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on ENDECB event." ] # [ inline ] pub fn endecb ( & mut self ) -> _ENDECBW { _ENDECBW { w : self } } # [ doc = "Bit 1 - Disable interrupt on ERRORECB event." ] # [ inline ] pub fn errorecb ( & mut self ) -> _ERRORECBW { _ERRORECBW { w : self } } } } # [ doc = "ECB block encrypt memory pointer." ] pub struct ECBDATAPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "ECB block encrypt memory pointer." ] pub mod ecbdataptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ECBDATAPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } } # [ doc = "Accelerated Address Resolver." ] pub struct AAR { _marker : PhantomData < * const ( ) > } unsafe impl Send for AAR { } impl AAR { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const aar :: RegisterBlock { 0x4000_f000 as * const _ } } impl Deref for AAR { type Target = aar :: RegisterBlock ; fn deref ( & self ) -> & aar :: RegisterBlock { unsafe { & * AAR :: ptr ( ) } } } # [ doc = "Accelerated Address Resolver." ] pub mod aar { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start resolving addresses based on IRKs specified in the IRK data structure." ] pub tasks_start : TASKS_START , _reserved0 : [ u8 ; 4usize ] , # [ doc = "0x08 - Stop resolving addresses." ] pub tasks_stop : TASKS_STOP , _reserved1 : [ u8 ; 244usize ] , # [ doc = "0x100 - Address resolution procedure completed." ] pub events_end : EVENTS_END , # [ doc = "0x104 - Address resolved." ] pub events_resolved : EVENTS_RESOLVED , # [ doc = "0x108 - Address not resolved." ] pub events_notresolved : EVENTS_NOTRESOLVED , _reserved2 : [ u8 ; 504usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 244usize ] , # [ doc = "0x400 - Resolution status." ] pub status : STATUS , _reserved4 : [ u8 ; 252usize ] , # [ doc = "0x500 - Enable AAR." ] pub enable : ENABLE , # [ doc = "0x504 - Number of Identity root Keys in the IRK data structure." ] pub nirk : NIRK , # [ doc = "0x508 - Pointer to the IRK data structure." ] pub irkptr : IRKPTR , _reserved5 : [ u8 ; 4usize ] , # [ doc = "0x510 - Pointer to the resolvable address (6 bytes)." ] pub addrptr : ADDRPTR , # [ doc = "0x514 - Pointer to \"scratch\" data area used for temporary storage during resolution. A minimum of 3 bytes must be reserved." ] pub scratchptr : SCRATCHPTR , } # [ doc = "Start resolving addresses based on IRKs specified in the IRK data structure." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start resolving addresses based on IRKs specified in the IRK data structure." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop resolving addresses." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop resolving addresses." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Address resolution procedure completed." ] pub struct EVENTS_END { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Address resolution procedure completed." ] pub mod events_end { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_END { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Address resolved." ] pub struct EVENTS_RESOLVED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Address resolved." ] pub mod events_resolved { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_RESOLVED { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Address not resolved." ] pub struct EVENTS_NOTRESOLVED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Address not resolved." ] pub mod events_notresolved { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_NOTRESOLVED { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `END`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDR :: DISABLED => false , ENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDR { match value { false => ENDR :: DISABLED , true => ENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDR :: ENABLED } } # [ doc = "Possible values of the field `RESOLVED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RESOLVEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RESOLVEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RESOLVEDR :: DISABLED => false , RESOLVEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RESOLVEDR { match value { false => RESOLVEDR :: DISABLED , true => RESOLVEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RESOLVEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RESOLVEDR :: ENABLED } } # [ doc = "Possible values of the field `NOTRESOLVED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NOTRESOLVEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl NOTRESOLVEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { NOTRESOLVEDR :: DISABLED => false , NOTRESOLVEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> NOTRESOLVEDR { match value { false => NOTRESOLVEDR :: DISABLED , true => NOTRESOLVEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == NOTRESOLVEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == NOTRESOLVEDR :: ENABLED } } # [ doc = "Values that can be written to the field `END`" ] pub enum ENDW { # [ doc = "Enable interrupt on write." ] SET } impl ENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ENDW < 'a > { w : & 'a mut W , } impl < 'a > _ENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ENDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RESOLVED`" ] pub enum RESOLVEDW { # [ doc = "Enable interrupt on write." ] SET } impl RESOLVEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RESOLVEDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _RESOLVEDW < 'a > { w : & 'a mut W , } impl < 'a > _RESOLVEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RESOLVEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( RESOLVEDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `NOTRESOLVED`" ] pub enum NOTRESOLVEDW { # [ doc = "Enable interrupt on write." ] SET } impl NOTRESOLVEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { NOTRESOLVEDW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _NOTRESOLVEDW < 'a > { w : & 'a mut W , } impl < 'a > _NOTRESOLVEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : NOTRESOLVEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( NOTRESOLVEDW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on END event." ] # [ inline ] pub fn end ( & self ) -> ENDR { ENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on RESOLVED event." ] # [ inline ] pub fn resolved ( & self ) -> RESOLVEDR { RESOLVEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable interrupt on NOTRESOLVED event." ] # [ inline ] pub fn notresolved ( & self ) -> NOTRESOLVEDR { NOTRESOLVEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on END event." ] # [ inline ] pub fn end ( & mut self ) -> _ENDW { _ENDW { w : self } } # [ doc = "Bit 1 - Enable interrupt on RESOLVED event." ] # [ inline ] pub fn resolved ( & mut self ) -> _RESOLVEDW { _RESOLVEDW { w : self } } # [ doc = "Bit 2 - Enable interrupt on NOTRESOLVED event." ] # [ inline ] pub fn notresolved ( & mut self ) -> _NOTRESOLVEDW { _NOTRESOLVEDW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `END`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDR :: DISABLED => false , ENDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDR { match value { false => ENDR :: DISABLED , true => ENDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDR :: ENABLED } } # [ doc = "Possible values of the field `RESOLVED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RESOLVEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl RESOLVEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RESOLVEDR :: DISABLED => false , RESOLVEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RESOLVEDR { match value { false => RESOLVEDR :: DISABLED , true => RESOLVEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RESOLVEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RESOLVEDR :: ENABLED } } # [ doc = "Possible values of the field `NOTRESOLVED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NOTRESOLVEDR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl NOTRESOLVEDR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { NOTRESOLVEDR :: DISABLED => false , NOTRESOLVEDR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> NOTRESOLVEDR { match value { false => NOTRESOLVEDR :: DISABLED , true => NOTRESOLVEDR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == NOTRESOLVEDR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == NOTRESOLVEDR :: ENABLED } } # [ doc = "Values that can be written to the field `END`" ] pub enum ENDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ENDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ENDW < 'a > { w : & 'a mut W , } impl < 'a > _ENDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ENDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RESOLVED`" ] pub enum RESOLVEDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl RESOLVEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RESOLVEDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _RESOLVEDW < 'a > { w : & 'a mut W , } impl < 'a > _RESOLVEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RESOLVEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( RESOLVEDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `NOTRESOLVED`" ] pub enum NOTRESOLVEDW { # [ doc = "Disable interrupt on write." ] CLEAR } impl NOTRESOLVEDW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { NOTRESOLVEDW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _NOTRESOLVEDW < 'a > { w : & 'a mut W , } impl < 'a > _NOTRESOLVEDW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : NOTRESOLVEDW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( NOTRESOLVEDW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on ENDKSGEN event." ] # [ inline ] pub fn end ( & self ) -> ENDR { ENDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on RESOLVED event." ] # [ inline ] pub fn resolved ( & self ) -> RESOLVEDR { RESOLVEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Disable interrupt on NOTRESOLVED event." ] # [ inline ] pub fn notresolved ( & self ) -> NOTRESOLVEDR { NOTRESOLVEDR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on ENDKSGEN event." ] # [ inline ] pub fn end ( & mut self ) -> _ENDW { _ENDW { w : self } } # [ doc = "Bit 1 - Disable interrupt on RESOLVED event." ] # [ inline ] pub fn resolved ( & mut self ) -> _RESOLVEDW { _RESOLVEDW { w : self } } # [ doc = "Bit 2 - Disable interrupt on NOTRESOLVED event." ] # [ inline ] pub fn notresolved ( & mut self ) -> _NOTRESOLVEDW { _NOTRESOLVEDW { w : self } } } } # [ doc = "Resolution status." ] pub struct STATUS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Resolution status." ] pub mod status { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: STATUS { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct STATUSR { bits : u8 , } impl STATUSR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:3 - The IRK used last time an address was resolved." ] # [ inline ] pub fn status ( & self ) -> STATUSR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; STATUSR { bits } } } } # [ doc = "Enable AAR." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable AAR." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "Disabled AAR." ] DISABLED , # [ doc = "Enable AAR." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ENABLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ENABLER :: DISABLED => 0 , ENABLER :: ENABLED => 0x03 , ENABLER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ENABLER { match value { 0 => ENABLER :: DISABLED , 3 => ENABLER :: ENABLED , i => ENABLER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "Disabled AAR." ] DISABLED , # [ doc = "Enable AAR." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ENABLEW :: DISABLED => 0 , ENABLEW :: ENABLED => 3 } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled AAR." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "Enable AAR." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Enable AAR." ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Enable AAR." ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "Number of Identity root Keys in the IRK data structure." ] pub struct NIRK { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Number of Identity root Keys in the IRK data structure." ] pub mod nirk { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: NIRK { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct NIRKR { bits : u8 , } impl NIRKR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _NIRKW < 'a > { w : & 'a mut W , } impl < 'a > _NIRKW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:4 - Number of Identity root Keys in the IRK data structure." ] # [ inline ] pub fn nirk ( & self ) -> NIRKR { let bits = { const MASK : u8 = 0x1f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; NIRKR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:4 - Number of Identity root Keys in the IRK data structure." ] # [ inline ] pub fn nirk ( & mut self ) -> _NIRKW { _NIRKW { w : self } } } } # [ doc = "Pointer to the IRK data structure." ] pub struct IRKPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pointer to the IRK data structure." ] pub mod irkptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IRKPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pointer to the resolvable address (6 bytes)." ] pub struct ADDRPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pointer to the resolvable address (6 bytes)." ] pub mod addrptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ADDRPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pointer to \"scratch\" data area used for temporary storage during resolution. A minimum of 3 bytes must be reserved." ] pub struct SCRATCHPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pointer to \"scratch\" data area used for temporary storage during resolution. A minimum of 3 bytes must be reserved." ] pub mod scratchptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SCRATCHPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } } # [ doc = "AES CCM Mode Encryption." ] pub struct CCM { _marker : PhantomData < * const ( ) > } unsafe impl Send for CCM { } impl CCM { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ccm :: RegisterBlock { 0x4000_f000 as * const _ } } impl Deref for CCM { type Target = ccm :: RegisterBlock ; fn deref ( & self ) -> & ccm :: RegisterBlock { unsafe { & * CCM :: ptr ( ) } } } # [ doc = "AES CCM Mode Encryption." ] pub mod ccm { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start generation of key-stream. This operation will stop by itself when completed." ] pub tasks_ksgen : TASKS_KSGEN , # [ doc = "0x04 - Start encrypt/decrypt. This operation will stop by itself when completed." ] pub tasks_crypt : TASKS_CRYPT , # [ doc = "0x08 - Stop encrypt/decrypt." ] pub tasks_stop : TASKS_STOP , _reserved0 : [ u8 ; 244usize ] , # [ doc = "0x100 - Keystream generation completed." ] pub events_endksgen : EVENTS_ENDKSGEN , # [ doc = "0x104 - Encrypt/decrypt completed." ] pub events_endcrypt : EVENTS_ENDCRYPT , # [ doc = "0x108 - Error happened." ] pub events_error : EVENTS_ERROR , _reserved1 : [ u8 ; 244usize ] , # [ doc = "0x200 - Shortcut for the CCM." ] pub shorts : SHORTS , _reserved2 : [ u8 ; 256usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 244usize ] , # [ doc = "0x400 - CCM RX MIC check result." ] pub micstatus : MICSTATUS , _reserved4 : [ u8 ; 252usize ] , # [ doc = "0x500 - CCM enable." ] pub enable : ENABLE , # [ doc = "0x504 - Operation mode." ] pub mode : MODE , # [ doc = "0x508 - Pointer to data structure holding AES key and NONCE vector." ] pub cnfptr : CNFPTR , # [ doc = "0x50c - Pointer to input packet." ] pub inptr : INPTR , # [ doc = "0x510 - Pointer to output packet." ] pub outptr : OUTPTR , # [ doc = "0x514 - Pointer to \"scratch\" data area used for temporary storage during resolution. A minimum of 43 bytes must be reserved." ] pub scratchptr : SCRATCHPTR , } # [ doc = "Start generation of key-stream. This operation will stop by itself when completed." ] pub struct TASKS_KSGEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start generation of key-stream. This operation will stop by itself when completed." ] pub mod tasks_ksgen { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_KSGEN { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Start encrypt/decrypt. This operation will stop by itself when completed." ] pub struct TASKS_CRYPT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start encrypt/decrypt. This operation will stop by itself when completed." ] pub mod tasks_crypt { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_CRYPT { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop encrypt/decrypt." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop encrypt/decrypt." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Keystream generation completed." ] pub struct EVENTS_ENDKSGEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Keystream generation completed." ] pub mod events_endksgen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ENDKSGEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Encrypt/decrypt completed." ] pub struct EVENTS_ENDCRYPT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Encrypt/decrypt completed." ] pub mod events_endcrypt { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ENDCRYPT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Error happened." ] pub struct EVENTS_ERROR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Error happened." ] pub mod events_error { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ERROR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Shortcut for the CCM." ] pub struct SHORTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Shortcut for the CCM." ] pub mod shorts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SHORTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENDKSGEN_CRYPT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDKSGEN_CRYPTR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl ENDKSGEN_CRYPTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDKSGEN_CRYPTR :: DISABLED => false , ENDKSGEN_CRYPTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDKSGEN_CRYPTR { match value { false => ENDKSGEN_CRYPTR :: DISABLED , true => ENDKSGEN_CRYPTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDKSGEN_CRYPTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDKSGEN_CRYPTR :: ENABLED } } # [ doc = "Values that can be written to the field `ENDKSGEN_CRYPT`" ] pub enum ENDKSGEN_CRYPTW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl ENDKSGEN_CRYPTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDKSGEN_CRYPTW :: DISABLED => false , ENDKSGEN_CRYPTW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENDKSGEN_CRYPTW < 'a > { w : & 'a mut W , } impl < 'a > _ENDKSGEN_CRYPTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDKSGEN_CRYPTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENDKSGEN_CRYPTW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENDKSGEN_CRYPTW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Short-cut between ENDKSGEN event and CRYPT task." ] # [ inline ] pub fn endksgen_crypt ( & self ) -> ENDKSGEN_CRYPTR { ENDKSGEN_CRYPTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Short-cut between ENDKSGEN event and CRYPT task." ] # [ inline ] pub fn endksgen_crypt ( & mut self ) -> _ENDKSGEN_CRYPTW { _ENDKSGEN_CRYPTW { w : self } } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENDKSGEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDKSGENR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDKSGENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDKSGENR :: DISABLED => false , ENDKSGENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDKSGENR { match value { false => ENDKSGENR :: DISABLED , true => ENDKSGENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDKSGENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDKSGENR :: ENABLED } } # [ doc = "Possible values of the field `ENDCRYPT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDCRYPTR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDCRYPTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDCRYPTR :: DISABLED => false , ENDCRYPTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDCRYPTR { match value { false => ENDCRYPTR :: DISABLED , true => ENDCRYPTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDCRYPTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDCRYPTR :: ENABLED } } # [ doc = "Possible values of the field `ERROR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERRORR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ERRORR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERRORR :: DISABLED => false , ERRORR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERRORR { match value { false => ERRORR :: DISABLED , true => ERRORR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ERRORR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ERRORR :: ENABLED } } # [ doc = "Values that can be written to the field `ENDKSGEN`" ] pub enum ENDKSGENW { # [ doc = "Enable interrupt on write." ] SET } impl ENDKSGENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDKSGENW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ENDKSGENW < 'a > { w : & 'a mut W , } impl < 'a > _ENDKSGENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDKSGENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ENDKSGENW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENDCRYPT`" ] pub enum ENDCRYPTW { # [ doc = "Enable interrupt on write." ] SET } impl ENDCRYPTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDCRYPTW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ENDCRYPTW < 'a > { w : & 'a mut W , } impl < 'a > _ENDCRYPTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDCRYPTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ENDCRYPTW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ERROR`" ] pub enum ERRORW { # [ doc = "Enable interrupt on write." ] SET } impl ERRORW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERRORW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ERRORW < 'a > { w : & 'a mut W , } impl < 'a > _ERRORW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERRORW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ERRORW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on ENDKSGEN event." ] # [ inline ] pub fn endksgen ( & self ) -> ENDKSGENR { ENDKSGENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on ENDCRYPT event." ] # [ inline ] pub fn endcrypt ( & self ) -> ENDCRYPTR { ENDCRYPTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable interrupt on ERROR event." ] # [ inline ] pub fn error ( & self ) -> ERRORR { ERRORR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on ENDKSGEN event." ] # [ inline ] pub fn endksgen ( & mut self ) -> _ENDKSGENW { _ENDKSGENW { w : self } } # [ doc = "Bit 1 - Enable interrupt on ENDCRYPT event." ] # [ inline ] pub fn endcrypt ( & mut self ) -> _ENDCRYPTW { _ENDCRYPTW { w : self } } # [ doc = "Bit 2 - Enable interrupt on ERROR event." ] # [ inline ] pub fn error ( & mut self ) -> _ERRORW { _ERRORW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENDKSGEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDKSGENR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDKSGENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDKSGENR :: DISABLED => false , ENDKSGENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDKSGENR { match value { false => ENDKSGENR :: DISABLED , true => ENDKSGENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDKSGENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDKSGENR :: ENABLED } } # [ doc = "Possible values of the field `ENDCRYPT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDCRYPTR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ENDCRYPTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENDCRYPTR :: DISABLED => false , ENDCRYPTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENDCRYPTR { match value { false => ENDCRYPTR :: DISABLED , true => ENDCRYPTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENDCRYPTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENDCRYPTR :: ENABLED } } # [ doc = "Possible values of the field `ERROR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERRORR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ERRORR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERRORR :: DISABLED => false , ERRORR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERRORR { match value { false => ERRORR :: DISABLED , true => ERRORR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ERRORR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ERRORR :: ENABLED } } # [ doc = "Values that can be written to the field `ENDKSGEN`" ] pub enum ENDKSGENW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ENDKSGENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDKSGENW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ENDKSGENW < 'a > { w : & 'a mut W , } impl < 'a > _ENDKSGENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDKSGENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ENDKSGENW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ENDCRYPT`" ] pub enum ENDCRYPTW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ENDCRYPTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENDCRYPTW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ENDCRYPTW < 'a > { w : & 'a mut W , } impl < 'a > _ENDCRYPTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENDCRYPTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ENDCRYPTW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ERROR`" ] pub enum ERRORW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ERRORW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERRORW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ERRORW < 'a > { w : & 'a mut W , } impl < 'a > _ERRORW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERRORW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ERRORW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on ENDKSGEN event." ] # [ inline ] pub fn endksgen ( & self ) -> ENDKSGENR { ENDKSGENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on ENDCRYPT event." ] # [ inline ] pub fn endcrypt ( & self ) -> ENDCRYPTR { ENDCRYPTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Disable interrupt on ERROR event." ] # [ inline ] pub fn error ( & self ) -> ERRORR { ERRORR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on ENDKSGEN event." ] # [ inline ] pub fn endksgen ( & mut self ) -> _ENDKSGENW { _ENDKSGENW { w : self } } # [ doc = "Bit 1 - Disable interrupt on ENDCRYPT event." ] # [ inline ] pub fn endcrypt ( & mut self ) -> _ENDCRYPTW { _ENDCRYPTW { w : self } } # [ doc = "Bit 2 - Disable interrupt on ERROR event." ] # [ inline ] pub fn error ( & mut self ) -> _ERRORW { _ERRORW { w : self } } } } # [ doc = "CCM RX MIC check result." ] pub struct MICSTATUS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "CCM RX MIC check result." ] pub mod micstatus { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: MICSTATUS { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `MICSTATUS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MICSTATUSR { # [ doc = "MIC check failed." ] CHECKFAILED , # [ doc = "MIC check passed." ] CHECKPASSED } impl MICSTATUSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MICSTATUSR :: CHECKFAILED => false , MICSTATUSR :: CHECKPASSED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MICSTATUSR { match value { false => MICSTATUSR :: CHECKFAILED , true => MICSTATUSR :: CHECKPASSED , } } # [ doc = "Checks if the value of the field is `CHECKFAILED`" ] # [ inline ] pub fn is_check_failed ( & self ) -> bool { * self == MICSTATUSR :: CHECKFAILED } # [ doc = "Checks if the value of the field is `CHECKPASSED`" ] # [ inline ] pub fn is_check_passed ( & self ) -> bool { * self == MICSTATUSR :: CHECKPASSED } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Result of the MIC check performed during the previous CCM RX STARTCRYPT" ] # [ inline ] pub fn micstatus ( & self ) -> MICSTATUSR { MICSTATUSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "CCM enable." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "CCM enable." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "CCM is disabled." ] DISABLED , # [ doc = "CCM is enabled." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ENABLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ENABLER :: DISABLED => 0 , ENABLER :: ENABLED => 0x02 , ENABLER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ENABLER { match value { 0 => ENABLER :: DISABLED , 2 => ENABLER :: ENABLED , i => ENABLER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "CCM is disabled." ] DISABLED , # [ doc = "CCM is enabled." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ENABLEW :: DISABLED => 0 , ENABLEW :: ENABLED => 2 } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CCM is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "CCM is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - CCM enable." ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - CCM enable." ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "Operation mode." ] pub struct MODE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Operation mode." ] pub mod mode { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MODE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODER { # [ doc = "CCM mode TX" ] ENCRYPTION , # [ doc = "CCM mode TX" ] DECRYPTION } impl MODER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MODER :: ENCRYPTION => false , MODER :: DECRYPTION => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MODER { match value { false => MODER :: ENCRYPTION , true => MODER :: DECRYPTION , } } # [ doc = "Checks if the value of the field is `ENCRYPTION`" ] # [ inline ] pub fn is_encryption ( & self ) -> bool { * self == MODER :: ENCRYPTION } # [ doc = "Checks if the value of the field is `DECRYPTION`" ] # [ inline ] pub fn is_decryption ( & self ) -> bool { * self == MODER :: DECRYPTION } } # [ doc = "Values that can be written to the field `MODE`" ] pub enum MODEW { # [ doc = "CCM mode TX" ] ENCRYPTION , # [ doc = "CCM mode TX" ] DECRYPTION } impl MODEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MODEW :: ENCRYPTION => false , MODEW :: DECRYPTION => true } } } # [ doc = r" Proxy" ] pub struct _MODEW < 'a > { w : & 'a mut W , } impl < 'a > _MODEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MODEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "CCM mode TX" ] # [ inline ] pub fn encryption ( self ) -> & 'a mut W { self . variant ( MODEW :: ENCRYPTION ) } # [ doc = "CCM mode TX" ] # [ inline ] pub fn decryption ( self ) -> & 'a mut W { self . variant ( MODEW :: DECRYPTION ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - CCM mode operation." ] # [ inline ] pub fn mode ( & self ) -> MODER { MODER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - CCM mode operation." ] # [ inline ] pub fn mode ( & mut self ) -> _MODEW { _MODEW { w : self } } } } # [ doc = "Pointer to data structure holding AES key and NONCE vector." ] pub struct CNFPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pointer to data structure holding AES key and NONCE vector." ] pub mod cnfptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CNFPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pointer to input packet." ] pub struct INPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pointer to input packet." ] pub mod inptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pointer to output packet." ] pub struct OUTPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pointer to output packet." ] pub mod outptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: OUTPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pointer to \"scratch\" data area used for temporary storage during resolution. A minimum of 43 bytes must be reserved." ] pub struct SCRATCHPTR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pointer to \"scratch\" data area used for temporary storage during resolution. A minimum of 43 bytes must be reserved." ] pub mod scratchptr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SCRATCHPTR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } } # [ doc = "Watchdog Timer." ] pub struct WDT { _marker : PhantomData < * const ( ) > } unsafe impl Send for WDT { } impl WDT { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const wdt :: RegisterBlock { 0x4001_0000 as * const _ } } impl Deref for WDT { type Target = wdt :: RegisterBlock ; fn deref ( & self ) -> & wdt :: RegisterBlock { unsafe { & * WDT :: ptr ( ) } } } # [ doc = "Watchdog Timer." ] pub mod wdt { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start the watchdog." ] pub tasks_start : TASKS_START , _reserved0 : [ u8 ; 252usize ] , # [ doc = "0x100 - Watchdog timeout." ] pub events_timeout : EVENTS_TIMEOUT , _reserved1 : [ u8 ; 512usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved2 : [ u8 ; 244usize ] , # [ doc = "0x400 - Watchdog running status." ] pub runstatus : RUNSTATUS , # [ doc = "0x404 - Request status." ] pub reqstatus : REQSTATUS , _reserved3 : [ u8 ; 252usize ] , # [ doc = "0x504 - Counter reload value in number of 32kiHz clock cycles." ] pub crv : CRV , # [ doc = "0x508 - Reload request enable." ] pub rren : RREN , # [ doc = "0x50c - Configuration register." ] pub config : CONFIG , _reserved4 : [ u8 ; 240usize ] , # [ doc = "0x600 - Reload requests registers." ] pub rr : [ RR ; 8 ] , } # [ doc = "Start the watchdog." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start the watchdog." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Watchdog timeout." ] pub struct EVENTS_TIMEOUT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog timeout." ] pub mod events_timeout { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_TIMEOUT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `TIMEOUT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TIMEOUTR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl TIMEOUTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TIMEOUTR :: DISABLED => false , TIMEOUTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TIMEOUTR { match value { false => TIMEOUTR :: DISABLED , true => TIMEOUTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TIMEOUTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TIMEOUTR :: ENABLED } } # [ doc = "Values that can be written to the field `TIMEOUT`" ] pub enum TIMEOUTW { # [ doc = "Enable interrupt on write." ] SET } impl TIMEOUTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TIMEOUTW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _TIMEOUTW < 'a > { w : & 'a mut W , } impl < 'a > _TIMEOUTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TIMEOUTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( TIMEOUTW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on TIMEOUT event." ] # [ inline ] pub fn timeout ( & self ) -> TIMEOUTR { TIMEOUTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on TIMEOUT event." ] # [ inline ] pub fn timeout ( & mut self ) -> _TIMEOUTW { _TIMEOUTW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `TIMEOUT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TIMEOUTR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl TIMEOUTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { TIMEOUTR :: DISABLED => false , TIMEOUTR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> TIMEOUTR { match value { false => TIMEOUTR :: DISABLED , true => TIMEOUTR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == TIMEOUTR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == TIMEOUTR :: ENABLED } } # [ doc = "Values that can be written to the field `TIMEOUT`" ] pub enum TIMEOUTW { # [ doc = "Disable interrupt on write." ] CLEAR } impl TIMEOUTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { TIMEOUTW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _TIMEOUTW < 'a > { w : & 'a mut W , } impl < 'a > _TIMEOUTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : TIMEOUTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( TIMEOUTW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on TIMEOUT event." ] # [ inline ] pub fn timeout ( & self ) -> TIMEOUTR { TIMEOUTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on TIMEOUT event." ] # [ inline ] pub fn timeout ( & mut self ) -> _TIMEOUTW { _TIMEOUTW { w : self } } } } # [ doc = "Watchdog running status." ] pub struct RUNSTATUS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Watchdog running status." ] pub mod runstatus { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RUNSTATUS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `RUNSTATUS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RUNSTATUSR { # [ doc = "Watchdog timer is not running." ] NOTRUNNING , # [ doc = "Watchdog timer is running." ] RUNNING } impl RUNSTATUSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RUNSTATUSR :: NOTRUNNING => false , RUNSTATUSR :: RUNNING => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RUNSTATUSR { match value { false => RUNSTATUSR :: NOTRUNNING , true => RUNSTATUSR :: RUNNING , } } # [ doc = "Checks if the value of the field is `NOTRUNNING`" ] # [ inline ] pub fn is_not_running ( & self ) -> bool { * self == RUNSTATUSR :: NOTRUNNING } # [ doc = "Checks if the value of the field is `RUNNING`" ] # [ inline ] pub fn is_running ( & self ) -> bool { * self == RUNSTATUSR :: RUNNING } } # [ doc = "Values that can be written to the field `RUNSTATUS`" ] pub enum RUNSTATUSW { # [ doc = "Watchdog timer is not running." ] NOTRUNNING , # [ doc = "Watchdog timer is running." ] RUNNING } impl RUNSTATUSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RUNSTATUSW :: NOTRUNNING => false , RUNSTATUSW :: RUNNING => true } } } # [ doc = r" Proxy" ] pub struct _RUNSTATUSW < 'a > { w : & 'a mut W , } impl < 'a > _RUNSTATUSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RUNSTATUSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Watchdog timer is not running." ] # [ inline ] pub fn not_running ( self ) -> & 'a mut W { self . variant ( RUNSTATUSW :: NOTRUNNING ) } # [ doc = "Watchdog timer is running." ] # [ inline ] pub fn running ( self ) -> & 'a mut W { self . variant ( RUNSTATUSW :: RUNNING ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Watchdog running status." ] # [ inline ] pub fn runstatus ( & self ) -> RUNSTATUSR { RUNSTATUSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Watchdog running status." ] # [ inline ] pub fn runstatus ( & mut self ) -> _RUNSTATUSW { _RUNSTATUSW { w : self } } } } # [ doc = "Request status." ] pub struct REQSTATUS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Request status." ] pub mod reqstatus { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: REQSTATUS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `RR0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR0R { # [ doc = "RR\\[0\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[0\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR0R :: DISABLEDORREQUESTED => false , RR0R :: ENABLEDANDUNREQUESTED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR0R { match value { false => RR0R :: DISABLEDORREQUESTED , true => RR0R :: ENABLEDANDUNREQUESTED , } } # [ doc = "Checks if the value of the field is `DISABLEDORREQUESTED`" ] # [ inline ] pub fn is_disabled_or_requested ( & self ) -> bool { * self == RR0R :: DISABLEDORREQUESTED } # [ doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`" ] # [ inline ] pub fn is_enabled_and_unrequested ( & self ) -> bool { * self == RR0R :: ENABLEDANDUNREQUESTED } } # [ doc = "Possible values of the field `RR1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR1R { # [ doc = "RR\\[1\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[1\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR1R :: DISABLEDORREQUESTED => false , RR1R :: ENABLEDANDUNREQUESTED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR1R { match value { false => RR1R :: DISABLEDORREQUESTED , true => RR1R :: ENABLEDANDUNREQUESTED , } } # [ doc = "Checks if the value of the field is `DISABLEDORREQUESTED`" ] # [ inline ] pub fn is_disabled_or_requested ( & self ) -> bool { * self == RR1R :: DISABLEDORREQUESTED } # [ doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`" ] # [ inline ] pub fn is_enabled_and_unrequested ( & self ) -> bool { * self == RR1R :: ENABLEDANDUNREQUESTED } } # [ doc = "Possible values of the field `RR2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR2R { # [ doc = "RR\\[2\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[2\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR2R :: DISABLEDORREQUESTED => false , RR2R :: ENABLEDANDUNREQUESTED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR2R { match value { false => RR2R :: DISABLEDORREQUESTED , true => RR2R :: ENABLEDANDUNREQUESTED , } } # [ doc = "Checks if the value of the field is `DISABLEDORREQUESTED`" ] # [ inline ] pub fn is_disabled_or_requested ( & self ) -> bool { * self == RR2R :: DISABLEDORREQUESTED } # [ doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`" ] # [ inline ] pub fn is_enabled_and_unrequested ( & self ) -> bool { * self == RR2R :: ENABLEDANDUNREQUESTED } } # [ doc = "Possible values of the field `RR3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR3R { # [ doc = "RR\\[3\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[3\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR3R :: DISABLEDORREQUESTED => false , RR3R :: ENABLEDANDUNREQUESTED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR3R { match value { false => RR3R :: DISABLEDORREQUESTED , true => RR3R :: ENABLEDANDUNREQUESTED , } } # [ doc = "Checks if the value of the field is `DISABLEDORREQUESTED`" ] # [ inline ] pub fn is_disabled_or_requested ( & self ) -> bool { * self == RR3R :: DISABLEDORREQUESTED } # [ doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`" ] # [ inline ] pub fn is_enabled_and_unrequested ( & self ) -> bool { * self == RR3R :: ENABLEDANDUNREQUESTED } } # [ doc = "Possible values of the field `RR4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR4R { # [ doc = "RR\\[4\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[4\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR4R :: DISABLEDORREQUESTED => false , RR4R :: ENABLEDANDUNREQUESTED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR4R { match value { false => RR4R :: DISABLEDORREQUESTED , true => RR4R :: ENABLEDANDUNREQUESTED , } } # [ doc = "Checks if the value of the field is `DISABLEDORREQUESTED`" ] # [ inline ] pub fn is_disabled_or_requested ( & self ) -> bool { * self == RR4R :: DISABLEDORREQUESTED } # [ doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`" ] # [ inline ] pub fn is_enabled_and_unrequested ( & self ) -> bool { * self == RR4R :: ENABLEDANDUNREQUESTED } } # [ doc = "Possible values of the field `RR5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR5R { # [ doc = "RR\\[5\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[5\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR5R :: DISABLEDORREQUESTED => false , RR5R :: ENABLEDANDUNREQUESTED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR5R { match value { false => RR5R :: DISABLEDORREQUESTED , true => RR5R :: ENABLEDANDUNREQUESTED , } } # [ doc = "Checks if the value of the field is `DISABLEDORREQUESTED`" ] # [ inline ] pub fn is_disabled_or_requested ( & self ) -> bool { * self == RR5R :: DISABLEDORREQUESTED } # [ doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`" ] # [ inline ] pub fn is_enabled_and_unrequested ( & self ) -> bool { * self == RR5R :: ENABLEDANDUNREQUESTED } } # [ doc = "Possible values of the field `RR6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR6R { # [ doc = "RR\\[6\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[6\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR6R :: DISABLEDORREQUESTED => false , RR6R :: ENABLEDANDUNREQUESTED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR6R { match value { false => RR6R :: DISABLEDORREQUESTED , true => RR6R :: ENABLEDANDUNREQUESTED , } } # [ doc = "Checks if the value of the field is `DISABLEDORREQUESTED`" ] # [ inline ] pub fn is_disabled_or_requested ( & self ) -> bool { * self == RR6R :: DISABLEDORREQUESTED } # [ doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`" ] # [ inline ] pub fn is_enabled_and_unrequested ( & self ) -> bool { * self == RR6R :: ENABLEDANDUNREQUESTED } } # [ doc = "Possible values of the field `RR7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR7R { # [ doc = "RR\\[7\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[7\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR7R :: DISABLEDORREQUESTED => false , RR7R :: ENABLEDANDUNREQUESTED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR7R { match value { false => RR7R :: DISABLEDORREQUESTED , true => RR7R :: ENABLEDANDUNREQUESTED , } } # [ doc = "Checks if the value of the field is `DISABLEDORREQUESTED`" ] # [ inline ] pub fn is_disabled_or_requested ( & self ) -> bool { * self == RR7R :: DISABLEDORREQUESTED } # [ doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`" ] # [ inline ] pub fn is_enabled_and_unrequested ( & self ) -> bool { * self == RR7R :: ENABLEDANDUNREQUESTED } } # [ doc = "Values that can be written to the field `RR0`" ] pub enum RR0W { # [ doc = "RR\\[0\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[0\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR0W :: DISABLEDORREQUESTED => false , RR0W :: ENABLEDANDUNREQUESTED => true } } } # [ doc = r" Proxy" ] pub struct _RR0W < 'a > { w : & 'a mut W , } impl < 'a > _RR0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[0\\] register is not enabled or has already requested reload." ] # [ inline ] pub fn disabled_or_requested ( self ) -> & 'a mut W { self . variant ( RR0W :: DISABLEDORREQUESTED ) } # [ doc = "RR\\[0\\] register is enabled and has not jet requested." ] # [ inline ] pub fn enabled_and_unrequested ( self ) -> & 'a mut W { self . variant ( RR0W :: ENABLEDANDUNREQUESTED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR1`" ] pub enum RR1W { # [ doc = "RR\\[1\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[1\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR1W :: DISABLEDORREQUESTED => false , RR1W :: ENABLEDANDUNREQUESTED => true } } } # [ doc = r" Proxy" ] pub struct _RR1W < 'a > { w : & 'a mut W , } impl < 'a > _RR1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[1\\] register is not enabled or has already requested reload." ] # [ inline ] pub fn disabled_or_requested ( self ) -> & 'a mut W { self . variant ( RR1W :: DISABLEDORREQUESTED ) } # [ doc = "RR\\[1\\] register is enabled and has not jet requested." ] # [ inline ] pub fn enabled_and_unrequested ( self ) -> & 'a mut W { self . variant ( RR1W :: ENABLEDANDUNREQUESTED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR2`" ] pub enum RR2W { # [ doc = "RR\\[2\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[2\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR2W :: DISABLEDORREQUESTED => false , RR2W :: ENABLEDANDUNREQUESTED => true } } } # [ doc = r" Proxy" ] pub struct _RR2W < 'a > { w : & 'a mut W , } impl < 'a > _RR2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[2\\] register is not enabled or has already requested reload." ] # [ inline ] pub fn disabled_or_requested ( self ) -> & 'a mut W { self . variant ( RR2W :: DISABLEDORREQUESTED ) } # [ doc = "RR\\[2\\] register is enabled and has not jet requested." ] # [ inline ] pub fn enabled_and_unrequested ( self ) -> & 'a mut W { self . variant ( RR2W :: ENABLEDANDUNREQUESTED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR3`" ] pub enum RR3W { # [ doc = "RR\\[3\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[3\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR3W :: DISABLEDORREQUESTED => false , RR3W :: ENABLEDANDUNREQUESTED => true } } } # [ doc = r" Proxy" ] pub struct _RR3W < 'a > { w : & 'a mut W , } impl < 'a > _RR3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[3\\] register is not enabled or has already requested reload." ] # [ inline ] pub fn disabled_or_requested ( self ) -> & 'a mut W { self . variant ( RR3W :: DISABLEDORREQUESTED ) } # [ doc = "RR\\[3\\] register is enabled and has not jet requested." ] # [ inline ] pub fn enabled_and_unrequested ( self ) -> & 'a mut W { self . variant ( RR3W :: ENABLEDANDUNREQUESTED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR4`" ] pub enum RR4W { # [ doc = "RR\\[4\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[4\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR4W :: DISABLEDORREQUESTED => false , RR4W :: ENABLEDANDUNREQUESTED => true } } } # [ doc = r" Proxy" ] pub struct _RR4W < 'a > { w : & 'a mut W , } impl < 'a > _RR4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[4\\] register is not enabled or has already requested reload." ] # [ inline ] pub fn disabled_or_requested ( self ) -> & 'a mut W { self . variant ( RR4W :: DISABLEDORREQUESTED ) } # [ doc = "RR\\[4\\] register is enabled and has not jet requested." ] # [ inline ] pub fn enabled_and_unrequested ( self ) -> & 'a mut W { self . variant ( RR4W :: ENABLEDANDUNREQUESTED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR5`" ] pub enum RR5W { # [ doc = "RR\\[5\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[5\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR5W :: DISABLEDORREQUESTED => false , RR5W :: ENABLEDANDUNREQUESTED => true } } } # [ doc = r" Proxy" ] pub struct _RR5W < 'a > { w : & 'a mut W , } impl < 'a > _RR5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[5\\] register is not enabled or has already requested reload." ] # [ inline ] pub fn disabled_or_requested ( self ) -> & 'a mut W { self . variant ( RR5W :: DISABLEDORREQUESTED ) } # [ doc = "RR\\[5\\] register is enabled and has not jet requested." ] # [ inline ] pub fn enabled_and_unrequested ( self ) -> & 'a mut W { self . variant ( RR5W :: ENABLEDANDUNREQUESTED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR6`" ] pub enum RR6W { # [ doc = "RR\\[6\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[6\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR6W :: DISABLEDORREQUESTED => false , RR6W :: ENABLEDANDUNREQUESTED => true } } } # [ doc = r" Proxy" ] pub struct _RR6W < 'a > { w : & 'a mut W , } impl < 'a > _RR6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[6\\] register is not enabled or has already requested reload." ] # [ inline ] pub fn disabled_or_requested ( self ) -> & 'a mut W { self . variant ( RR6W :: DISABLEDORREQUESTED ) } # [ doc = "RR\\[6\\] register is enabled and has not jet requested." ] # [ inline ] pub fn enabled_and_unrequested ( self ) -> & 'a mut W { self . variant ( RR6W :: ENABLEDANDUNREQUESTED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR7`" ] pub enum RR7W { # [ doc = "RR\\[7\\] register is not enabled or has already requested reload." ] DISABLEDORREQUESTED , # [ doc = "RR\\[7\\] register is enabled and has not jet requested." ] ENABLEDANDUNREQUESTED } impl RR7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR7W :: DISABLEDORREQUESTED => false , RR7W :: ENABLEDANDUNREQUESTED => true } } } # [ doc = r" Proxy" ] pub struct _RR7W < 'a > { w : & 'a mut W , } impl < 'a > _RR7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[7\\] register is not enabled or has already requested reload." ] # [ inline ] pub fn disabled_or_requested ( self ) -> & 'a mut W { self . variant ( RR7W :: DISABLEDORREQUESTED ) } # [ doc = "RR\\[7\\] register is enabled and has not jet requested." ] # [ inline ] pub fn enabled_and_unrequested ( self ) -> & 'a mut W { self . variant ( RR7W :: ENABLEDANDUNREQUESTED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Request status for RR\\[0\\]." ] # [ inline ] pub fn rr0 ( & self ) -> RR0R { RR0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Request status for RR\\[1\\]." ] # [ inline ] pub fn rr1 ( & self ) -> RR1R { RR1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Request status for RR\\[2\\]." ] # [ inline ] pub fn rr2 ( & self ) -> RR2R { RR2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Request status for RR\\[3\\]." ] # [ inline ] pub fn rr3 ( & self ) -> RR3R { RR3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Request status for RR\\[4\\]." ] # [ inline ] pub fn rr4 ( & self ) -> RR4R { RR4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Request status for RR\\[5\\]." ] # [ inline ] pub fn rr5 ( & self ) -> RR5R { RR5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Request status for RR\\[6\\]." ] # [ inline ] pub fn rr6 ( & self ) -> RR6R { RR6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Request status for RR\\[7\\]." ] # [ inline ] pub fn rr7 ( & self ) -> RR7R { RR7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Request status for RR\\[0\\]." ] # [ inline ] pub fn rr0 ( & mut self ) -> _RR0W { _RR0W { w : self } } # [ doc = "Bit 1 - Request status for RR\\[1\\]." ] # [ inline ] pub fn rr1 ( & mut self ) -> _RR1W { _RR1W { w : self } } # [ doc = "Bit 2 - Request status for RR\\[2\\]." ] # [ inline ] pub fn rr2 ( & mut self ) -> _RR2W { _RR2W { w : self } } # [ doc = "Bit 3 - Request status for RR\\[3\\]." ] # [ inline ] pub fn rr3 ( & mut self ) -> _RR3W { _RR3W { w : self } } # [ doc = "Bit 4 - Request status for RR\\[4\\]." ] # [ inline ] pub fn rr4 ( & mut self ) -> _RR4W { _RR4W { w : self } } # [ doc = "Bit 5 - Request status for RR\\[5\\]." ] # [ inline ] pub fn rr5 ( & mut self ) -> _RR5W { _RR5W { w : self } } # [ doc = "Bit 6 - Request status for RR\\[6\\]." ] # [ inline ] pub fn rr6 ( & mut self ) -> _RR6W { _RR6W { w : self } } # [ doc = "Bit 7 - Request status for RR\\[7\\]." ] # [ inline ] pub fn rr7 ( & mut self ) -> _RR7W { _RR7W { w : self } } } } # [ doc = "Counter reload value in number of 32kiHz clock cycles." ] pub struct CRV { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Counter reload value in number of 32kiHz clock cycles." ] pub mod crv { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CRV { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Reload request enable." ] pub struct RREN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Reload request enable." ] pub mod rren { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RREN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `RR0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR0R { # [ doc = "RR\\[0\\] register is disabled." ] DISABLED , # [ doc = "RR\\[0\\] register is enabled." ] ENABLED } impl RR0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR0R :: DISABLED => false , RR0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR0R { match value { false => RR0R :: DISABLED , true => RR0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RR0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RR0R :: ENABLED } } # [ doc = "Possible values of the field `RR1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR1R { # [ doc = "RR\\[1\\] register is disabled." ] DISABLED , # [ doc = "RR\\[1\\] register is enabled." ] ENABLED } impl RR1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR1R :: DISABLED => false , RR1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR1R { match value { false => RR1R :: DISABLED , true => RR1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RR1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RR1R :: ENABLED } } # [ doc = "Possible values of the field `RR2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR2R { # [ doc = "RR\\[2\\] register is disabled." ] DISABLED , # [ doc = "RR\\[2\\] register is enabled." ] ENABLED } impl RR2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR2R :: DISABLED => false , RR2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR2R { match value { false => RR2R :: DISABLED , true => RR2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RR2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RR2R :: ENABLED } } # [ doc = "Possible values of the field `RR3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR3R { # [ doc = "RR\\[3\\] register is disabled." ] DISABLED , # [ doc = "RR\\[3\\] register is enabled." ] ENABLED } impl RR3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR3R :: DISABLED => false , RR3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR3R { match value { false => RR3R :: DISABLED , true => RR3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RR3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RR3R :: ENABLED } } # [ doc = "Possible values of the field `RR4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR4R { # [ doc = "RR\\[4\\] register is disabled." ] DISABLED , # [ doc = "RR\\[4\\] register is enabled." ] ENABLED } impl RR4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR4R :: DISABLED => false , RR4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR4R { match value { false => RR4R :: DISABLED , true => RR4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RR4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RR4R :: ENABLED } } # [ doc = "Possible values of the field `RR5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR5R { # [ doc = "RR\\[5\\] register is disabled." ] DISABLED , # [ doc = "RR\\[5\\] register is enabled." ] ENABLED } impl RR5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR5R :: DISABLED => false , RR5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR5R { match value { false => RR5R :: DISABLED , true => RR5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RR5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RR5R :: ENABLED } } # [ doc = "Possible values of the field `RR6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR6R { # [ doc = "RR\\[6\\] register is disabled." ] DISABLED , # [ doc = "RR\\[6\\] register is enabled." ] ENABLED } impl RR6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR6R :: DISABLED => false , RR6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR6R { match value { false => RR6R :: DISABLED , true => RR6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RR6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RR6R :: ENABLED } } # [ doc = "Possible values of the field `RR7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RR7R { # [ doc = "RR\\[7\\] register is disabled." ] DISABLED , # [ doc = "RR\\[7\\] register is enabled." ] ENABLED } impl RR7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RR7R :: DISABLED => false , RR7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RR7R { match value { false => RR7R :: DISABLED , true => RR7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == RR7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == RR7R :: ENABLED } } # [ doc = "Values that can be written to the field `RR0`" ] pub enum RR0W { # [ doc = "RR\\[0\\] register is disabled." ] DISABLED , # [ doc = "RR\\[0\\] register is enabled." ] ENABLED } impl RR0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR0W :: DISABLED => false , RR0W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _RR0W < 'a > { w : & 'a mut W , } impl < 'a > _RR0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[0\\] register is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RR0W :: DISABLED ) } # [ doc = "RR\\[0\\] register is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( RR0W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR1`" ] pub enum RR1W { # [ doc = "RR\\[1\\] register is disabled." ] DISABLED , # [ doc = "RR\\[1\\] register is enabled." ] ENABLED } impl RR1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR1W :: DISABLED => false , RR1W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _RR1W < 'a > { w : & 'a mut W , } impl < 'a > _RR1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[1\\] register is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RR1W :: DISABLED ) } # [ doc = "RR\\[1\\] register is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( RR1W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR2`" ] pub enum RR2W { # [ doc = "RR\\[2\\] register is disabled." ] DISABLED , # [ doc = "RR\\[2\\] register is enabled." ] ENABLED } impl RR2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR2W :: DISABLED => false , RR2W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _RR2W < 'a > { w : & 'a mut W , } impl < 'a > _RR2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[2\\] register is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RR2W :: DISABLED ) } # [ doc = "RR\\[2\\] register is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( RR2W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR3`" ] pub enum RR3W { # [ doc = "RR\\[3\\] register is disabled." ] DISABLED , # [ doc = "RR\\[3\\] register is enabled." ] ENABLED } impl RR3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR3W :: DISABLED => false , RR3W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _RR3W < 'a > { w : & 'a mut W , } impl < 'a > _RR3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[3\\] register is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RR3W :: DISABLED ) } # [ doc = "RR\\[3\\] register is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( RR3W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR4`" ] pub enum RR4W { # [ doc = "RR\\[4\\] register is disabled." ] DISABLED , # [ doc = "RR\\[4\\] register is enabled." ] ENABLED } impl RR4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR4W :: DISABLED => false , RR4W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _RR4W < 'a > { w : & 'a mut W , } impl < 'a > _RR4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[4\\] register is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RR4W :: DISABLED ) } # [ doc = "RR\\[4\\] register is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( RR4W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR5`" ] pub enum RR5W { # [ doc = "RR\\[5\\] register is disabled." ] DISABLED , # [ doc = "RR\\[5\\] register is enabled." ] ENABLED } impl RR5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR5W :: DISABLED => false , RR5W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _RR5W < 'a > { w : & 'a mut W , } impl < 'a > _RR5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[5\\] register is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RR5W :: DISABLED ) } # [ doc = "RR\\[5\\] register is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( RR5W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR6`" ] pub enum RR6W { # [ doc = "RR\\[6\\] register is disabled." ] DISABLED , # [ doc = "RR\\[6\\] register is enabled." ] ENABLED } impl RR6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR6W :: DISABLED => false , RR6W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _RR6W < 'a > { w : & 'a mut W , } impl < 'a > _RR6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[6\\] register is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RR6W :: DISABLED ) } # [ doc = "RR\\[6\\] register is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( RR6W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `RR7`" ] pub enum RR7W { # [ doc = "RR\\[7\\] register is disabled." ] DISABLED , # [ doc = "RR\\[7\\] register is enabled." ] ENABLED } impl RR7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { RR7W :: DISABLED => false , RR7W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _RR7W < 'a > { w : & 'a mut W , } impl < 'a > _RR7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RR7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "RR\\[7\\] register is disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RR7W :: DISABLED ) } # [ doc = "RR\\[7\\] register is enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( RR7W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable or disable RR\\[0\\] register." ] # [ inline ] pub fn rr0 ( & self ) -> RR0R { RR0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable or disable RR\\[1\\] register." ] # [ inline ] pub fn rr1 ( & self ) -> RR1R { RR1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable or disable RR\\[2\\] register." ] # [ inline ] pub fn rr2 ( & self ) -> RR2R { RR2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable or disable RR\\[3\\] register." ] # [ inline ] pub fn rr3 ( & self ) -> RR3R { RR3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Enable or disable RR\\[4\\] register." ] # [ inline ] pub fn rr4 ( & self ) -> RR4R { RR4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Enable or disable RR\\[5\\] register." ] # [ inline ] pub fn rr5 ( & self ) -> RR5R { RR5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Enable or disable RR\\[6\\] register." ] # [ inline ] pub fn rr6 ( & self ) -> RR6R { RR6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Enable or disable RR\\[7\\] register." ] # [ inline ] pub fn rr7 ( & self ) -> RR7R { RR7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable or disable RR\\[0\\] register." ] # [ inline ] pub fn rr0 ( & mut self ) -> _RR0W { _RR0W { w : self } } # [ doc = "Bit 1 - Enable or disable RR\\[1\\] register." ] # [ inline ] pub fn rr1 ( & mut self ) -> _RR1W { _RR1W { w : self } } # [ doc = "Bit 2 - Enable or disable RR\\[2\\] register." ] # [ inline ] pub fn rr2 ( & mut self ) -> _RR2W { _RR2W { w : self } } # [ doc = "Bit 3 - Enable or disable RR\\[3\\] register." ] # [ inline ] pub fn rr3 ( & mut self ) -> _RR3W { _RR3W { w : self } } # [ doc = "Bit 4 - Enable or disable RR\\[4\\] register." ] # [ inline ] pub fn rr4 ( & mut self ) -> _RR4W { _RR4W { w : self } } # [ doc = "Bit 5 - Enable or disable RR\\[5\\] register." ] # [ inline ] pub fn rr5 ( & mut self ) -> _RR5W { _RR5W { w : self } } # [ doc = "Bit 6 - Enable or disable RR\\[6\\] register." ] # [ inline ] pub fn rr6 ( & mut self ) -> _RR6W { _RR6W { w : self } } # [ doc = "Bit 7 - Enable or disable RR\\[7\\] register." ] # [ inline ] pub fn rr7 ( & mut self ) -> _RR7W { _RR7W { w : self } } } } # [ doc = "Configuration register." ] pub struct CONFIG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Configuration register." ] pub mod config { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONFIG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SLEEP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SLEEPR { # [ doc = "Pause watchdog while the CPU is asleep." ] PAUSE , # [ doc = "Do not pause watchdog while the CPU is asleep." ] RUN } impl SLEEPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SLEEPR :: PAUSE => false , SLEEPR :: RUN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SLEEPR { match value { false => SLEEPR :: PAUSE , true => SLEEPR :: RUN , } } # [ doc = "Checks if the value of the field is `PAUSE`" ] # [ inline ] pub fn is_pause ( & self ) -> bool { * self == SLEEPR :: PAUSE } # [ doc = "Checks if the value of the field is `RUN`" ] # [ inline ] pub fn is_run ( & self ) -> bool { * self == SLEEPR :: RUN } } # [ doc = "Possible values of the field `HALT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HALTR { # [ doc = "Pause watchdog while the CPU is halted by the debugger." ] PAUSE , # [ doc = "Do not pause watchdog while the CPU is halted by the debugger." ] RUN } impl HALTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { HALTR :: PAUSE => false , HALTR :: RUN => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> HALTR { match value { false => HALTR :: PAUSE , true => HALTR :: RUN , } } # [ doc = "Checks if the value of the field is `PAUSE`" ] # [ inline ] pub fn is_pause ( & self ) -> bool { * self == HALTR :: PAUSE } # [ doc = "Checks if the value of the field is `RUN`" ] # [ inline ] pub fn is_run ( & self ) -> bool { * self == HALTR :: RUN } } # [ doc = "Values that can be written to the field `SLEEP`" ] pub enum SLEEPW { # [ doc = "Pause watchdog while the CPU is asleep." ] PAUSE , # [ doc = "Do not pause watchdog while the CPU is asleep." ] RUN } impl SLEEPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SLEEPW :: PAUSE => false , SLEEPW :: RUN => true } } } # [ doc = r" Proxy" ] pub struct _SLEEPW < 'a > { w : & 'a mut W , } impl < 'a > _SLEEPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SLEEPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pause watchdog while the CPU is asleep." ] # [ inline ] pub fn pause ( self ) -> & 'a mut W { self . variant ( SLEEPW :: PAUSE ) } # [ doc = "Do not pause watchdog while the CPU is asleep." ] # [ inline ] pub fn run ( self ) -> & 'a mut W { self . variant ( SLEEPW :: RUN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `HALT`" ] pub enum HALTW { # [ doc = "Pause watchdog while the CPU is halted by the debugger." ] PAUSE , # [ doc = "Do not pause watchdog while the CPU is halted by the debugger." ] RUN } impl HALTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { HALTW :: PAUSE => false , HALTW :: RUN => true } } } # [ doc = r" Proxy" ] pub struct _HALTW < 'a > { w : & 'a mut W , } impl < 'a > _HALTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : HALTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pause watchdog while the CPU is halted by the debugger." ] # [ inline ] pub fn pause ( self ) -> & 'a mut W { self . variant ( HALTW :: PAUSE ) } # [ doc = "Do not pause watchdog while the CPU is halted by the debugger." ] # [ inline ] pub fn run ( self ) -> & 'a mut W { self . variant ( HALTW :: RUN ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Configure the watchdog to pause or not while the CPU is sleeping." ] # [ inline ] pub fn sleep ( & self ) -> SLEEPR { SLEEPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Configure the watchdog to pause or not while the CPU is halted by the debugger." ] # [ inline ] pub fn halt ( & self ) -> HALTR { HALTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x01 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Configure the watchdog to pause or not while the CPU is sleeping." ] # [ inline ] pub fn sleep ( & mut self ) -> _SLEEPW { _SLEEPW { w : self } } # [ doc = "Bit 3 - Configure the watchdog to pause or not while the CPU is halted by the debugger." ] # [ inline ] pub fn halt ( & mut self ) -> _HALTW { _HALTW { w : self } } } } # [ doc = "Reload requests registers." ] pub struct RR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Reload requests registers." ] pub mod rr { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RR { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } # [ doc = "Values that can be written to the field `RR`" ] pub enum RRW { # [ doc = "Value to request a reload of the watchdog timer." ] RELOAD } impl RRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u32 { match * self { RRW :: RELOAD => 1850885685 } } } # [ doc = r" Proxy" ] pub struct _RRW < 'a > { w : & 'a mut W , } impl < 'a > _RRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : RRW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Value to request a reload of the watchdog timer." ] # [ inline ] pub fn reload ( self ) -> & 'a mut W { self . variant ( RRW :: RELOAD ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:31 - Reload register." ] # [ inline ] pub fn rr ( & mut self ) -> _RRW { _RRW { w : self } } } } } # [ doc = "Real time counter 1." ] pub struct RTC1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for RTC1 { } impl RTC1 { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const rtc0 :: RegisterBlock { 0x4001_1000 as * const _ } } impl Deref for RTC1 { type Target = rtc0 :: RegisterBlock ; fn deref ( & self ) -> & rtc0 :: RegisterBlock { unsafe { & * RTC1 :: ptr ( ) } } } # [ doc = "Rotary decoder." ] pub struct QDEC { _marker : PhantomData < * const ( ) > } unsafe impl Send for QDEC { } impl QDEC { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const qdec :: RegisterBlock { 0x4001_2000 as * const _ } } impl Deref for QDEC { type Target = qdec :: RegisterBlock ; fn deref ( & self ) -> & qdec :: RegisterBlock { unsafe { & * QDEC :: ptr ( ) } } } # [ doc = "Rotary decoder." ] pub mod qdec { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start the quadrature decoder." ] pub tasks_start : TASKS_START , # [ doc = "0x04 - Stop the quadrature decoder." ] pub tasks_stop : TASKS_STOP , # [ doc = "0x08 - Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers." ] pub tasks_readclracc : TASKS_READCLRACC , _reserved0 : [ u8 ; 244usize ] , # [ doc = "0x100 - A new sample is written to the sample register." ] pub events_samplerdy : EVENTS_SAMPLERDY , # [ doc = "0x104 - REPORTPER number of samples accumulated in ACC register, and ACC register different than zero." ] pub events_reportrdy : EVENTS_REPORTRDY , # [ doc = "0x108 - ACC or ACCDBL register overflow." ] pub events_accof : EVENTS_ACCOF , _reserved1 : [ u8 ; 244usize ] , # [ doc = "0x200 - Shortcut for the QDEC." ] pub shorts : SHORTS , _reserved2 : [ u8 ; 256usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 500usize ] , # [ doc = "0x500 - Enable the QDEC." ] pub enable : ENABLE , # [ doc = "0x504 - LED output pin polarity." ] pub ledpol : LEDPOL , # [ doc = "0x508 - Sample period." ] pub sampleper : SAMPLEPER , # [ doc = "0x50c - Motion sample value." ] pub sample : SAMPLE , # [ doc = "0x510 - Number of samples to generate an EVENT_REPORTRDY." ] pub reportper : REPORTPER , # [ doc = "0x514 - Accumulated valid transitions register." ] pub acc : ACC , # [ doc = "0x518 - Snapshot of ACC register. Value generated by the TASKS_READCLEACC task." ] pub accread : ACCREAD , # [ doc = "0x51c - Pin select for LED output." ] pub pselled : PSELLED , # [ doc = "0x520 - Pin select for phase A input." ] pub psela : PSELA , # [ doc = "0x524 - Pin select for phase B input." ] pub pselb : PSELB , # [ doc = "0x528 - Enable debouncer input filters." ] pub dbfen : DBFEN , _reserved4 : [ u8 ; 20usize ] , # [ doc = "0x540 - Time LED is switched ON before the sample." ] pub ledpre : LEDPRE , # [ doc = "0x544 - Accumulated double (error) transitions register." ] pub accdbl : ACCDBL , # [ doc = "0x548 - Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task." ] pub accdblread : ACCDBLREAD , } # [ doc = "Start the quadrature decoder." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start the quadrature decoder." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop the quadrature decoder." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop the quadrature decoder." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers." ] pub struct TASKS_READCLRACC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers." ] pub mod tasks_readclracc { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_READCLRACC { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "A new sample is written to the sample register." ] pub struct EVENTS_SAMPLERDY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "A new sample is written to the sample register." ] pub mod events_samplerdy { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_SAMPLERDY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "REPORTPER number of samples accumulated in ACC register, and ACC register different than zero." ] pub struct EVENTS_REPORTRDY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "REPORTPER number of samples accumulated in ACC register, and ACC register different than zero." ] pub mod events_reportrdy { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_REPORTRDY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "ACC or ACCDBL register overflow." ] pub struct EVENTS_ACCOF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "ACC or ACCDBL register overflow." ] pub mod events_accof { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_ACCOF { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Shortcut for the QDEC." ] pub struct SHORTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Shortcut for the QDEC." ] pub mod shorts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SHORTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `REPORTRDY_READCLRACC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REPORTRDY_READCLRACCR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl REPORTRDY_READCLRACCR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { REPORTRDY_READCLRACCR :: DISABLED => false , REPORTRDY_READCLRACCR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> REPORTRDY_READCLRACCR { match value { false => REPORTRDY_READCLRACCR :: DISABLED , true => REPORTRDY_READCLRACCR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == REPORTRDY_READCLRACCR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == REPORTRDY_READCLRACCR :: ENABLED } } # [ doc = "Possible values of the field `SAMPLERDY_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SAMPLERDY_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl SAMPLERDY_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SAMPLERDY_STOPR :: DISABLED => false , SAMPLERDY_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SAMPLERDY_STOPR { match value { false => SAMPLERDY_STOPR :: DISABLED , true => SAMPLERDY_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == SAMPLERDY_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == SAMPLERDY_STOPR :: ENABLED } } # [ doc = "Values that can be written to the field `REPORTRDY_READCLRACC`" ] pub enum REPORTRDY_READCLRACCW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl REPORTRDY_READCLRACCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { REPORTRDY_READCLRACCW :: DISABLED => false , REPORTRDY_READCLRACCW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _REPORTRDY_READCLRACCW < 'a > { w : & 'a mut W , } impl < 'a > _REPORTRDY_READCLRACCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : REPORTRDY_READCLRACCW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( REPORTRDY_READCLRACCW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( REPORTRDY_READCLRACCW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SAMPLERDY_STOP`" ] pub enum SAMPLERDY_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl SAMPLERDY_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SAMPLERDY_STOPW :: DISABLED => false , SAMPLERDY_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _SAMPLERDY_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _SAMPLERDY_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SAMPLERDY_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( SAMPLERDY_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( SAMPLERDY_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Short-cut between REPORTRDY event and READCLRACC task." ] # [ inline ] pub fn reportrdy_readclracc ( & self ) -> REPORTRDY_READCLRACCR { REPORTRDY_READCLRACCR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Short-cut between SAMPLERDY event and STOP task." ] # [ inline ] pub fn samplerdy_stop ( & self ) -> SAMPLERDY_STOPR { SAMPLERDY_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Short-cut between REPORTRDY event and READCLRACC task." ] # [ inline ] pub fn reportrdy_readclracc ( & mut self ) -> _REPORTRDY_READCLRACCW { _REPORTRDY_READCLRACCW { w : self } } # [ doc = "Bit 1 - Short-cut between SAMPLERDY event and STOP task." ] # [ inline ] pub fn samplerdy_stop ( & mut self ) -> _SAMPLERDY_STOPW { _SAMPLERDY_STOPW { w : self } } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SAMPLERDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SAMPLERDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl SAMPLERDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SAMPLERDYR :: DISABLED => false , SAMPLERDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SAMPLERDYR { match value { false => SAMPLERDYR :: DISABLED , true => SAMPLERDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == SAMPLERDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == SAMPLERDYR :: ENABLED } } # [ doc = "Possible values of the field `REPORTRDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REPORTRDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl REPORTRDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { REPORTRDYR :: DISABLED => false , REPORTRDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> REPORTRDYR { match value { false => REPORTRDYR :: DISABLED , true => REPORTRDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == REPORTRDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == REPORTRDYR :: ENABLED } } # [ doc = "Possible values of the field `ACCOF`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ACCOFR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ACCOFR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ACCOFR :: DISABLED => false , ACCOFR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ACCOFR { match value { false => ACCOFR :: DISABLED , true => ACCOFR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ACCOFR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ACCOFR :: ENABLED } } # [ doc = "Values that can be written to the field `SAMPLERDY`" ] pub enum SAMPLERDYW { # [ doc = "Enable interrupt on write." ] SET } impl SAMPLERDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SAMPLERDYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _SAMPLERDYW < 'a > { w : & 'a mut W , } impl < 'a > _SAMPLERDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SAMPLERDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( SAMPLERDYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `REPORTRDY`" ] pub enum REPORTRDYW { # [ doc = "Enable interrupt on write." ] SET } impl REPORTRDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { REPORTRDYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _REPORTRDYW < 'a > { w : & 'a mut W , } impl < 'a > _REPORTRDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : REPORTRDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( REPORTRDYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ACCOF`" ] pub enum ACCOFW { # [ doc = "Enable interrupt on write." ] SET } impl ACCOFW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ACCOFW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _ACCOFW < 'a > { w : & 'a mut W , } impl < 'a > _ACCOFW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ACCOFW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( ACCOFW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on SAMPLERDY event." ] # [ inline ] pub fn samplerdy ( & self ) -> SAMPLERDYR { SAMPLERDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on REPORTRDY event." ] # [ inline ] pub fn reportrdy ( & self ) -> REPORTRDYR { REPORTRDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable interrupt on ACCOF event." ] # [ inline ] pub fn accof ( & self ) -> ACCOFR { ACCOFR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on SAMPLERDY event." ] # [ inline ] pub fn samplerdy ( & mut self ) -> _SAMPLERDYW { _SAMPLERDYW { w : self } } # [ doc = "Bit 1 - Enable interrupt on REPORTRDY event." ] # [ inline ] pub fn reportrdy ( & mut self ) -> _REPORTRDYW { _REPORTRDYW { w : self } } # [ doc = "Bit 2 - Enable interrupt on ACCOF event." ] # [ inline ] pub fn accof ( & mut self ) -> _ACCOFW { _ACCOFW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SAMPLERDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SAMPLERDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl SAMPLERDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { SAMPLERDYR :: DISABLED => false , SAMPLERDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> SAMPLERDYR { match value { false => SAMPLERDYR :: DISABLED , true => SAMPLERDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == SAMPLERDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == SAMPLERDYR :: ENABLED } } # [ doc = "Possible values of the field `REPORTRDY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REPORTRDYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl REPORTRDYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { REPORTRDYR :: DISABLED => false , REPORTRDYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> REPORTRDYR { match value { false => REPORTRDYR :: DISABLED , true => REPORTRDYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == REPORTRDYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == REPORTRDYR :: ENABLED } } # [ doc = "Possible values of the field `ACCOF`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ACCOFR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl ACCOFR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ACCOFR :: DISABLED => false , ACCOFR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ACCOFR { match value { false => ACCOFR :: DISABLED , true => ACCOFR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ACCOFR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ACCOFR :: ENABLED } } # [ doc = "Values that can be written to the field `SAMPLERDY`" ] pub enum SAMPLERDYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl SAMPLERDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { SAMPLERDYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _SAMPLERDYW < 'a > { w : & 'a mut W , } impl < 'a > _SAMPLERDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SAMPLERDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( SAMPLERDYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `REPORTRDY`" ] pub enum REPORTRDYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl REPORTRDYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { REPORTRDYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _REPORTRDYW < 'a > { w : & 'a mut W , } impl < 'a > _REPORTRDYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : REPORTRDYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( REPORTRDYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `ACCOF`" ] pub enum ACCOFW { # [ doc = "Disable interrupt on write." ] CLEAR } impl ACCOFW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ACCOFW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _ACCOFW < 'a > { w : & 'a mut W , } impl < 'a > _ACCOFW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ACCOFW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( ACCOFW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on SAMPLERDY event." ] # [ inline ] pub fn samplerdy ( & self ) -> SAMPLERDYR { SAMPLERDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on REPORTRDY event." ] # [ inline ] pub fn reportrdy ( & self ) -> REPORTRDYR { REPORTRDYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Disable interrupt on ACCOF event." ] # [ inline ] pub fn accof ( & self ) -> ACCOFR { ACCOFR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on SAMPLERDY event." ] # [ inline ] pub fn samplerdy ( & mut self ) -> _SAMPLERDYW { _SAMPLERDYW { w : self } } # [ doc = "Bit 1 - Disable interrupt on REPORTRDY event." ] # [ inline ] pub fn reportrdy ( & mut self ) -> _REPORTRDYW { _REPORTRDYW { w : self } } # [ doc = "Bit 2 - Disable interrupt on ACCOF event." ] # [ inline ] pub fn accof ( & mut self ) -> _ACCOFW { _ACCOFW { w : self } } } } # [ doc = "Enable the QDEC." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable the QDEC." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "Disabled QDEC." ] DISABLED , # [ doc = "Enable QDEC." ] ENABLED } impl ENABLER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ENABLER :: DISABLED => false , ENABLER :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ENABLER { match value { false => ENABLER :: DISABLED , true => ENABLER :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "Disabled QDEC." ] DISABLED , # [ doc = "Enable QDEC." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ENABLEW :: DISABLED => false , ENABLEW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disabled QDEC." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "Enable QDEC." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable or disable QDEC." ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable or disable QDEC." ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "LED output pin polarity." ] pub struct LEDPOL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "LED output pin polarity." ] pub mod ledpol { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: LEDPOL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `LEDPOL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LEDPOLR { # [ doc = "LED output is active low." ] ACTIVELOW , # [ doc = "LED output is active high." ] ACTIVEHIGH } impl LEDPOLR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { LEDPOLR :: ACTIVELOW => false , LEDPOLR :: ACTIVEHIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> LEDPOLR { match value { false => LEDPOLR :: ACTIVELOW , true => LEDPOLR :: ACTIVEHIGH , } } # [ doc = "Checks if the value of the field is `ACTIVELOW`" ] # [ inline ] pub fn is_active_low ( & self ) -> bool { * self == LEDPOLR :: ACTIVELOW } # [ doc = "Checks if the value of the field is `ACTIVEHIGH`" ] # [ inline ] pub fn is_active_high ( & self ) -> bool { * self == LEDPOLR :: ACTIVEHIGH } } # [ doc = "Values that can be written to the field `LEDPOL`" ] pub enum LEDPOLW { # [ doc = "LED output is active low." ] ACTIVELOW , # [ doc = "LED output is active high." ] ACTIVEHIGH } impl LEDPOLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { LEDPOLW :: ACTIVELOW => false , LEDPOLW :: ACTIVEHIGH => true } } } # [ doc = r" Proxy" ] pub struct _LEDPOLW < 'a > { w : & 'a mut W , } impl < 'a > _LEDPOLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : LEDPOLW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "LED output is active low." ] # [ inline ] pub fn active_low ( self ) -> & 'a mut W { self . variant ( LEDPOLW :: ACTIVELOW ) } # [ doc = "LED output is active high." ] # [ inline ] pub fn active_high ( self ) -> & 'a mut W { self . variant ( LEDPOLW :: ACTIVEHIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - LED output pin polarity." ] # [ inline ] pub fn ledpol ( & self ) -> LEDPOLR { LEDPOLR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - LED output pin polarity." ] # [ inline ] pub fn ledpol ( & mut self ) -> _LEDPOLW { _LEDPOLW { w : self } } } } # [ doc = "Sample period." ] pub struct SAMPLEPER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Sample period." ] pub mod sampleper { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SAMPLEPER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SAMPLEPER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SAMPLEPERR { # [ doc = "128us sample period." ] _128US , # [ doc = "256us sample period." ] _256US , # [ doc = "512us sample period." ] _512US , # [ doc = "1024us sample period." ] _1024US , # [ doc = "2048us sample period." ] _2048US , # [ doc = "4096us sample period." ] _4096US , # [ doc = "8192us sample period." ] _8192US , # [ doc = "16384us sample period." ] _16384US } impl SAMPLEPERR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SAMPLEPERR :: _128US => 0 , SAMPLEPERR :: _256US => 0x01 , SAMPLEPERR :: _512US => 0x02 , SAMPLEPERR :: _1024US => 0x03 , SAMPLEPERR :: _2048US => 0x04 , SAMPLEPERR :: _4096US => 0x05 , SAMPLEPERR :: _8192US => 0x06 , SAMPLEPERR :: _16384US => 0x07 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SAMPLEPERR { match value { 0 => SAMPLEPERR :: _128US , 1 => SAMPLEPERR :: _256US , 2 => SAMPLEPERR :: _512US , 3 => SAMPLEPERR :: _1024US , 4 => SAMPLEPERR :: _2048US , 5 => SAMPLEPERR :: _4096US , 6 => SAMPLEPERR :: _8192US , 7 => SAMPLEPERR :: _16384US , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `_128US`" ] # [ inline ] pub fn is_128us ( & self ) -> bool { * self == SAMPLEPERR :: _128US } # [ doc = "Checks if the value of the field is `_256US`" ] # [ inline ] pub fn is_256us ( & self ) -> bool { * self == SAMPLEPERR :: _256US } # [ doc = "Checks if the value of the field is `_512US`" ] # [ inline ] pub fn is_512us ( & self ) -> bool { * self == SAMPLEPERR :: _512US } # [ doc = "Checks if the value of the field is `_1024US`" ] # [ inline ] pub fn is_1024us ( & self ) -> bool { * self == SAMPLEPERR :: _1024US } # [ doc = "Checks if the value of the field is `_2048US`" ] # [ inline ] pub fn is_2048us ( & self ) -> bool { * self == SAMPLEPERR :: _2048US } # [ doc = "Checks if the value of the field is `_4096US`" ] # [ inline ] pub fn is_4096us ( & self ) -> bool { * self == SAMPLEPERR :: _4096US } # [ doc = "Checks if the value of the field is `_8192US`" ] # [ inline ] pub fn is_8192us ( & self ) -> bool { * self == SAMPLEPERR :: _8192US } # [ doc = "Checks if the value of the field is `_16384US`" ] # [ inline ] pub fn is_16384us ( & self ) -> bool { * self == SAMPLEPERR :: _16384US } } # [ doc = "Values that can be written to the field `SAMPLEPER`" ] pub enum SAMPLEPERW { # [ doc = "128us sample period." ] _128US , # [ doc = "256us sample period." ] _256US , # [ doc = "512us sample period." ] _512US , # [ doc = "1024us sample period." ] _1024US , # [ doc = "2048us sample period." ] _2048US , # [ doc = "4096us sample period." ] _4096US , # [ doc = "8192us sample period." ] _8192US , # [ doc = "16384us sample period." ] _16384US } impl SAMPLEPERW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SAMPLEPERW :: _128US => 0 , SAMPLEPERW :: _256US => 1 , SAMPLEPERW :: _512US => 2 , SAMPLEPERW :: _1024US => 3 , SAMPLEPERW :: _2048US => 4 , SAMPLEPERW :: _4096US => 5 , SAMPLEPERW :: _8192US => 6 , SAMPLEPERW :: _16384US => 7 } } } # [ doc = r" Proxy" ] pub struct _SAMPLEPERW < 'a > { w : & 'a mut W , } impl < 'a > _SAMPLEPERW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SAMPLEPERW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "128us sample period." ] # [ inline ] pub fn _128us ( self ) -> & 'a mut W { self . variant ( SAMPLEPERW :: _128US ) } # [ doc = "256us sample period." ] # [ inline ] pub fn _256us ( self ) -> & 'a mut W { self . variant ( SAMPLEPERW :: _256US ) } # [ doc = "512us sample period." ] # [ inline ] pub fn _512us ( self ) -> & 'a mut W { self . variant ( SAMPLEPERW :: _512US ) } # [ doc = "1024us sample period." ] # [ inline ] pub fn _1024us ( self ) -> & 'a mut W { self . variant ( SAMPLEPERW :: _1024US ) } # [ doc = "2048us sample period." ] # [ inline ] pub fn _2048us ( self ) -> & 'a mut W { self . variant ( SAMPLEPERW :: _2048US ) } # [ doc = "4096us sample period." ] # [ inline ] pub fn _4096us ( self ) -> & 'a mut W { self . variant ( SAMPLEPERW :: _4096US ) } # [ doc = "8192us sample period." ] # [ inline ] pub fn _8192us ( self ) -> & 'a mut W { self . variant ( SAMPLEPERW :: _8192US ) } # [ doc = "16384us sample period." ] # [ inline ] pub fn _16384us ( self ) -> & 'a mut W { self . variant ( SAMPLEPERW :: _16384US ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Sample period." ] # [ inline ] pub fn sampleper ( & self ) -> SAMPLEPERR { SAMPLEPERR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Sample period." ] # [ inline ] pub fn sampleper ( & mut self ) -> _SAMPLEPERW { _SAMPLEPERW { w : self } } } } # [ doc = "Motion sample value." ] pub struct SAMPLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Motion sample value." ] pub mod sample { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: SAMPLE { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct SAMPLER { bits : u32 , } impl SAMPLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:31 - Last sample taken in compliment to 2." ] # [ inline ] pub fn sample ( & self ) -> SAMPLER { let bits = { const MASK : u32 = 0xffff_ffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u32 } ; SAMPLER { bits } } } } # [ doc = "Number of samples to generate an EVENT_REPORTRDY." ] pub struct REPORTPER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Number of samples to generate an EVENT_REPORTRDY." ] pub mod reportper { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: REPORTPER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `REPORTPER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REPORTPERR { # [ doc = "10 samples per report." ] _10SMPL , # [ doc = "40 samples per report." ] _40SMPL , # [ doc = "80 samples per report." ] _80SMPL , # [ doc = "120 samples per report." ] _120SMPL , # [ doc = "160 samples per report." ] _160SMPL , # [ doc = "200 samples per report." ] _200SMPL , # [ doc = "240 samples per report." ] _240SMPL , # [ doc = "280 samples per report." ] _280SMPL } impl REPORTPERR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { REPORTPERR :: _10SMPL => 0 , REPORTPERR :: _40SMPL => 0x01 , REPORTPERR :: _80SMPL => 0x02 , REPORTPERR :: _120SMPL => 0x03 , REPORTPERR :: _160SMPL => 0x04 , REPORTPERR :: _200SMPL => 0x05 , REPORTPERR :: _240SMPL => 0x06 , REPORTPERR :: _280SMPL => 0x07 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> REPORTPERR { match value { 0 => REPORTPERR :: _10SMPL , 1 => REPORTPERR :: _40SMPL , 2 => REPORTPERR :: _80SMPL , 3 => REPORTPERR :: _120SMPL , 4 => REPORTPERR :: _160SMPL , 5 => REPORTPERR :: _200SMPL , 6 => REPORTPERR :: _240SMPL , 7 => REPORTPERR :: _280SMPL , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `_10SMPL`" ] # [ inline ] pub fn is_10smpl ( & self ) -> bool { * self == REPORTPERR :: _10SMPL } # [ doc = "Checks if the value of the field is `_40SMPL`" ] # [ inline ] pub fn is_40smpl ( & self ) -> bool { * self == REPORTPERR :: _40SMPL } # [ doc = "Checks if the value of the field is `_80SMPL`" ] # [ inline ] pub fn is_80smpl ( & self ) -> bool { * self == REPORTPERR :: _80SMPL } # [ doc = "Checks if the value of the field is `_120SMPL`" ] # [ inline ] pub fn is_120smpl ( & self ) -> bool { * self == REPORTPERR :: _120SMPL } # [ doc = "Checks if the value of the field is `_160SMPL`" ] # [ inline ] pub fn is_160smpl ( & self ) -> bool { * self == REPORTPERR :: _160SMPL } # [ doc = "Checks if the value of the field is `_200SMPL`" ] # [ inline ] pub fn is_200smpl ( & self ) -> bool { * self == REPORTPERR :: _200SMPL } # [ doc = "Checks if the value of the field is `_240SMPL`" ] # [ inline ] pub fn is_240smpl ( & self ) -> bool { * self == REPORTPERR :: _240SMPL } # [ doc = "Checks if the value of the field is `_280SMPL`" ] # [ inline ] pub fn is_280smpl ( & self ) -> bool { * self == REPORTPERR :: _280SMPL } } # [ doc = "Values that can be written to the field `REPORTPER`" ] pub enum REPORTPERW { # [ doc = "10 samples per report." ] _10SMPL , # [ doc = "40 samples per report." ] _40SMPL , # [ doc = "80 samples per report." ] _80SMPL , # [ doc = "120 samples per report." ] _120SMPL , # [ doc = "160 samples per report." ] _160SMPL , # [ doc = "200 samples per report." ] _200SMPL , # [ doc = "240 samples per report." ] _240SMPL , # [ doc = "280 samples per report." ] _280SMPL } impl REPORTPERW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { REPORTPERW :: _10SMPL => 0 , REPORTPERW :: _40SMPL => 1 , REPORTPERW :: _80SMPL => 2 , REPORTPERW :: _120SMPL => 3 , REPORTPERW :: _160SMPL => 4 , REPORTPERW :: _200SMPL => 5 , REPORTPERW :: _240SMPL => 6 , REPORTPERW :: _280SMPL => 7 } } } # [ doc = r" Proxy" ] pub struct _REPORTPERW < 'a > { w : & 'a mut W , } impl < 'a > _REPORTPERW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : REPORTPERW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "10 samples per report." ] # [ inline ] pub fn _10smpl ( self ) -> & 'a mut W { self . variant ( REPORTPERW :: _10SMPL ) } # [ doc = "40 samples per report." ] # [ inline ] pub fn _40smpl ( self ) -> & 'a mut W { self . variant ( REPORTPERW :: _40SMPL ) } # [ doc = "80 samples per report." ] # [ inline ] pub fn _80smpl ( self ) -> & 'a mut W { self . variant ( REPORTPERW :: _80SMPL ) } # [ doc = "120 samples per report." ] # [ inline ] pub fn _120smpl ( self ) -> & 'a mut W { self . variant ( REPORTPERW :: _120SMPL ) } # [ doc = "160 samples per report." ] # [ inline ] pub fn _160smpl ( self ) -> & 'a mut W { self . variant ( REPORTPERW :: _160SMPL ) } # [ doc = "200 samples per report." ] # [ inline ] pub fn _200smpl ( self ) -> & 'a mut W { self . variant ( REPORTPERW :: _200SMPL ) } # [ doc = "240 samples per report." ] # [ inline ] pub fn _240smpl ( self ) -> & 'a mut W { self . variant ( REPORTPERW :: _240SMPL ) } # [ doc = "280 samples per report." ] # [ inline ] pub fn _280smpl ( self ) -> & 'a mut W { self . variant ( REPORTPERW :: _280SMPL ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Number of samples to generate an EVENT_REPORTRDY." ] # [ inline ] pub fn reportper ( & self ) -> REPORTPERR { REPORTPERR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Number of samples to generate an EVENT_REPORTRDY." ] # [ inline ] pub fn reportper ( & mut self ) -> _REPORTPERW { _REPORTPERW { w : self } } } } # [ doc = "Accumulated valid transitions register." ] pub struct ACC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Accumulated valid transitions register." ] pub mod acc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: ACC { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } } # [ doc = "Snapshot of ACC register. Value generated by the TASKS_READCLEACC task." ] pub struct ACCREAD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Snapshot of ACC register. Value generated by the TASKS_READCLEACC task." ] pub mod accread { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: ACCREAD { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } } # [ doc = "Pin select for LED output." ] pub struct PSELLED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for LED output." ] pub mod pselled { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELLED { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for phase A input." ] pub struct PSELA { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for phase A input." ] pub mod psela { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELA { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pin select for phase B input." ] pub struct PSELB { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pin select for phase B input." ] pub mod pselb { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSELB { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0xffff_ffff } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Enable debouncer input filters." ] pub struct DBFEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable debouncer input filters." ] pub mod dbfen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DBFEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `DBFEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DBFENR { # [ doc = "Debounce input filters disabled." ] DISABLED , # [ doc = "Debounce input filters enabled." ] ENABLED } impl DBFENR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DBFENR :: DISABLED => false , DBFENR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DBFENR { match value { false => DBFENR :: DISABLED , true => DBFENR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DBFENR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DBFENR :: ENABLED } } # [ doc = "Values that can be written to the field `DBFEN`" ] pub enum DBFENW { # [ doc = "Debounce input filters disabled." ] DISABLED , # [ doc = "Debounce input filters enabled." ] ENABLED } impl DBFENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DBFENW :: DISABLED => false , DBFENW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _DBFENW < 'a > { w : & 'a mut W , } impl < 'a > _DBFENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DBFENW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Debounce input filters disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( DBFENW :: DISABLED ) } # [ doc = "Debounce input filters enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( DBFENW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable debounce input filters." ] # [ inline ] pub fn dbfen ( & self ) -> DBFENR { DBFENR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable debounce input filters." ] # [ inline ] pub fn dbfen ( & mut self ) -> _DBFENW { _DBFENW { w : self } } } } # [ doc = "Time LED is switched ON before the sample." ] pub struct LEDPRE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Time LED is switched ON before the sample." ] pub mod ledpre { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: LEDPRE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct LEDPRER { bits : u8 , } impl LEDPRER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _LEDPREW < 'a > { w : & 'a mut W , } impl < 'a > _LEDPREW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Period in us the LED in switched on prior to sampling." ] # [ inline ] pub fn ledpre ( & self ) -> LEDPRER { let bits = { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; LEDPRER { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Period in us the LED in switched on prior to sampling." ] # [ inline ] pub fn ledpre ( & mut self ) -> _LEDPREW { _LEDPREW { w : self } } } } # [ doc = "Accumulated double (error) transitions register." ] pub struct ACCDBL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Accumulated double (error) transitions register." ] pub mod accdbl { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: ACCDBL { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct ACCDBLR { bits : u8 , } impl ACCDBLR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:3 - Accumulated double (error) transitions." ] # [ inline ] pub fn accdbl ( & self ) -> ACCDBLR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; ACCDBLR { bits } } } } # [ doc = "Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task." ] pub struct ACCDBLREAD { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task." ] pub mod accdblread { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: ACCDBLREAD { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct ACCDBLREADR { bits : u8 , } impl ACCDBLREADR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:3 - Snapshot of accumulated double (error) transitions." ] # [ inline ] pub fn accdblread ( & self ) -> ACCDBLREADR { let bits = { const MASK : u8 = 0x0f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; ACCDBLREADR { bits } } } } } # [ doc = "Wakeup Comparator." ] pub struct WUCOMP { _marker : PhantomData < * const ( ) > } unsafe impl Send for WUCOMP { } impl WUCOMP { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const wucomp :: RegisterBlock { 0x4001_3000 as * const _ } } impl Deref for WUCOMP { type Target = wucomp :: RegisterBlock ; fn deref ( & self ) -> & wucomp :: RegisterBlock { unsafe { & * WUCOMP :: ptr ( ) } } } # [ doc = "Wakeup Comparator." ] pub mod wucomp { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start the comparator." ] pub tasks_start : TASKS_START , # [ doc = "0x04 - Stop the comparator." ] pub tasks_stop : TASKS_STOP , # [ doc = "0x08 - Sample comparator value." ] pub tasks_sample : TASKS_SAMPLE , _reserved0 : [ u8 ; 244usize ] , # [ doc = "0x100 - WUCOMP is ready and output is valid." ] pub events_ready : EVENTS_READY , # [ doc = "0x104 - Input voltage crossed the threshold going down." ] pub events_down : EVENTS_DOWN , # [ doc = "0x108 - Input voltage crossed the threshold going up." ] pub events_up : EVENTS_UP , # [ doc = "0x10c - Input voltage crossed the threshold in any direction." ] pub events_cross : EVENTS_CROSS , _reserved1 : [ u8 ; 240usize ] , # [ doc = "0x200 - Shortcut for the WUCOMP." ] pub shorts : SHORTS , _reserved2 : [ u8 ; 256usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 244usize ] , # [ doc = "0x400 - Result of last compare." ] pub result : RESULT , _reserved4 : [ u8 ; 252usize ] , # [ doc = "0x500 - Enable the WUCOMP." ] pub enable : ENABLE , # [ doc = "0x504 - Input pin select." ] pub psel : PSEL , # [ doc = "0x508 - Reference select." ] pub refsel : REFSEL , # [ doc = "0x50c - External reference select." ] pub extrefsel : EXTREFSEL , _reserved5 : [ u8 ; 16usize ] , # [ doc = "0x520 - Analog detect configuration." ] pub anadetect : ANADETECT , } # [ doc = "Start the comparator." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start the comparator." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop the comparator." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop the comparator." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Sample comparator value." ] pub struct TASKS_SAMPLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Sample comparator value." ] pub mod tasks_sample { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_SAMPLE { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "WUCOMP is ready and output is valid." ] pub struct EVENTS_READY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "WUCOMP is ready and output is valid." ] pub mod events_ready { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_READY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Input voltage crossed the threshold going down." ] pub struct EVENTS_DOWN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Input voltage crossed the threshold going down." ] pub mod events_down { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_DOWN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Input voltage crossed the threshold going up." ] pub struct EVENTS_UP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Input voltage crossed the threshold going up." ] pub mod events_up { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_UP { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Input voltage crossed the threshold in any direction." ] pub struct EVENTS_CROSS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Input voltage crossed the threshold in any direction." ] pub mod events_cross { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_CROSS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Shortcut for the WUCOMP." ] pub struct SHORTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Shortcut for the WUCOMP." ] pub mod shorts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SHORTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY_SAMPLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READY_SAMPLER { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_SAMPLER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READY_SAMPLER :: DISABLED => false , READY_SAMPLER :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READY_SAMPLER { match value { false => READY_SAMPLER :: DISABLED , true => READY_SAMPLER :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READY_SAMPLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READY_SAMPLER :: ENABLED } } # [ doc = "Possible values of the field `READY_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READY_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READY_STOPR :: DISABLED => false , READY_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READY_STOPR { match value { false => READY_STOPR :: DISABLED , true => READY_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READY_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READY_STOPR :: ENABLED } } # [ doc = "Possible values of the field `DOWN_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DOWN_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DOWN_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DOWN_STOPR :: DISABLED => false , DOWN_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DOWN_STOPR { match value { false => DOWN_STOPR :: DISABLED , true => DOWN_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DOWN_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DOWN_STOPR :: ENABLED } } # [ doc = "Possible values of the field `UP_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UP_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl UP_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { UP_STOPR :: DISABLED => false , UP_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> UP_STOPR { match value { false => UP_STOPR :: DISABLED , true => UP_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == UP_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == UP_STOPR :: ENABLED } } # [ doc = "Possible values of the field `CROSS_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CROSS_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl CROSS_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CROSS_STOPR :: DISABLED => false , CROSS_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CROSS_STOPR { match value { false => CROSS_STOPR :: DISABLED , true => CROSS_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CROSS_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CROSS_STOPR :: ENABLED } } # [ doc = "Values that can be written to the field `READY_SAMPLE`" ] pub enum READY_SAMPLEW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_SAMPLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READY_SAMPLEW :: DISABLED => false , READY_SAMPLEW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _READY_SAMPLEW < 'a > { w : & 'a mut W , } impl < 'a > _READY_SAMPLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READY_SAMPLEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( READY_SAMPLEW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( READY_SAMPLEW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `READY_STOP`" ] pub enum READY_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READY_STOPW :: DISABLED => false , READY_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _READY_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _READY_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READY_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( READY_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( READY_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DOWN_STOP`" ] pub enum DOWN_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DOWN_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DOWN_STOPW :: DISABLED => false , DOWN_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _DOWN_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _DOWN_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DOWN_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( DOWN_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( DOWN_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `UP_STOP`" ] pub enum UP_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl UP_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { UP_STOPW :: DISABLED => false , UP_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _UP_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _UP_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : UP_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( UP_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( UP_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CROSS_STOP`" ] pub enum CROSS_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl CROSS_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CROSS_STOPW :: DISABLED => false , CROSS_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CROSS_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _CROSS_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CROSS_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CROSS_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CROSS_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Short-cut between READY event and SAMPLE task." ] # [ inline ] pub fn ready_sample ( & self ) -> READY_SAMPLER { READY_SAMPLER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Short-cut between RADY event and STOP task." ] # [ inline ] pub fn ready_stop ( & self ) -> READY_STOPR { READY_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Short-cut between DOWN event and STOP task." ] # [ inline ] pub fn down_stop ( & self ) -> DOWN_STOPR { DOWN_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Short-cut between UP event and STOP task." ] # [ inline ] pub fn up_stop ( & self ) -> UP_STOPR { UP_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Short-cut between CROSS event and STOP task." ] # [ inline ] pub fn cross_stop ( & self ) -> CROSS_STOPR { CROSS_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Short-cut between READY event and SAMPLE task." ] # [ inline ] pub fn ready_sample ( & mut self ) -> _READY_SAMPLEW { _READY_SAMPLEW { w : self } } # [ doc = "Bit 1 - Short-cut between RADY event and STOP task." ] # [ inline ] pub fn ready_stop ( & mut self ) -> _READY_STOPW { _READY_STOPW { w : self } } # [ doc = "Bit 2 - Short-cut between DOWN event and STOP task." ] # [ inline ] pub fn down_stop ( & mut self ) -> _DOWN_STOPW { _DOWN_STOPW { w : self } } # [ doc = "Bit 3 - Short-cut between UP event and STOP task." ] # [ inline ] pub fn up_stop ( & mut self ) -> _UP_STOPW { _UP_STOPW { w : self } } # [ doc = "Bit 4 - Short-cut between CROSS event and STOP task." ] # [ inline ] pub fn cross_stop ( & mut self ) -> _CROSS_STOPW { _CROSS_STOPW { w : self } } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl READYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READYR :: DISABLED => false , READYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READYR { match value { false => READYR :: DISABLED , true => READYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READYR :: ENABLED } } # [ doc = "Possible values of the field `DOWN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DOWNR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DOWNR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DOWNR :: DISABLED => false , DOWNR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DOWNR { match value { false => DOWNR :: DISABLED , true => DOWNR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DOWNR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DOWNR :: ENABLED } } # [ doc = "Possible values of the field `UP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UPR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl UPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { UPR :: DISABLED => false , UPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> UPR { match value { false => UPR :: DISABLED , true => UPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == UPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == UPR :: ENABLED } } # [ doc = "Possible values of the field `CROSS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CROSSR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl CROSSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CROSSR :: DISABLED => false , CROSSR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CROSSR { match value { false => CROSSR :: DISABLED , true => CROSSR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CROSSR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CROSSR :: ENABLED } } # [ doc = "Values that can be written to the field `READY`" ] pub enum READYW { # [ doc = "Enable interrupt on write." ] SET } impl READYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _READYW < 'a > { w : & 'a mut W , } impl < 'a > _READYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( READYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DOWN`" ] pub enum DOWNW { # [ doc = "Enable interrupt on write." ] SET } impl DOWNW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DOWNW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _DOWNW < 'a > { w : & 'a mut W , } impl < 'a > _DOWNW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DOWNW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( DOWNW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `UP`" ] pub enum UPW { # [ doc = "Enable interrupt on write." ] SET } impl UPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { UPW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _UPW < 'a > { w : & 'a mut W , } impl < 'a > _UPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : UPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( UPW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CROSS`" ] pub enum CROSSW { # [ doc = "Enable interrupt on write." ] SET } impl CROSSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CROSSW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CROSSW < 'a > { w : & 'a mut W , } impl < 'a > _CROSSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CROSSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CROSSW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on READY event." ] # [ inline ] pub fn ready ( & self ) -> READYR { READYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on DOWN event." ] # [ inline ] pub fn down ( & self ) -> DOWNR { DOWNR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable interrupt on UP event." ] # [ inline ] pub fn up ( & self ) -> UPR { UPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable interrupt on CROSS event." ] # [ inline ] pub fn cross ( & self ) -> CROSSR { CROSSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on READY event." ] # [ inline ] pub fn ready ( & mut self ) -> _READYW { _READYW { w : self } } # [ doc = "Bit 1 - Enable interrupt on DOWN event." ] # [ inline ] pub fn down ( & mut self ) -> _DOWNW { _DOWNW { w : self } } # [ doc = "Bit 2 - Enable interrupt on UP event." ] # [ inline ] pub fn up ( & mut self ) -> _UPW { _UPW { w : self } } # [ doc = "Bit 3 - Enable interrupt on CROSS event." ] # [ inline ] pub fn cross ( & mut self ) -> _CROSSW { _CROSSW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl READYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READYR :: DISABLED => false , READYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READYR { match value { false => READYR :: DISABLED , true => READYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READYR :: ENABLED } } # [ doc = "Possible values of the field `DOWN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DOWNR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DOWNR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DOWNR :: DISABLED => false , DOWNR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DOWNR { match value { false => DOWNR :: DISABLED , true => DOWNR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DOWNR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DOWNR :: ENABLED } } # [ doc = "Possible values of the field `UP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UPR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl UPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { UPR :: DISABLED => false , UPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> UPR { match value { false => UPR :: DISABLED , true => UPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == UPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == UPR :: ENABLED } } # [ doc = "Possible values of the field `CROSS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CROSSR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl CROSSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CROSSR :: DISABLED => false , CROSSR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CROSSR { match value { false => CROSSR :: DISABLED , true => CROSSR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CROSSR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CROSSR :: ENABLED } } # [ doc = "Values that can be written to the field `READY`" ] pub enum READYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl READYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _READYW < 'a > { w : & 'a mut W , } impl < 'a > _READYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( READYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DOWN`" ] pub enum DOWNW { # [ doc = "Disable interrupt on write." ] CLEAR } impl DOWNW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DOWNW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _DOWNW < 'a > { w : & 'a mut W , } impl < 'a > _DOWNW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DOWNW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( DOWNW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `UP`" ] pub enum UPW { # [ doc = "Disable interrupt on write." ] CLEAR } impl UPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { UPW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _UPW < 'a > { w : & 'a mut W , } impl < 'a > _UPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : UPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( UPW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CROSS`" ] pub enum CROSSW { # [ doc = "Disable interrupt on write." ] CLEAR } impl CROSSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CROSSW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CROSSW < 'a > { w : & 'a mut W , } impl < 'a > _CROSSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CROSSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CROSSW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on READY event." ] # [ inline ] pub fn ready ( & self ) -> READYR { READYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on DOWN event." ] # [ inline ] pub fn down ( & self ) -> DOWNR { DOWNR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Disable interrupt on UP event." ] # [ inline ] pub fn up ( & self ) -> UPR { UPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Disable interrupt on CROSS event." ] # [ inline ] pub fn cross ( & self ) -> CROSSR { CROSSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on READY event." ] # [ inline ] pub fn ready ( & mut self ) -> _READYW { _READYW { w : self } } # [ doc = "Bit 1 - Disable interrupt on DOWN event." ] # [ inline ] pub fn down ( & mut self ) -> _DOWNW { _DOWNW { w : self } } # [ doc = "Bit 2 - Disable interrupt on UP event." ] # [ inline ] pub fn up ( & mut self ) -> _UPW { _UPW { w : self } } # [ doc = "Bit 3 - Disable interrupt on CROSS event." ] # [ inline ] pub fn cross ( & mut self ) -> _CROSSW { _CROSSW { w : self } } } } # [ doc = "Result of last compare." ] pub struct RESULT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Result of last compare." ] pub mod result { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: RESULT { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `RESULT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RESULTR { # [ doc = "Input voltage is bellow the reference threshold." ] BELLOW , # [ doc = "Input voltage is above the reference threshold." ] ABOVE } impl RESULTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RESULTR :: BELLOW => false , RESULTR :: ABOVE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RESULTR { match value { false => RESULTR :: BELLOW , true => RESULTR :: ABOVE , } } # [ doc = "Checks if the value of the field is `BELLOW`" ] # [ inline ] pub fn is_bellow ( & self ) -> bool { * self == RESULTR :: BELLOW } # [ doc = "Checks if the value of the field is `ABOVE`" ] # [ inline ] pub fn is_above ( & self ) -> bool { * self == RESULTR :: ABOVE } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Result of last compare. Decision point SAMPLE task." ] # [ inline ] pub fn result ( & self ) -> RESULTR { RESULTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "Enable the WUCOMP." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable the WUCOMP." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "Disabled WUCOMP." ] DISABLED , # [ doc = "Enable WUCOMP." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ENABLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ENABLER :: DISABLED => 0 , ENABLER :: ENABLED => 0x01 , ENABLER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ENABLER { match value { 0 => ENABLER :: DISABLED , 1 => ENABLER :: ENABLED , i => ENABLER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "Disabled WUCOMP." ] DISABLED , # [ doc = "Enable WUCOMP." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ENABLEW :: DISABLED => 0 , ENABLEW :: ENABLED => 1 } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled WUCOMP." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "Enable WUCOMP." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Enable or disable WUCOMP." ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Enable or disable WUCOMP." ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "Input pin select." ] pub struct PSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Input pin select." ] pub mod psel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PSELR { # [ doc = "Use analog input 0 as analog input." ] ANALOGINPUT0 , # [ doc = "Use analog input 1 as analog input." ] ANALOGINPUT1 , # [ doc = "Use analog input 2 as analog input." ] ANALOGINPUT2 , # [ doc = "Use analog input 3 as analog input." ] ANALOGINPUT3 , # [ doc = "Use analog input 4 as analog input." ] ANALOGINPUT4 , # [ doc = "Use analog input 5 as analog input." ] ANALOGINPUT5 , # [ doc = "Use analog input 6 as analog input." ] ANALOGINPUT6 , # [ doc = "Use analog input 7 as analog input." ] ANALOGINPUT7 } impl PSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PSELR :: ANALOGINPUT0 => 0 , PSELR :: ANALOGINPUT1 => 0x01 , PSELR :: ANALOGINPUT2 => 0x02 , PSELR :: ANALOGINPUT3 => 0x03 , PSELR :: ANALOGINPUT4 => 0x04 , PSELR :: ANALOGINPUT5 => 0x05 , PSELR :: ANALOGINPUT6 => 0x06 , PSELR :: ANALOGINPUT7 => 0x07 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PSELR { match value { 0 => PSELR :: ANALOGINPUT0 , 1 => PSELR :: ANALOGINPUT1 , 2 => PSELR :: ANALOGINPUT2 , 3 => PSELR :: ANALOGINPUT3 , 4 => PSELR :: ANALOGINPUT4 , 5 => PSELR :: ANALOGINPUT5 , 6 => PSELR :: ANALOGINPUT6 , 7 => PSELR :: ANALOGINPUT7 , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `ANALOGINPUT0`" ] # [ inline ] pub fn is_analog_input0 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT0 } # [ doc = "Checks if the value of the field is `ANALOGINPUT1`" ] # [ inline ] pub fn is_analog_input1 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT1 } # [ doc = "Checks if the value of the field is `ANALOGINPUT2`" ] # [ inline ] pub fn is_analog_input2 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT2 } # [ doc = "Checks if the value of the field is `ANALOGINPUT3`" ] # [ inline ] pub fn is_analog_input3 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT3 } # [ doc = "Checks if the value of the field is `ANALOGINPUT4`" ] # [ inline ] pub fn is_analog_input4 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT4 } # [ doc = "Checks if the value of the field is `ANALOGINPUT5`" ] # [ inline ] pub fn is_analog_input5 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT5 } # [ doc = "Checks if the value of the field is `ANALOGINPUT6`" ] # [ inline ] pub fn is_analog_input6 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT6 } # [ doc = "Checks if the value of the field is `ANALOGINPUT7`" ] # [ inline ] pub fn is_analog_input7 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT7 } } # [ doc = "Values that can be written to the field `PSEL`" ] pub enum PSELW { # [ doc = "Use analog input 0 as analog input." ] ANALOGINPUT0 , # [ doc = "Use analog input 1 as analog input." ] ANALOGINPUT1 , # [ doc = "Use analog input 2 as analog input." ] ANALOGINPUT2 , # [ doc = "Use analog input 3 as analog input." ] ANALOGINPUT3 , # [ doc = "Use analog input 4 as analog input." ] ANALOGINPUT4 , # [ doc = "Use analog input 5 as analog input." ] ANALOGINPUT5 , # [ doc = "Use analog input 6 as analog input." ] ANALOGINPUT6 , # [ doc = "Use analog input 7 as analog input." ] ANALOGINPUT7 } impl PSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PSELW :: ANALOGINPUT0 => 0 , PSELW :: ANALOGINPUT1 => 1 , PSELW :: ANALOGINPUT2 => 2 , PSELW :: ANALOGINPUT3 => 3 , PSELW :: ANALOGINPUT4 => 4 , PSELW :: ANALOGINPUT5 => 5 , PSELW :: ANALOGINPUT6 => 6 , PSELW :: ANALOGINPUT7 => 7 } } } # [ doc = r" Proxy" ] pub struct _PSELW < 'a > { w : & 'a mut W , } impl < 'a > _PSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PSELW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Use analog input 0 as analog input." ] # [ inline ] pub fn analog_input0 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT0 ) } # [ doc = "Use analog input 1 as analog input." ] # [ inline ] pub fn analog_input1 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT1 ) } # [ doc = "Use analog input 2 as analog input." ] # [ inline ] pub fn analog_input2 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT2 ) } # [ doc = "Use analog input 3 as analog input." ] # [ inline ] pub fn analog_input3 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT3 ) } # [ doc = "Use analog input 4 as analog input." ] # [ inline ] pub fn analog_input4 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT4 ) } # [ doc = "Use analog input 5 as analog input." ] # [ inline ] pub fn analog_input5 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT5 ) } # [ doc = "Use analog input 6 as analog input." ] # [ inline ] pub fn analog_input6 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT6 ) } # [ doc = "Use analog input 7 as analog input." ] # [ inline ] pub fn analog_input7 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT7 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Analog input pin select." ] # [ inline ] pub fn psel ( & self ) -> PSELR { PSELR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Analog input pin select." ] # [ inline ] pub fn psel ( & mut self ) -> _PSELW { _PSELW { w : self } } } } # [ doc = "Reference select." ] pub struct REFSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Reference select." ] pub mod refsel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: REFSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `REFSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFSELR { # [ doc = "Use analog supply with a 1/8 prescaler as reference." ] SUPPLYONEEIGHTHPRESCALING , # [ doc = "Use analog supply with a 2/8 prescaler as reference." ] SUPPLYTWOEIGHTHSPRESCALING , # [ doc = "Use analog supply with a 3/8 prescaler as reference." ] SUPPLYTHREEEIGHTHSPRESCALING , # [ doc = "Use analog supply with a 4/8 prescaler as reference." ] SUPPLYFOUREIGHTHSPRESCALING , # [ doc = "Use analog supply with a 5/8 prescaler as reference." ] SUPPLYFIVEEIGHTHSPRESCALING , # [ doc = "Use analog supply with a 6/8 prescaler as reference." ] SUPPLYSIXEIGHTHSPRESCALING , # [ doc = "Use analog supply with a 7/8 prescaler as reference." ] SUPPLYSEVENEIGHTHSPRESCALING , # [ doc = "Use external analog reference as reference." ] AREF } impl REFSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { REFSELR :: SUPPLYONEEIGHTHPRESCALING => 0 , REFSELR :: SUPPLYTWOEIGHTHSPRESCALING => 0x01 , REFSELR :: SUPPLYTHREEEIGHTHSPRESCALING => 0x02 , REFSELR :: SUPPLYFOUREIGHTHSPRESCALING => 0x03 , REFSELR :: SUPPLYFIVEEIGHTHSPRESCALING => 0x04 , REFSELR :: SUPPLYSIXEIGHTHSPRESCALING => 0x05 , REFSELR :: SUPPLYSEVENEIGHTHSPRESCALING => 0x06 , REFSELR :: AREF => 0x07 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> REFSELR { match value { 0 => REFSELR :: SUPPLYONEEIGHTHPRESCALING , 1 => REFSELR :: SUPPLYTWOEIGHTHSPRESCALING , 2 => REFSELR :: SUPPLYTHREEEIGHTHSPRESCALING , 3 => REFSELR :: SUPPLYFOUREIGHTHSPRESCALING , 4 => REFSELR :: SUPPLYFIVEEIGHTHSPRESCALING , 5 => REFSELR :: SUPPLYSIXEIGHTHSPRESCALING , 6 => REFSELR :: SUPPLYSEVENEIGHTHSPRESCALING , 7 => REFSELR :: AREF , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `SUPPLYONEEIGHTHPRESCALING`" ] # [ inline ] pub fn is_supply_one_eighth_prescaling ( & self ) -> bool { * self == REFSELR :: SUPPLYONEEIGHTHPRESCALING } # [ doc = "Checks if the value of the field is `SUPPLYTWOEIGHTHSPRESCALING`" ] # [ inline ] pub fn is_supply_two_eighths_prescaling ( & self ) -> bool { * self == REFSELR :: SUPPLYTWOEIGHTHSPRESCALING } # [ doc = "Checks if the value of the field is `SUPPLYTHREEEIGHTHSPRESCALING`" ] # [ inline ] pub fn is_supply_three_eighths_prescaling ( & self ) -> bool { * self == REFSELR :: SUPPLYTHREEEIGHTHSPRESCALING } # [ doc = "Checks if the value of the field is `SUPPLYFOUREIGHTHSPRESCALING`" ] # [ inline ] pub fn is_supply_four_eighths_prescaling ( & self ) -> bool { * self == REFSELR :: SUPPLYFOUREIGHTHSPRESCALING } # [ doc = "Checks if the value of the field is `SUPPLYFIVEEIGHTHSPRESCALING`" ] # [ inline ] pub fn is_supply_five_eighths_prescaling ( & self ) -> bool { * self == REFSELR :: SUPPLYFIVEEIGHTHSPRESCALING } # [ doc = "Checks if the value of the field is `SUPPLYSIXEIGHTHSPRESCALING`" ] # [ inline ] pub fn is_supply_six_eighths_prescaling ( & self ) -> bool { * self == REFSELR :: SUPPLYSIXEIGHTHSPRESCALING } # [ doc = "Checks if the value of the field is `SUPPLYSEVENEIGHTHSPRESCALING`" ] # [ inline ] pub fn is_supply_seven_eighths_prescaling ( & self ) -> bool { * self == REFSELR :: SUPPLYSEVENEIGHTHSPRESCALING } # [ doc = "Checks if the value of the field is `AREF`" ] # [ inline ] pub fn is_aref ( & self ) -> bool { * self == REFSELR :: AREF } } # [ doc = "Values that can be written to the field `REFSEL`" ] pub enum REFSELW { # [ doc = "Use analog supply with a 1/8 prescaler as reference." ] SUPPLYONEEIGHTHPRESCALING , # [ doc = "Use analog supply with a 2/8 prescaler as reference." ] SUPPLYTWOEIGHTHSPRESCALING , # [ doc = "Use analog supply with a 3/8 prescaler as reference." ] SUPPLYTHREEEIGHTHSPRESCALING , # [ doc = "Use analog supply with a 4/8 prescaler as reference." ] SUPPLYFOUREIGHTHSPRESCALING , # [ doc = "Use analog supply with a 5/8 prescaler as reference." ] SUPPLYFIVEEIGHTHSPRESCALING , # [ doc = "Use analog supply with a 6/8 prescaler as reference." ] SUPPLYSIXEIGHTHSPRESCALING , # [ doc = "Use analog supply with a 7/8 prescaler as reference." ] SUPPLYSEVENEIGHTHSPRESCALING , # [ doc = "Use external analog reference as reference." ] AREF } impl REFSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { REFSELW :: SUPPLYONEEIGHTHPRESCALING => 0 , REFSELW :: SUPPLYTWOEIGHTHSPRESCALING => 1 , REFSELW :: SUPPLYTHREEEIGHTHSPRESCALING => 2 , REFSELW :: SUPPLYFOUREIGHTHSPRESCALING => 3 , REFSELW :: SUPPLYFIVEEIGHTHSPRESCALING => 4 , REFSELW :: SUPPLYSIXEIGHTHSPRESCALING => 5 , REFSELW :: SUPPLYSEVENEIGHTHSPRESCALING => 6 , REFSELW :: AREF => 7 } } } # [ doc = r" Proxy" ] pub struct _REFSELW < 'a > { w : & 'a mut W , } impl < 'a > _REFSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : REFSELW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Use analog supply with a 1/8 prescaler as reference." ] # [ inline ] pub fn supply_one_eighth_prescaling ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLYONEEIGHTHPRESCALING ) } # [ doc = "Use analog supply with a 2/8 prescaler as reference." ] # [ inline ] pub fn supply_two_eighths_prescaling ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLYTWOEIGHTHSPRESCALING ) } # [ doc = "Use analog supply with a 3/8 prescaler as reference." ] # [ inline ] pub fn supply_three_eighths_prescaling ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLYTHREEEIGHTHSPRESCALING ) } # [ doc = "Use analog supply with a 4/8 prescaler as reference." ] # [ inline ] pub fn supply_four_eighths_prescaling ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLYFOUREIGHTHSPRESCALING ) } # [ doc = "Use analog supply with a 5/8 prescaler as reference." ] # [ inline ] pub fn supply_five_eighths_prescaling ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLYFIVEEIGHTHSPRESCALING ) } # [ doc = "Use analog supply with a 6/8 prescaler as reference." ] # [ inline ] pub fn supply_six_eighths_prescaling ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLYSIXEIGHTHSPRESCALING ) } # [ doc = "Use analog supply with a 7/8 prescaler as reference." ] # [ inline ] pub fn supply_seven_eighths_prescaling ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLYSEVENEIGHTHSPRESCALING ) } # [ doc = "Use external analog reference as reference." ] # [ inline ] pub fn aref ( self ) -> & 'a mut W { self . variant ( REFSELW :: AREF ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Reference select." ] # [ inline ] pub fn refsel ( & self ) -> REFSELR { REFSELR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Reference select." ] # [ inline ] pub fn refsel ( & mut self ) -> _REFSELW { _REFSELW { w : self } } } } # [ doc = "External reference select." ] pub struct EXTREFSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "External reference select." ] pub mod extrefsel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EXTREFSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `EXTREFSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EXTREFSELR { # [ doc = "Use analog reference 0 as reference." ] ANALOGREFERENCE0 , # [ doc = "Use analog reference 1 as reference." ] ANALOGREFERENCE1 } impl EXTREFSELR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { EXTREFSELR :: ANALOGREFERENCE0 => false , EXTREFSELR :: ANALOGREFERENCE1 => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> EXTREFSELR { match value { false => EXTREFSELR :: ANALOGREFERENCE0 , true => EXTREFSELR :: ANALOGREFERENCE1 , } } # [ doc = "Checks if the value of the field is `ANALOGREFERENCE0`" ] # [ inline ] pub fn is_analog_reference0 ( & self ) -> bool { * self == EXTREFSELR :: ANALOGREFERENCE0 } # [ doc = "Checks if the value of the field is `ANALOGREFERENCE1`" ] # [ inline ] pub fn is_analog_reference1 ( & self ) -> bool { * self == EXTREFSELR :: ANALOGREFERENCE1 } } # [ doc = "Values that can be written to the field `EXTREFSEL`" ] pub enum EXTREFSELW { # [ doc = "Use analog reference 0 as reference." ] ANALOGREFERENCE0 , # [ doc = "Use analog reference 1 as reference." ] ANALOGREFERENCE1 } impl EXTREFSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { EXTREFSELW :: ANALOGREFERENCE0 => false , EXTREFSELW :: ANALOGREFERENCE1 => true } } } # [ doc = r" Proxy" ] pub struct _EXTREFSELW < 'a > { w : & 'a mut W , } impl < 'a > _EXTREFSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EXTREFSELW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Use analog reference 0 as reference." ] # [ inline ] pub fn analog_reference0 ( self ) -> & 'a mut W { self . variant ( EXTREFSELW :: ANALOGREFERENCE0 ) } # [ doc = "Use analog reference 1 as reference." ] # [ inline ] pub fn analog_reference1 ( self ) -> & 'a mut W { self . variant ( EXTREFSELW :: ANALOGREFERENCE1 ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - External analog reference pin selection." ] # [ inline ] pub fn extrefsel ( & self ) -> EXTREFSELR { EXTREFSELR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - External analog reference pin selection." ] # [ inline ] pub fn extrefsel ( & mut self ) -> _EXTREFSELW { _EXTREFSELW { w : self } } } } # [ doc = "Analog detect configuration." ] pub struct ANADETECT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Analog detect configuration." ] pub mod anadetect { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ANADETECT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ANADETECT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ANADETECTR { # [ doc = "Generate ANADETEC on crossing, both upwards and downwards crossing." ] CROSS , # [ doc = "Generate ANADETEC on upwards crossing only." ] UP , # [ doc = "Generate ANADETEC on downwards crossing only." ] DOWN , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ANADETECTR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ANADETECTR :: CROSS => 0 , ANADETECTR :: UP => 0x01 , ANADETECTR :: DOWN => 0x02 , ANADETECTR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ANADETECTR { match value { 0 => ANADETECTR :: CROSS , 1 => ANADETECTR :: UP , 2 => ANADETECTR :: DOWN , i => ANADETECTR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `CROSS`" ] # [ inline ] pub fn is_cross ( & self ) -> bool { * self == ANADETECTR :: CROSS } # [ doc = "Checks if the value of the field is `UP`" ] # [ inline ] pub fn is_up ( & self ) -> bool { * self == ANADETECTR :: UP } # [ doc = "Checks if the value of the field is `DOWN`" ] # [ inline ] pub fn is_down ( & self ) -> bool { * self == ANADETECTR :: DOWN } } # [ doc = "Values that can be written to the field `ANADETECT`" ] pub enum ANADETECTW { # [ doc = "Generate ANADETEC on crossing, both upwards and downwards crossing." ] CROSS , # [ doc = "Generate ANADETEC on upwards crossing only." ] UP , # [ doc = "Generate ANADETEC on downwards crossing only." ] DOWN } impl ANADETECTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ANADETECTW :: CROSS => 0 , ANADETECTW :: UP => 1 , ANADETECTW :: DOWN => 2 } } } # [ doc = r" Proxy" ] pub struct _ANADETECTW < 'a > { w : & 'a mut W , } impl < 'a > _ANADETECTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ANADETECTW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Generate ANADETEC on crossing, both upwards and downwards crossing." ] # [ inline ] pub fn cross ( self ) -> & 'a mut W { self . variant ( ANADETECTW :: CROSS ) } # [ doc = "Generate ANADETEC on upwards crossing only." ] # [ inline ] pub fn up ( self ) -> & 'a mut W { self . variant ( ANADETECTW :: UP ) } # [ doc = "Generate ANADETEC on downwards crossing only." ] # [ inline ] pub fn down ( self ) -> & 'a mut W { self . variant ( ANADETECTW :: DOWN ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Analog detect configuration." ] # [ inline ] pub fn anadetect ( & self ) -> ANADETECTR { ANADETECTR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Analog detect configuration." ] # [ inline ] pub fn anadetect ( & mut self ) -> _ANADETECTW { _ANADETECTW { w : self } } } } } # [ doc = "Comparator." ] pub struct COMP { _marker : PhantomData < * const ( ) > } unsafe impl Send for COMP { } impl COMP { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const comp :: RegisterBlock { 0x4001_3000 as * const _ } } impl Deref for COMP { type Target = comp :: RegisterBlock ; fn deref ( & self ) -> & comp :: RegisterBlock { unsafe { & * COMP :: ptr ( ) } } } # [ doc = "Comparator." ] pub mod comp { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Start the comparator." ] pub tasks_start : TASKS_START , # [ doc = "0x04 - Stop the comparator." ] pub tasks_stop : TASKS_STOP , # [ doc = "0x08 - Sample comparator value." ] pub tasks_sample : TASKS_SAMPLE , _reserved0 : [ u8 ; 244usize ] , # [ doc = "0x100 - COMP is ready and output is valid." ] pub events_ready : EVENTS_READY , # [ doc = "0x104 - Input voltage crossed the threshold going down." ] pub events_down : EVENTS_DOWN , # [ doc = "0x108 - Input voltage crossed the threshold going up." ] pub events_up : EVENTS_UP , # [ doc = "0x10c - Input voltage crossed the threshold in any direction." ] pub events_cross : EVENTS_CROSS , _reserved1 : [ u8 ; 240usize ] , # [ doc = "0x200 - Shortcut for the COMP." ] pub shorts : SHORTS , _reserved2 : [ u8 ; 256usize ] , # [ doc = "0x304 - Interrupt enable set register." ] pub intenset : INTENSET , # [ doc = "0x308 - Interrupt enable clear register." ] pub intenclr : INTENCLR , _reserved3 : [ u8 ; 244usize ] , # [ doc = "0x400 - Compare result." ] pub result : RESULT , _reserved4 : [ u8 ; 252usize ] , # [ doc = "0x500 - Enable the COMP." ] pub enable : ENABLE , # [ doc = "0x504 - Input pin select." ] pub psel : PSEL , # [ doc = "0x508 - Reference select." ] pub refsel : REFSEL , # [ doc = "0x50c - External reference select." ] pub extrefsel : EXTREFSEL , _reserved5 : [ u8 ; 32usize ] , # [ doc = "0x530 - Threshold configuration for hysteresis unit." ] pub th : TH , # [ doc = "0x534 - Mode configuration." ] pub mode : MODE , } # [ doc = "Start the comparator." ] pub struct TASKS_START { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Start the comparator." ] pub mod tasks_start { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_START { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Stop the comparator." ] pub struct TASKS_STOP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Stop the comparator." ] pub mod tasks_stop { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_STOP { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Sample comparator value." ] pub struct TASKS_SAMPLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Sample comparator value." ] pub mod tasks_sample { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TASKS_SAMPLE { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "COMP is ready and output is valid." ] pub struct EVENTS_READY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "COMP is ready and output is valid." ] pub mod events_ready { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_READY { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Input voltage crossed the threshold going down." ] pub struct EVENTS_DOWN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Input voltage crossed the threshold going down." ] pub mod events_down { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_DOWN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Input voltage crossed the threshold going up." ] pub struct EVENTS_UP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Input voltage crossed the threshold going up." ] pub mod events_up { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_UP { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Input voltage crossed the threshold in any direction." ] pub struct EVENTS_CROSS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Input voltage crossed the threshold in any direction." ] pub mod events_cross { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EVENTS_CROSS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Shortcut for the COMP." ] pub struct SHORTS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Shortcut for the COMP." ] pub mod shorts { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SHORTS { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY_SAMPLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READY_SAMPLER { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_SAMPLER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READY_SAMPLER :: DISABLED => false , READY_SAMPLER :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READY_SAMPLER { match value { false => READY_SAMPLER :: DISABLED , true => READY_SAMPLER :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READY_SAMPLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READY_SAMPLER :: ENABLED } } # [ doc = "Possible values of the field `READY_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READY_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READY_STOPR :: DISABLED => false , READY_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READY_STOPR { match value { false => READY_STOPR :: DISABLED , true => READY_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READY_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READY_STOPR :: ENABLED } } # [ doc = "Possible values of the field `DOWN_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DOWN_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DOWN_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DOWN_STOPR :: DISABLED => false , DOWN_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DOWN_STOPR { match value { false => DOWN_STOPR :: DISABLED , true => DOWN_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DOWN_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DOWN_STOPR :: ENABLED } } # [ doc = "Possible values of the field `UP_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UP_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl UP_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { UP_STOPR :: DISABLED => false , UP_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> UP_STOPR { match value { false => UP_STOPR :: DISABLED , true => UP_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == UP_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == UP_STOPR :: ENABLED } } # [ doc = "Possible values of the field `CROSS_STOP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CROSS_STOPR { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl CROSS_STOPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CROSS_STOPR :: DISABLED => false , CROSS_STOPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CROSS_STOPR { match value { false => CROSS_STOPR :: DISABLED , true => CROSS_STOPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CROSS_STOPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CROSS_STOPR :: ENABLED } } # [ doc = "Values that can be written to the field `READY_SAMPLE`" ] pub enum READY_SAMPLEW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_SAMPLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READY_SAMPLEW :: DISABLED => false , READY_SAMPLEW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _READY_SAMPLEW < 'a > { w : & 'a mut W , } impl < 'a > _READY_SAMPLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READY_SAMPLEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( READY_SAMPLEW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( READY_SAMPLEW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `READY_STOP`" ] pub enum READY_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl READY_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READY_STOPW :: DISABLED => false , READY_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _READY_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _READY_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READY_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( READY_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( READY_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DOWN_STOP`" ] pub enum DOWN_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl DOWN_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DOWN_STOPW :: DISABLED => false , DOWN_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _DOWN_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _DOWN_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DOWN_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( DOWN_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( DOWN_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `UP_STOP`" ] pub enum UP_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl UP_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { UP_STOPW :: DISABLED => false , UP_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _UP_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _UP_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : UP_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( UP_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( UP_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CROSS_STOP`" ] pub enum CROSS_STOPW { # [ doc = "Shortcut disabled." ] DISABLED , # [ doc = "Shortcut enabled." ] ENABLED } impl CROSS_STOPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CROSS_STOPW :: DISABLED => false , CROSS_STOPW :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CROSS_STOPW < 'a > { w : & 'a mut W , } impl < 'a > _CROSS_STOPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CROSS_STOPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Shortcut disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CROSS_STOPW :: DISABLED ) } # [ doc = "Shortcut enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CROSS_STOPW :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Short-cut between READY event and SAMPLE task." ] # [ inline ] pub fn ready_sample ( & self ) -> READY_SAMPLER { READY_SAMPLER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Short-cut between RADY event and STOP task." ] # [ inline ] pub fn ready_stop ( & self ) -> READY_STOPR { READY_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Short-cut between DOWN event and STOP task." ] # [ inline ] pub fn down_stop ( & self ) -> DOWN_STOPR { DOWN_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Short-cut between UP event and STOP task." ] # [ inline ] pub fn up_stop ( & self ) -> UP_STOPR { UP_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Short-cut between CROSS event and STOP task." ] # [ inline ] pub fn cross_stop ( & self ) -> CROSS_STOPR { CROSS_STOPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Short-cut between READY event and SAMPLE task." ] # [ inline ] pub fn ready_sample ( & mut self ) -> _READY_SAMPLEW { _READY_SAMPLEW { w : self } } # [ doc = "Bit 1 - Short-cut between RADY event and STOP task." ] # [ inline ] pub fn ready_stop ( & mut self ) -> _READY_STOPW { _READY_STOPW { w : self } } # [ doc = "Bit 2 - Short-cut between DOWN event and STOP task." ] # [ inline ] pub fn down_stop ( & mut self ) -> _DOWN_STOPW { _DOWN_STOPW { w : self } } # [ doc = "Bit 3 - Short-cut between UP event and STOP task." ] # [ inline ] pub fn up_stop ( & mut self ) -> _UP_STOPW { _UP_STOPW { w : self } } # [ doc = "Bit 4 - Short-cut between CROSS event and STOP task." ] # [ inline ] pub fn cross_stop ( & mut self ) -> _CROSS_STOPW { _CROSS_STOPW { w : self } } } } # [ doc = "Interrupt enable set register." ] pub struct INTENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable set register." ] pub mod intenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl READYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READYR :: DISABLED => false , READYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READYR { match value { false => READYR :: DISABLED , true => READYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READYR :: ENABLED } } # [ doc = "Possible values of the field `DOWN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DOWNR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DOWNR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DOWNR :: DISABLED => false , DOWNR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DOWNR { match value { false => DOWNR :: DISABLED , true => DOWNR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DOWNR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DOWNR :: ENABLED } } # [ doc = "Possible values of the field `UP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UPR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl UPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { UPR :: DISABLED => false , UPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> UPR { match value { false => UPR :: DISABLED , true => UPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == UPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == UPR :: ENABLED } } # [ doc = "Possible values of the field `CROSS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CROSSR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl CROSSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CROSSR :: DISABLED => false , CROSSR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CROSSR { match value { false => CROSSR :: DISABLED , true => CROSSR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CROSSR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CROSSR :: ENABLED } } # [ doc = "Values that can be written to the field `READY`" ] pub enum READYW { # [ doc = "Enable interrupt on write." ] SET } impl READYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READYW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _READYW < 'a > { w : & 'a mut W , } impl < 'a > _READYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( READYW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DOWN`" ] pub enum DOWNW { # [ doc = "Enable interrupt on write." ] SET } impl DOWNW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DOWNW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _DOWNW < 'a > { w : & 'a mut W , } impl < 'a > _DOWNW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DOWNW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( DOWNW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `UP`" ] pub enum UPW { # [ doc = "Enable interrupt on write." ] SET } impl UPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { UPW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _UPW < 'a > { w : & 'a mut W , } impl < 'a > _UPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : UPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( UPW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CROSS`" ] pub enum CROSSW { # [ doc = "Enable interrupt on write." ] SET } impl CROSSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CROSSW :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CROSSW < 'a > { w : & 'a mut W , } impl < 'a > _CROSSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CROSSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable interrupt on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CROSSW :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable interrupt on READY event." ] # [ inline ] pub fn ready ( & self ) -> READYR { READYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable interrupt on DOWN event." ] # [ inline ] pub fn down ( & self ) -> DOWNR { DOWNR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable interrupt on UP event." ] # [ inline ] pub fn up ( & self ) -> UPR { UPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable interrupt on CROSS event." ] # [ inline ] pub fn cross ( & self ) -> CROSSR { CROSSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable interrupt on READY event." ] # [ inline ] pub fn ready ( & mut self ) -> _READYW { _READYW { w : self } } # [ doc = "Bit 1 - Enable interrupt on DOWN event." ] # [ inline ] pub fn down ( & mut self ) -> _DOWNW { _DOWNW { w : self } } # [ doc = "Bit 2 - Enable interrupt on UP event." ] # [ inline ] pub fn up ( & mut self ) -> _UPW { _UPW { w : self } } # [ doc = "Bit 3 - Enable interrupt on CROSS event." ] # [ inline ] pub fn cross ( & mut self ) -> _CROSSW { _CROSSW { w : self } } } } # [ doc = "Interrupt enable clear register." ] pub struct INTENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Interrupt enable clear register." ] pub mod intenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: INTENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `READY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READYR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl READYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READYR :: DISABLED => false , READYR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READYR { match value { false => READYR :: DISABLED , true => READYR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == READYR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == READYR :: ENABLED } } # [ doc = "Possible values of the field `DOWN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DOWNR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl DOWNR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DOWNR :: DISABLED => false , DOWNR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DOWNR { match value { false => DOWNR :: DISABLED , true => DOWNR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == DOWNR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == DOWNR :: ENABLED } } # [ doc = "Possible values of the field `UP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UPR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl UPR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { UPR :: DISABLED => false , UPR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> UPR { match value { false => UPR :: DISABLED , true => UPR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == UPR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == UPR :: ENABLED } } # [ doc = "Possible values of the field `CROSS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CROSSR { # [ doc = "Interrupt disabled." ] DISABLED , # [ doc = "Interrupt enabled." ] ENABLED } impl CROSSR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CROSSR :: DISABLED => false , CROSSR :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CROSSR { match value { false => CROSSR :: DISABLED , true => CROSSR :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CROSSR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CROSSR :: ENABLED } } # [ doc = "Values that can be written to the field `READY`" ] pub enum READYW { # [ doc = "Disable interrupt on write." ] CLEAR } impl READYW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { READYW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _READYW < 'a > { w : & 'a mut W , } impl < 'a > _READYW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : READYW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( READYW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DOWN`" ] pub enum DOWNW { # [ doc = "Disable interrupt on write." ] CLEAR } impl DOWNW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DOWNW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _DOWNW < 'a > { w : & 'a mut W , } impl < 'a > _DOWNW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DOWNW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( DOWNW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `UP`" ] pub enum UPW { # [ doc = "Disable interrupt on write." ] CLEAR } impl UPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { UPW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _UPW < 'a > { w : & 'a mut W , } impl < 'a > _UPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : UPW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( UPW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CROSS`" ] pub enum CROSSW { # [ doc = "Disable interrupt on write." ] CLEAR } impl CROSSW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CROSSW :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CROSSW < 'a > { w : & 'a mut W , } impl < 'a > _CROSSW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CROSSW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable interrupt on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CROSSW :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable interrupt on READY event." ] # [ inline ] pub fn ready ( & self ) -> READYR { READYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable interrupt on DOWN event." ] # [ inline ] pub fn down ( & self ) -> DOWNR { DOWNR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Disable interrupt on UP event." ] # [ inline ] pub fn up ( & self ) -> UPR { UPR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Disable interrupt on CROSS event." ] # [ inline ] pub fn cross ( & self ) -> CROSSR { CROSSR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable interrupt on READY event." ] # [ inline ] pub fn ready ( & mut self ) -> _READYW { _READYW { w : self } } # [ doc = "Bit 1 - Disable interrupt on DOWN event." ] # [ inline ] pub fn down ( & mut self ) -> _DOWNW { _DOWNW { w : self } } # [ doc = "Bit 2 - Disable interrupt on UP event." ] # [ inline ] pub fn up ( & mut self ) -> _UPW { _UPW { w : self } } # [ doc = "Bit 3 - Disable interrupt on CROSS event." ] # [ inline ] pub fn cross ( & mut self ) -> _CROSSW { _CROSSW { w : self } } } } # [ doc = "Compare result." ] pub struct RESULT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Compare result." ] pub mod result { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: RESULT { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `RESULT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RESULTR { # [ doc = "Input voltage is bellow the reference threshold." ] BELLOW , # [ doc = "Input voltage is above the reference threshold." ] ABOVE } impl RESULTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { RESULTR :: BELLOW => false , RESULTR :: ABOVE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> RESULTR { match value { false => RESULTR :: BELLOW , true => RESULTR :: ABOVE , } } # [ doc = "Checks if the value of the field is `BELLOW`" ] # [ inline ] pub fn is_bellow ( & self ) -> bool { * self == RESULTR :: BELLOW } # [ doc = "Checks if the value of the field is `ABOVE`" ] # [ inline ] pub fn is_above ( & self ) -> bool { * self == RESULTR :: ABOVE } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Result of last compare. Decision point SAMPLE task." ] # [ inline ] pub fn result ( & self ) -> RESULTR { RESULTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "Enable the COMP." ] pub struct ENABLE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable the COMP." ] pub mod enable { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ENABLE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLER { # [ doc = "Disabled COMP." ] DISABLED , # [ doc = "Enable COMP." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl ENABLER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { ENABLER :: DISABLED => 0 , ENABLER :: ENABLED => 0x02 , ENABLER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> ENABLER { match value { 0 => ENABLER :: DISABLED , 2 => ENABLER :: ENABLED , i => ENABLER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == ENABLER :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == ENABLER :: ENABLED } } # [ doc = "Values that can be written to the field `ENABLE`" ] pub enum ENABLEW { # [ doc = "Disabled COMP." ] DISABLED , # [ doc = "Enable COMP." ] ENABLED } impl ENABLEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { ENABLEW :: DISABLED => 0 , ENABLEW :: ENABLED => 2 } } } # [ doc = r" Proxy" ] pub struct _ENABLEW < 'a > { w : & 'a mut W , } impl < 'a > _ENABLEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ENABLEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled COMP." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: DISABLED ) } # [ doc = "Enable COMP." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( ENABLEW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Enable or disable COMP." ] # [ inline ] pub fn enable ( & self ) -> ENABLER { ENABLER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Enable or disable COMP." ] # [ inline ] pub fn enable ( & mut self ) -> _ENABLEW { _ENABLEW { w : self } } } } # [ doc = "Input pin select." ] pub struct PSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Input pin select." ] pub mod psel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PSELR { # [ doc = "Use analog input 0 as analog input." ] ANALOGINPUT0 , # [ doc = "Use analog input 1 as analog input." ] ANALOGINPUT1 , # [ doc = "Use analog input 2 as analog input." ] ANALOGINPUT2 , # [ doc = "Use analog input 3 as analog input." ] ANALOGINPUT3 , # [ doc = "Use analog input 4 as analog input." ] ANALOGINPUT4 , # [ doc = "Use analog input 5 as analog input." ] ANALOGINPUT5 , # [ doc = "Use analog input 6 as analog input." ] ANALOGINPUT6 , # [ doc = "Use analog input 7 as analog input." ] ANALOGINPUT7 } impl PSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PSELR :: ANALOGINPUT0 => 0 , PSELR :: ANALOGINPUT1 => 0x01 , PSELR :: ANALOGINPUT2 => 0x02 , PSELR :: ANALOGINPUT3 => 0x03 , PSELR :: ANALOGINPUT4 => 0x04 , PSELR :: ANALOGINPUT5 => 0x05 , PSELR :: ANALOGINPUT6 => 0x06 , PSELR :: ANALOGINPUT7 => 0x07 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PSELR { match value { 0 => PSELR :: ANALOGINPUT0 , 1 => PSELR :: ANALOGINPUT1 , 2 => PSELR :: ANALOGINPUT2 , 3 => PSELR :: ANALOGINPUT3 , 4 => PSELR :: ANALOGINPUT4 , 5 => PSELR :: ANALOGINPUT5 , 6 => PSELR :: ANALOGINPUT6 , 7 => PSELR :: ANALOGINPUT7 , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `ANALOGINPUT0`" ] # [ inline ] pub fn is_analog_input0 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT0 } # [ doc = "Checks if the value of the field is `ANALOGINPUT1`" ] # [ inline ] pub fn is_analog_input1 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT1 } # [ doc = "Checks if the value of the field is `ANALOGINPUT2`" ] # [ inline ] pub fn is_analog_input2 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT2 } # [ doc = "Checks if the value of the field is `ANALOGINPUT3`" ] # [ inline ] pub fn is_analog_input3 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT3 } # [ doc = "Checks if the value of the field is `ANALOGINPUT4`" ] # [ inline ] pub fn is_analog_input4 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT4 } # [ doc = "Checks if the value of the field is `ANALOGINPUT5`" ] # [ inline ] pub fn is_analog_input5 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT5 } # [ doc = "Checks if the value of the field is `ANALOGINPUT6`" ] # [ inline ] pub fn is_analog_input6 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT6 } # [ doc = "Checks if the value of the field is `ANALOGINPUT7`" ] # [ inline ] pub fn is_analog_input7 ( & self ) -> bool { * self == PSELR :: ANALOGINPUT7 } } # [ doc = "Values that can be written to the field `PSEL`" ] pub enum PSELW { # [ doc = "Use analog input 0 as analog input." ] ANALOGINPUT0 , # [ doc = "Use analog input 1 as analog input." ] ANALOGINPUT1 , # [ doc = "Use analog input 2 as analog input." ] ANALOGINPUT2 , # [ doc = "Use analog input 3 as analog input." ] ANALOGINPUT3 , # [ doc = "Use analog input 4 as analog input." ] ANALOGINPUT4 , # [ doc = "Use analog input 5 as analog input." ] ANALOGINPUT5 , # [ doc = "Use analog input 6 as analog input." ] ANALOGINPUT6 , # [ doc = "Use analog input 7 as analog input." ] ANALOGINPUT7 } impl PSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PSELW :: ANALOGINPUT0 => 0 , PSELW :: ANALOGINPUT1 => 1 , PSELW :: ANALOGINPUT2 => 2 , PSELW :: ANALOGINPUT3 => 3 , PSELW :: ANALOGINPUT4 => 4 , PSELW :: ANALOGINPUT5 => 5 , PSELW :: ANALOGINPUT6 => 6 , PSELW :: ANALOGINPUT7 => 7 } } } # [ doc = r" Proxy" ] pub struct _PSELW < 'a > { w : & 'a mut W , } impl < 'a > _PSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PSELW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Use analog input 0 as analog input." ] # [ inline ] pub fn analog_input0 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT0 ) } # [ doc = "Use analog input 1 as analog input." ] # [ inline ] pub fn analog_input1 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT1 ) } # [ doc = "Use analog input 2 as analog input." ] # [ inline ] pub fn analog_input2 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT2 ) } # [ doc = "Use analog input 3 as analog input." ] # [ inline ] pub fn analog_input3 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT3 ) } # [ doc = "Use analog input 4 as analog input." ] # [ inline ] pub fn analog_input4 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT4 ) } # [ doc = "Use analog input 5 as analog input." ] # [ inline ] pub fn analog_input5 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT5 ) } # [ doc = "Use analog input 6 as analog input." ] # [ inline ] pub fn analog_input6 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT6 ) } # [ doc = "Use analog input 7 as analog input." ] # [ inline ] pub fn analog_input7 ( self ) -> & 'a mut W { self . variant ( PSELW :: ANALOGINPUT7 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Analog input pin select." ] # [ inline ] pub fn psel ( & self ) -> PSELR { PSELR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Analog input pin select." ] # [ inline ] pub fn psel ( & mut self ) -> _PSELW { _PSELW { w : self } } } } # [ doc = "Reference select." ] pub struct REFSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Reference select." ] pub mod refsel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: REFSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `REFSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFSELR { # [ doc = "Use internal 1V5 as reference." ] INT1V5 , # [ doc = "Use internal 2V0 as reference." ] INT2V0 , # [ doc = "Use internal 2V5 as reference." ] INT2V5 , # [ doc = "Use supply as reference." ] SUPPLY , # [ doc = "Use external analog reference as reference." ] AREF , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl REFSELR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { REFSELR :: INT1V5 => 0 , REFSELR :: INT2V0 => 0x01 , REFSELR :: INT2V5 => 0x02 , REFSELR :: SUPPLY => 0x04 , REFSELR :: AREF => 0x05 , REFSELR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> REFSELR { match value { 0 => REFSELR :: INT1V5 , 1 => REFSELR :: INT2V0 , 2 => REFSELR :: INT2V5 , 4 => REFSELR :: SUPPLY , 5 => REFSELR :: AREF , i => REFSELR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `INT1V5`" ] # [ inline ] pub fn is_int1v5 ( & self ) -> bool { * self == REFSELR :: INT1V5 } # [ doc = "Checks if the value of the field is `INT2V0`" ] # [ inline ] pub fn is_int2v0 ( & self ) -> bool { * self == REFSELR :: INT2V0 } # [ doc = "Checks if the value of the field is `INT2V5`" ] # [ inline ] pub fn is_int2v5 ( & self ) -> bool { * self == REFSELR :: INT2V5 } # [ doc = "Checks if the value of the field is `SUPPLY`" ] # [ inline ] pub fn is_supply ( & self ) -> bool { * self == REFSELR :: SUPPLY } # [ doc = "Checks if the value of the field is `AREF`" ] # [ inline ] pub fn is_aref ( & self ) -> bool { * self == REFSELR :: AREF } } # [ doc = "Values that can be written to the field `REFSEL`" ] pub enum REFSELW { # [ doc = "Use internal 1V5 as reference." ] INT1V5 , # [ doc = "Use internal 2V0 as reference." ] INT2V0 , # [ doc = "Use internal 2V5 as reference." ] INT2V5 , # [ doc = "Use supply as reference." ] SUPPLY , # [ doc = "Use external analog reference as reference." ] AREF } impl REFSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { REFSELW :: INT1V5 => 0 , REFSELW :: INT2V0 => 1 , REFSELW :: INT2V5 => 2 , REFSELW :: SUPPLY => 4 , REFSELW :: AREF => 5 } } } # [ doc = r" Proxy" ] pub struct _REFSELW < 'a > { w : & 'a mut W , } impl < 'a > _REFSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : REFSELW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Use internal 1V5 as reference." ] # [ inline ] pub fn int1v5 ( self ) -> & 'a mut W { self . variant ( REFSELW :: INT1V5 ) } # [ doc = "Use internal 2V0 as reference." ] # [ inline ] pub fn int2v0 ( self ) -> & 'a mut W { self . variant ( REFSELW :: INT2V0 ) } # [ doc = "Use internal 2V5 as reference." ] # [ inline ] pub fn int2v5 ( self ) -> & 'a mut W { self . variant ( REFSELW :: INT2V5 ) } # [ doc = "Use supply as reference." ] # [ inline ] pub fn supply ( self ) -> & 'a mut W { self . variant ( REFSELW :: SUPPLY ) } # [ doc = "Use external analog reference as reference." ] # [ inline ] pub fn aref ( self ) -> & 'a mut W { self . variant ( REFSELW :: AREF ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:2 - Reference select." ] # [ inline ] pub fn refsel ( & self ) -> REFSELR { REFSELR :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:2 - Reference select." ] # [ inline ] pub fn refsel ( & mut self ) -> _REFSELW { _REFSELW { w : self } } } } # [ doc = "External reference select." ] pub struct EXTREFSEL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "External reference select." ] pub mod extrefsel { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EXTREFSEL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `EXTREFSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EXTREFSELR { # [ doc = "Use analog reference 0 as reference." ] ANALOGREFERENCE0 , # [ doc = "Use analog reference 1 as reference." ] ANALOGREFERENCE1 } impl EXTREFSELR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { EXTREFSELR :: ANALOGREFERENCE0 => false , EXTREFSELR :: ANALOGREFERENCE1 => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> EXTREFSELR { match value { false => EXTREFSELR :: ANALOGREFERENCE0 , true => EXTREFSELR :: ANALOGREFERENCE1 , } } # [ doc = "Checks if the value of the field is `ANALOGREFERENCE0`" ] # [ inline ] pub fn is_analog_reference0 ( & self ) -> bool { * self == EXTREFSELR :: ANALOGREFERENCE0 } # [ doc = "Checks if the value of the field is `ANALOGREFERENCE1`" ] # [ inline ] pub fn is_analog_reference1 ( & self ) -> bool { * self == EXTREFSELR :: ANALOGREFERENCE1 } } # [ doc = "Values that can be written to the field `EXTREFSEL`" ] pub enum EXTREFSELW { # [ doc = "Use analog reference 0 as reference." ] ANALOGREFERENCE0 , # [ doc = "Use analog reference 1 as reference." ] ANALOGREFERENCE1 } impl EXTREFSELW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { EXTREFSELW :: ANALOGREFERENCE0 => false , EXTREFSELW :: ANALOGREFERENCE1 => true } } } # [ doc = r" Proxy" ] pub struct _EXTREFSELW < 'a > { w : & 'a mut W , } impl < 'a > _EXTREFSELW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : EXTREFSELW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Use analog reference 0 as reference." ] # [ inline ] pub fn analog_reference0 ( self ) -> & 'a mut W { self . variant ( EXTREFSELW :: ANALOGREFERENCE0 ) } # [ doc = "Use analog reference 1 as reference." ] # [ inline ] pub fn analog_reference1 ( self ) -> & 'a mut W { self . variant ( EXTREFSELW :: ANALOGREFERENCE1 ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - External analog reference pin selection." ] # [ inline ] pub fn extrefsel ( & self ) -> EXTREFSELR { EXTREFSELR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - External analog reference pin selection." ] # [ inline ] pub fn extrefsel ( & mut self ) -> _EXTREFSELW { _EXTREFSELW { w : self } } } } # [ doc = "Threshold configuration for hysteresis unit." ] pub struct TH { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Threshold configuration for hysteresis unit." ] pub mod th { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TH { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct THUPR { bits : u8 , } impl THUPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Value of the field" ] pub struct THDOWNR { bits : u8 , } impl THDOWNR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { self . bits } } # [ doc = r" Proxy" ] pub struct _THUPW < 'a > { w : & 'a mut W , } impl < 'a > _THUPW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x3f ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _THDOWNW < 'a > { w : & 'a mut W , } impl < 'a > _THDOWNW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x3f ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:5 - VUP configuration." ] # [ inline ] pub fn thup ( & self ) -> THUPR { let bits = { const MASK : u8 = 0x3f ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; THUPR { bits } } # [ doc = "Bits 8:13 - VDOWN configuration." ] # [ inline ] pub fn thdown ( & self ) -> THDOWNR { let bits = { const MASK : u8 = 0x3f ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ; THDOWNR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:5 - VUP configuration." ] # [ inline ] pub fn thup ( & mut self ) -> _THUPW { _THUPW { w : self } } # [ doc = "Bits 8:13 - VDOWN configuration." ] # [ inline ] pub fn thdown ( & mut self ) -> _THDOWNW { _THDOWNW { w : self } } } } # [ doc = "Mode configuration." ] pub struct MODE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Mode configuration." ] pub mod mode { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: MODE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `SP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SPR { # [ doc = "Low power mode." ] LOW , # [ doc = "Normal mode." ] NORMAL , # [ doc = "High speed mode." ] HIGH , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl SPR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SPR :: LOW => 0 , SPR :: NORMAL => 0x01 , SPR :: HIGH => 0x02 , SPR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SPR { match value { 0 => SPR :: LOW , 1 => SPR :: NORMAL , 2 => SPR :: HIGH , i => SPR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == SPR :: LOW } # [ doc = "Checks if the value of the field is `NORMAL`" ] # [ inline ] pub fn is_normal ( & self ) -> bool { * self == SPR :: NORMAL } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == SPR :: HIGH } } # [ doc = "Possible values of the field `MAIN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MAINR { # [ doc = "Single ended mode." ] SINGLE , # [ doc = "Differential mode." ] DIFF } impl MAINR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { MAINR :: SINGLE => false , MAINR :: DIFF => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> MAINR { match value { false => MAINR :: SINGLE , true => MAINR :: DIFF , } } # [ doc = "Checks if the value of the field is `SINGLE`" ] # [ inline ] pub fn is_single ( & self ) -> bool { * self == MAINR :: SINGLE } # [ doc = "Checks if the value of the field is `DIFF`" ] # [ inline ] pub fn is_diff ( & self ) -> bool { * self == MAINR :: DIFF } } # [ doc = "Values that can be written to the field `SP`" ] pub enum SPW { # [ doc = "Low power mode." ] LOW , # [ doc = "Normal mode." ] NORMAL , # [ doc = "High speed mode." ] HIGH } impl SPW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SPW :: LOW => 0 , SPW :: NORMAL => 1 , SPW :: HIGH => 2 } } } # [ doc = r" Proxy" ] pub struct _SPW < 'a > { w : & 'a mut W , } impl < 'a > _SPW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SPW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Low power mode." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( SPW :: LOW ) } # [ doc = "Normal mode." ] # [ inline ] pub fn normal ( self ) -> & 'a mut W { self . variant ( SPW :: NORMAL ) } # [ doc = "High speed mode." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( SPW :: HIGH ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `MAIN`" ] pub enum MAINW { # [ doc = "Single ended mode." ] SINGLE , # [ doc = "Differential mode." ] DIFF } impl MAINW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { MAINW :: SINGLE => false , MAINW :: DIFF => true } } } # [ doc = r" Proxy" ] pub struct _MAINW < 'a > { w : & 'a mut W , } impl < 'a > _MAINW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : MAINW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Single ended mode." ] # [ inline ] pub fn single ( self ) -> & 'a mut W { self . variant ( MAINW :: SINGLE ) } # [ doc = "Differential mode." ] # [ inline ] pub fn diff ( self ) -> & 'a mut W { self . variant ( MAINW :: DIFF ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Speed and power mode." ] # [ inline ] pub fn sp ( & self ) -> SPR { SPR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bit 8 - Main operation mode." ] # [ inline ] pub fn main ( & self ) -> MAINR { MAINR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Speed and power mode." ] # [ inline ] pub fn sp ( & mut self ) -> _SPW { _SPW { w : self } } # [ doc = "Bit 8 - Main operation mode." ] # [ inline ] pub fn main ( & mut self ) -> _MAINW { _MAINW { w : self } } } } } # [ doc = "SW Interrupts." ] pub struct SWI { _marker : PhantomData < * const ( ) > } unsafe impl Send for SWI { } impl SWI { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const swi :: RegisterBlock { 0x4001_4000 as * const _ } } impl Deref for SWI { type Target = swi :: RegisterBlock ; fn deref ( & self ) -> & swi :: RegisterBlock { unsafe { & * SWI :: ptr ( ) } } } # [ doc = "SW Interrupts." ] pub mod swi { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Unused." ] pub unused : UNUSED , } # [ doc = "Unused." ] pub struct UNUSED { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Unused." ] pub mod unused { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: UNUSED { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } } } # [ doc = "Non Volatile Memory Controller." ] pub struct NVMC { _marker : PhantomData < * const ( ) > } unsafe impl Send for NVMC { } impl NVMC { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const nvmc :: RegisterBlock { 0x4001_e000 as * const _ } } impl Deref for NVMC { type Target = nvmc :: RegisterBlock ; fn deref ( & self ) -> & nvmc :: RegisterBlock { unsafe { & * NVMC :: ptr ( ) } } } # [ doc = "Non Volatile Memory Controller." ] pub mod nvmc { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1024usize ] , # [ doc = "0x400 - Ready flag." ] pub ready : READY , _reserved1 : [ u8 ; 256usize ] , # [ doc = "0x504 - Configuration register." ] pub config : CONFIG , # [ doc = "0x508 - Register for erasing a non-protected non-volatile memory page." ] pub erasepage : ERASEPAGE , # [ doc = "0x50c - Register for erasing all non-volatile user memory." ] pub eraseall : ERASEALL , # [ doc = "0x510 - Register for erasing a protected non-volatile memory page." ] pub eraseprotectedpage : ERASEPROTECTEDPAGE , # [ doc = "0x514 - Register for start erasing User Information Congfiguration Registers." ] pub eraseuicr : ERASEUICR , } # [ doc = "Ready flag." ] pub struct READY { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Ready flag." ] pub mod ready { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: READY { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `READY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READYR { # [ doc = "NVMC is busy (on-going write or erase operation)." ] BUSY , # [ doc = "NVMC is ready." ] READY } impl READYR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { READYR :: BUSY => false , READYR :: READY => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> READYR { match value { false => READYR :: BUSY , true => READYR :: READY , } } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ] pub fn is_busy ( & self ) -> bool { * self == READYR :: BUSY } # [ doc = "Checks if the value of the field is `READY`" ] # [ inline ] pub fn is_ready ( & self ) -> bool { * self == READYR :: READY } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - NVMC ready." ] # [ inline ] pub fn ready ( & self ) -> READYR { READYR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "Configuration register." ] pub struct CONFIG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Configuration register." ] pub mod config { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONFIG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `WEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WENR { # [ doc = "Read only access." ] REN , # [ doc = "Write enabled." ] WEN , # [ doc = "Erase enabled." ] EEN , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl WENR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { WENR :: REN => 0 , WENR :: WEN => 0x01 , WENR :: EEN => 0x02 , WENR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> WENR { match value { 0 => WENR :: REN , 1 => WENR :: WEN , 2 => WENR :: EEN , i => WENR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `REN`" ] # [ inline ] pub fn is_ren ( & self ) -> bool { * self == WENR :: REN } # [ doc = "Checks if the value of the field is `WEN`" ] # [ inline ] pub fn is_wen ( & self ) -> bool { * self == WENR :: WEN } # [ doc = "Checks if the value of the field is `EEN`" ] # [ inline ] pub fn is_een ( & self ) -> bool { * self == WENR :: EEN } } # [ doc = "Values that can be written to the field `WEN`" ] pub enum WENW { # [ doc = "Read only access." ] REN , # [ doc = "Write enabled." ] WEN , # [ doc = "Erase enabled." ] EEN } impl WENW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { WENW :: REN => 0 , WENW :: WEN => 1 , WENW :: EEN => 2 } } } # [ doc = r" Proxy" ] pub struct _WENW < 'a > { w : & 'a mut W , } impl < 'a > _WENW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : WENW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Read only access." ] # [ inline ] pub fn ren ( self ) -> & 'a mut W { self . variant ( WENW :: REN ) } # [ doc = "Write enabled." ] # [ inline ] pub fn wen ( self ) -> & 'a mut W { self . variant ( WENW :: WEN ) } # [ doc = "Erase enabled." ] # [ inline ] pub fn een ( self ) -> & 'a mut W { self . variant ( WENW :: EEN ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:1 - Program write enable." ] # [ inline ] pub fn wen ( & self ) -> WENR { WENR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:1 - Program write enable." ] # [ inline ] pub fn wen ( & mut self ) -> _WENW { _WENW { w : self } } } } # [ doc = "Register for erasing a non-protected non-volatile memory page." ] pub struct ERASEPAGE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Register for erasing a non-protected non-volatile memory page." ] pub mod erasepage { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ERASEPAGE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Register for erasing all non-volatile user memory." ] pub struct ERASEALL { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Register for erasing all non-volatile user memory." ] pub mod eraseall { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ERASEALL { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ERASEALL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERASEALLR { # [ doc = "No operation." ] NOOPERATION , # [ doc = "Start chip erase." ] ERASE } impl ERASEALLR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERASEALLR :: NOOPERATION => false , ERASEALLR :: ERASE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERASEALLR { match value { false => ERASEALLR :: NOOPERATION , true => ERASEALLR :: ERASE , } } # [ doc = "Checks if the value of the field is `NOOPERATION`" ] # [ inline ] pub fn is_no_operation ( & self ) -> bool { * self == ERASEALLR :: NOOPERATION } # [ doc = "Checks if the value of the field is `ERASE`" ] # [ inline ] pub fn is_erase ( & self ) -> bool { * self == ERASEALLR :: ERASE } } # [ doc = "Values that can be written to the field `ERASEALL`" ] pub enum ERASEALLW { # [ doc = "No operation." ] NOOPERATION , # [ doc = "Start chip erase." ] ERASE } impl ERASEALLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERASEALLW :: NOOPERATION => false , ERASEALLW :: ERASE => true } } } # [ doc = r" Proxy" ] pub struct _ERASEALLW < 'a > { w : & 'a mut W , } impl < 'a > _ERASEALLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERASEALLW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No operation." ] # [ inline ] pub fn no_operation ( self ) -> & 'a mut W { self . variant ( ERASEALLW :: NOOPERATION ) } # [ doc = "Start chip erase." ] # [ inline ] pub fn erase ( self ) -> & 'a mut W { self . variant ( ERASEALLW :: ERASE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Starts the erasing of all user NVM (code region 0/1 and UICR registers)." ] # [ inline ] pub fn eraseall ( & self ) -> ERASEALLR { ERASEALLR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Starts the erasing of all user NVM (code region 0/1 and UICR registers)." ] # [ inline ] pub fn eraseall ( & mut self ) -> _ERASEALLW { _ERASEALLW { w : self } } } } # [ doc = "Register for erasing a protected non-volatile memory page." ] pub struct ERASEPROTECTEDPAGE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Register for erasing a protected non-volatile memory page." ] pub mod eraseprotectedpage { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ERASEPROTECTEDPAGE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Register for start erasing User Information Congfiguration Registers." ] pub struct ERASEUICR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Register for start erasing User Information Congfiguration Registers." ] pub mod eraseuicr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ERASEUICR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `ERASEUICR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ERASEUICRR { # [ doc = "No operation." ] NOOPERATION , # [ doc = "Start UICR erase." ] ERASE } impl ERASEUICRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { ERASEUICRR :: NOOPERATION => false , ERASEUICRR :: ERASE => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> ERASEUICRR { match value { false => ERASEUICRR :: NOOPERATION , true => ERASEUICRR :: ERASE , } } # [ doc = "Checks if the value of the field is `NOOPERATION`" ] # [ inline ] pub fn is_no_operation ( & self ) -> bool { * self == ERASEUICRR :: NOOPERATION } # [ doc = "Checks if the value of the field is `ERASE`" ] # [ inline ] pub fn is_erase ( & self ) -> bool { * self == ERASEUICRR :: ERASE } } # [ doc = "Values that can be written to the field `ERASEUICR`" ] pub enum ERASEUICRW { # [ doc = "No operation." ] NOOPERATION , # [ doc = "Start UICR erase." ] ERASE } impl ERASEUICRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { ERASEUICRW :: NOOPERATION => false , ERASEUICRW :: ERASE => true } } } # [ doc = r" Proxy" ] pub struct _ERASEUICRW < 'a > { w : & 'a mut W , } impl < 'a > _ERASEUICRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : ERASEUICRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "No operation." ] # [ inline ] pub fn no_operation ( self ) -> & 'a mut W { self . variant ( ERASEUICRW :: NOOPERATION ) } # [ doc = "Start UICR erase." ] # [ inline ] pub fn erase ( self ) -> & 'a mut W { self . variant ( ERASEUICRW :: ERASE ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - It can only be used when all contents of code region 1 are erased." ] # [ inline ] pub fn eraseuicr ( & self ) -> ERASEUICRR { ERASEUICRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - It can only be used when all contents of code region 1 are erased." ] # [ inline ] pub fn eraseuicr ( & mut self ) -> _ERASEUICRW { _ERASEUICRW { w : self } } } } } # [ doc = "PPI controller." ] pub struct PPI { _marker : PhantomData < * const ( ) > } unsafe impl Send for PPI { } impl PPI { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ppi :: RegisterBlock { 0x4001_f000 as * const _ } } impl Deref for PPI { type Target = ppi :: RegisterBlock ; fn deref ( & self ) -> & ppi :: RegisterBlock { unsafe { & * PPI :: ptr ( ) } } } # [ doc = "PPI controller." ] pub mod ppi { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Channel group tasks." ] pub tasks_chg0 : TASKS_CHG , # [ doc = "0x08 - Channel group tasks." ] pub tasks_chg2 : TASKS_CHG , _reserved0 : [ u8 ; 1264usize ] , # [ doc = "0x500 - Channel enable." ] pub chen : CHEN , # [ doc = "0x504 - Channel enable set." ] pub chenset : CHENSET , # [ doc = "0x508 - Channel enable clear." ] pub chenclr : CHENCLR , _reserved1 : [ u8 ; 4usize ] , # [ doc = "0x510 - PPI Channel." ] pub ch0 : CH , # [ doc = "0x518 - PPI Channel." ] pub ch2 : CH , # [ doc = "0x520 - PPI Channel." ] pub ch4 : CH , # [ doc = "0x528 - PPI Channel." ] pub ch6 : CH , # [ doc = "0x530 - PPI Channel." ] pub ch8 : CH , # [ doc = "0x538 - PPI Channel." ] pub ch10 : CH , # [ doc = "0x540 - PPI Channel." ] pub ch12 : CH , # [ doc = "0x548 - PPI Channel." ] pub ch14 : CH , _reserved2 : [ u8 ; 688usize ] , # [ doc = "0x800 - Channel group configuration." ] pub chg : [ CHG ; 4 ] , } # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct TASKS_CHG { # [ doc = "0x00 - Enable channel group." ] pub en : self::tasks_chg::EN , # [ doc = "0x04 - Disable channel group." ] pub dis : self::tasks_chg::DIS , } # [ doc = r" Register block" ] # [ doc = "Channel group tasks." ] pub mod tasks_chg { # [ doc = "Enable channel group." ] pub struct EN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Enable channel group." ] pub mod en { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EN { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Disable channel group." ] pub struct DIS { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Disable channel group." ] pub mod dis { # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DIS { # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } } # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct CH { # [ doc = "0x00 - Channel event end-point." ] pub eep : self::ch::EEP , # [ doc = "0x04 - Channel task end-point." ] pub tep : self::ch::TEP , } # [ doc = r" Register block" ] # [ doc = "PPI Channel." ] pub mod ch { # [ doc = "Channel event end-point." ] pub struct EEP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Channel event end-point." ] pub mod eep { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: EEP { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Channel task end-point." ] pub struct TEP { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Channel task end-point." ] pub mod tep { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: TEP { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } } # [ doc = "Channel enable." ] pub struct CHEN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Channel enable." ] pub mod chen { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CHEN { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CH0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH0R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH0R :: DISABLED => false , CH0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH0R { match value { false => CH0R :: DISABLED , true => CH0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH0R :: ENABLED } } # [ doc = "Possible values of the field `CH1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH1R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH1R :: DISABLED => false , CH1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH1R { match value { false => CH1R :: DISABLED , true => CH1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH1R :: ENABLED } } # [ doc = "Possible values of the field `CH2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH2R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH2R :: DISABLED => false , CH2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH2R { match value { false => CH2R :: DISABLED , true => CH2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH2R :: ENABLED } } # [ doc = "Possible values of the field `CH3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH3R { # [ doc = "Channel disabled" ] DISABLED , # [ doc = "Channel enabled" ] ENABLED } impl CH3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH3R :: DISABLED => false , CH3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH3R { match value { false => CH3R :: DISABLED , true => CH3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH3R :: ENABLED } } # [ doc = "Possible values of the field `CH4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH4R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH4R :: DISABLED => false , CH4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH4R { match value { false => CH4R :: DISABLED , true => CH4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH4R :: ENABLED } } # [ doc = "Possible values of the field `CH5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH5R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH5R :: DISABLED => false , CH5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH5R { match value { false => CH5R :: DISABLED , true => CH5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH5R :: ENABLED } } # [ doc = "Possible values of the field `CH6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH6R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH6R :: DISABLED => false , CH6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH6R { match value { false => CH6R :: DISABLED , true => CH6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH6R :: ENABLED } } # [ doc = "Possible values of the field `CH7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH7R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH7R :: DISABLED => false , CH7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH7R { match value { false => CH7R :: DISABLED , true => CH7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH7R :: ENABLED } } # [ doc = "Possible values of the field `CH8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH8R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH8R :: DISABLED => false , CH8R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH8R { match value { false => CH8R :: DISABLED , true => CH8R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH8R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH8R :: ENABLED } } # [ doc = "Possible values of the field `CH9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH9R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH9R :: DISABLED => false , CH9R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH9R { match value { false => CH9R :: DISABLED , true => CH9R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH9R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH9R :: ENABLED } } # [ doc = "Possible values of the field `CH10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH10R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH10R :: DISABLED => false , CH10R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH10R { match value { false => CH10R :: DISABLED , true => CH10R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH10R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH10R :: ENABLED } } # [ doc = "Possible values of the field `CH11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH11R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH11R :: DISABLED => false , CH11R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH11R { match value { false => CH11R :: DISABLED , true => CH11R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH11R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH11R :: ENABLED } } # [ doc = "Possible values of the field `CH12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH12R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH12R :: DISABLED => false , CH12R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH12R { match value { false => CH12R :: DISABLED , true => CH12R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH12R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH12R :: ENABLED } } # [ doc = "Possible values of the field `CH13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH13R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH13R :: DISABLED => false , CH13R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH13R { match value { false => CH13R :: DISABLED , true => CH13R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH13R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH13R :: ENABLED } } # [ doc = "Possible values of the field `CH14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH14R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH14R :: DISABLED => false , CH14R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH14R { match value { false => CH14R :: DISABLED , true => CH14R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH14R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH14R :: ENABLED } } # [ doc = "Possible values of the field `CH15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH15R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH15R :: DISABLED => false , CH15R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH15R { match value { false => CH15R :: DISABLED , true => CH15R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH15R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH15R :: ENABLED } } # [ doc = "Possible values of the field `CH20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH20R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH20R :: DISABLED => false , CH20R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH20R { match value { false => CH20R :: DISABLED , true => CH20R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH20R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH20R :: ENABLED } } # [ doc = "Possible values of the field `CH21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH21R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH21R :: DISABLED => false , CH21R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH21R { match value { false => CH21R :: DISABLED , true => CH21R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH21R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH21R :: ENABLED } } # [ doc = "Possible values of the field `CH22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH22R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH22R :: DISABLED => false , CH22R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH22R { match value { false => CH22R :: DISABLED , true => CH22R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH22R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH22R :: ENABLED } } # [ doc = "Possible values of the field `CH23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH23R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH23R :: DISABLED => false , CH23R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH23R { match value { false => CH23R :: DISABLED , true => CH23R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH23R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH23R :: ENABLED } } # [ doc = "Possible values of the field `CH24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH24R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH24R :: DISABLED => false , CH24R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH24R { match value { false => CH24R :: DISABLED , true => CH24R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH24R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH24R :: ENABLED } } # [ doc = "Possible values of the field `CH25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH25R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH25R :: DISABLED => false , CH25R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH25R { match value { false => CH25R :: DISABLED , true => CH25R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH25R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH25R :: ENABLED } } # [ doc = "Possible values of the field `CH26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH26R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH26R :: DISABLED => false , CH26R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH26R { match value { false => CH26R :: DISABLED , true => CH26R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH26R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH26R :: ENABLED } } # [ doc = "Possible values of the field `CH27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH27R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH27R :: DISABLED => false , CH27R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH27R { match value { false => CH27R :: DISABLED , true => CH27R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH27R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH27R :: ENABLED } } # [ doc = "Possible values of the field `CH28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH28R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH28R :: DISABLED => false , CH28R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH28R { match value { false => CH28R :: DISABLED , true => CH28R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH28R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH28R :: ENABLED } } # [ doc = "Possible values of the field `CH29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH29R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH29R :: DISABLED => false , CH29R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH29R { match value { false => CH29R :: DISABLED , true => CH29R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH29R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH29R :: ENABLED } } # [ doc = "Possible values of the field `CH30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH30R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH30R :: DISABLED => false , CH30R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH30R { match value { false => CH30R :: DISABLED , true => CH30R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH30R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH30R :: ENABLED } } # [ doc = "Possible values of the field `CH31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH31R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH31R :: DISABLED => false , CH31R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH31R { match value { false => CH31R :: DISABLED , true => CH31R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH31R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH31R :: ENABLED } } # [ doc = "Values that can be written to the field `CH0`" ] pub enum CH0W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH0W :: DISABLED => false , CH0W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH0W < 'a > { w : & 'a mut W , } impl < 'a > _CH0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH0W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH0W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH1`" ] pub enum CH1W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH1W :: DISABLED => false , CH1W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH1W < 'a > { w : & 'a mut W , } impl < 'a > _CH1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH1W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH1W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH2`" ] pub enum CH2W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH2W :: DISABLED => false , CH2W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH2W < 'a > { w : & 'a mut W , } impl < 'a > _CH2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH2W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH2W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH3`" ] pub enum CH3W { # [ doc = "Channel disabled" ] DISABLED , # [ doc = "Channel enabled" ] ENABLED } impl CH3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH3W :: DISABLED => false , CH3W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH3W < 'a > { w : & 'a mut W , } impl < 'a > _CH3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled" ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH3W :: DISABLED ) } # [ doc = "Channel enabled" ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH3W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH4`" ] pub enum CH4W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH4W :: DISABLED => false , CH4W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH4W < 'a > { w : & 'a mut W , } impl < 'a > _CH4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH4W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH4W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH5`" ] pub enum CH5W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH5W :: DISABLED => false , CH5W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH5W < 'a > { w : & 'a mut W , } impl < 'a > _CH5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH5W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH5W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH6`" ] pub enum CH6W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH6W :: DISABLED => false , CH6W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH6W < 'a > { w : & 'a mut W , } impl < 'a > _CH6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH6W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH6W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH7`" ] pub enum CH7W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH7W :: DISABLED => false , CH7W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH7W < 'a > { w : & 'a mut W , } impl < 'a > _CH7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH7W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH7W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH8`" ] pub enum CH8W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH8W :: DISABLED => false , CH8W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH8W < 'a > { w : & 'a mut W , } impl < 'a > _CH8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH8W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH8W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH9`" ] pub enum CH9W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH9W :: DISABLED => false , CH9W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH9W < 'a > { w : & 'a mut W , } impl < 'a > _CH9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH9W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH9W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH10`" ] pub enum CH10W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH10W :: DISABLED => false , CH10W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH10W < 'a > { w : & 'a mut W , } impl < 'a > _CH10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH10W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH10W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH11`" ] pub enum CH11W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH11W :: DISABLED => false , CH11W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH11W < 'a > { w : & 'a mut W , } impl < 'a > _CH11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH11W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH11W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH12`" ] pub enum CH12W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH12W :: DISABLED => false , CH12W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH12W < 'a > { w : & 'a mut W , } impl < 'a > _CH12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH12W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH12W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH13`" ] pub enum CH13W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH13W :: DISABLED => false , CH13W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH13W < 'a > { w : & 'a mut W , } impl < 'a > _CH13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH13W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH13W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH14`" ] pub enum CH14W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH14W :: DISABLED => false , CH14W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH14W < 'a > { w : & 'a mut W , } impl < 'a > _CH14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH14W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH14W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH15`" ] pub enum CH15W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH15W :: DISABLED => false , CH15W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH15W < 'a > { w : & 'a mut W , } impl < 'a > _CH15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH15W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH15W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH20`" ] pub enum CH20W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH20W :: DISABLED => false , CH20W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH20W < 'a > { w : & 'a mut W , } impl < 'a > _CH20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH20W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH20W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH21`" ] pub enum CH21W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH21W :: DISABLED => false , CH21W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH21W < 'a > { w : & 'a mut W , } impl < 'a > _CH21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH21W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH21W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH22`" ] pub enum CH22W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH22W :: DISABLED => false , CH22W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH22W < 'a > { w : & 'a mut W , } impl < 'a > _CH22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH22W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH22W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH23`" ] pub enum CH23W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH23W :: DISABLED => false , CH23W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH23W < 'a > { w : & 'a mut W , } impl < 'a > _CH23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH23W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH23W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH24`" ] pub enum CH24W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH24W :: DISABLED => false , CH24W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH24W < 'a > { w : & 'a mut W , } impl < 'a > _CH24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH24W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH24W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH25`" ] pub enum CH25W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH25W :: DISABLED => false , CH25W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH25W < 'a > { w : & 'a mut W , } impl < 'a > _CH25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH25W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH25W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH26`" ] pub enum CH26W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH26W :: DISABLED => false , CH26W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH26W < 'a > { w : & 'a mut W , } impl < 'a > _CH26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH26W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH26W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH27`" ] pub enum CH27W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH27W :: DISABLED => false , CH27W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH27W < 'a > { w : & 'a mut W , } impl < 'a > _CH27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH27W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH27W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH28`" ] pub enum CH28W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH28W :: DISABLED => false , CH28W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH28W < 'a > { w : & 'a mut W , } impl < 'a > _CH28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH28W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH28W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH29`" ] pub enum CH29W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH29W :: DISABLED => false , CH29W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH29W < 'a > { w : & 'a mut W , } impl < 'a > _CH29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH29W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH29W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH30`" ] pub enum CH30W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH30W :: DISABLED => false , CH30W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH30W < 'a > { w : & 'a mut W , } impl < 'a > _CH30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH30W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH30W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH31`" ] pub enum CH31W { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH31W :: DISABLED => false , CH31W :: ENABLED => true } } } # [ doc = r" Proxy" ] pub struct _CH31W < 'a > { w : & 'a mut W , } impl < 'a > _CH31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( CH31W :: DISABLED ) } # [ doc = "Channel enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( CH31W :: ENABLED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable PPI channel 0." ] # [ inline ] pub fn ch0 ( & self ) -> CH0R { CH0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable PPI channel 1." ] # [ inline ] pub fn ch1 ( & self ) -> CH1R { CH1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable PPI channel 2." ] # [ inline ] pub fn ch2 ( & self ) -> CH2R { CH2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable PPI channel 3." ] # [ inline ] pub fn ch3 ( & self ) -> CH3R { CH3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Enable PPI channel 4." ] # [ inline ] pub fn ch4 ( & self ) -> CH4R { CH4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Enable PPI channel 5." ] # [ inline ] pub fn ch5 ( & self ) -> CH5R { CH5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Enable PPI channel 6." ] # [ inline ] pub fn ch6 ( & self ) -> CH6R { CH6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Enable PPI channel 7." ] # [ inline ] pub fn ch7 ( & self ) -> CH7R { CH7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Enable PPI channel 8." ] # [ inline ] pub fn ch8 ( & self ) -> CH8R { CH8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Enable PPI channel 9." ] # [ inline ] pub fn ch9 ( & self ) -> CH9R { CH9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Enable PPI channel 10." ] # [ inline ] pub fn ch10 ( & self ) -> CH10R { CH10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Enable PPI channel 11." ] # [ inline ] pub fn ch11 ( & self ) -> CH11R { CH11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Enable PPI channel 12." ] # [ inline ] pub fn ch12 ( & self ) -> CH12R { CH12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Enable PPI channel 13." ] # [ inline ] pub fn ch13 ( & self ) -> CH13R { CH13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Enable PPI channel 14." ] # [ inline ] pub fn ch14 ( & self ) -> CH14R { CH14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Enable PPI channel 15." ] # [ inline ] pub fn ch15 ( & self ) -> CH15R { CH15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Enable PPI channel 20." ] # [ inline ] pub fn ch20 ( & self ) -> CH20R { CH20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Enable PPI channel 21." ] # [ inline ] pub fn ch21 ( & self ) -> CH21R { CH21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Enable PPI channel 22." ] # [ inline ] pub fn ch22 ( & self ) -> CH22R { CH22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Enable PPI channel 23." ] # [ inline ] pub fn ch23 ( & self ) -> CH23R { CH23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Enable PPI channel 24." ] # [ inline ] pub fn ch24 ( & self ) -> CH24R { CH24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Enable PPI channel 25." ] # [ inline ] pub fn ch25 ( & self ) -> CH25R { CH25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Enable PPI channel 26." ] # [ inline ] pub fn ch26 ( & self ) -> CH26R { CH26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Enable PPI channel 27." ] # [ inline ] pub fn ch27 ( & self ) -> CH27R { CH27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Enable PPI channel 28." ] # [ inline ] pub fn ch28 ( & self ) -> CH28R { CH28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Enable PPI channel 29." ] # [ inline ] pub fn ch29 ( & self ) -> CH29R { CH29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Enable PPI channel 30." ] # [ inline ] pub fn ch30 ( & self ) -> CH30R { CH30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Enable PPI channel 31." ] # [ inline ] pub fn ch31 ( & self ) -> CH31R { CH31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable PPI channel 0." ] # [ inline ] pub fn ch0 ( & mut self ) -> _CH0W { _CH0W { w : self } } # [ doc = "Bit 1 - Enable PPI channel 1." ] # [ inline ] pub fn ch1 ( & mut self ) -> _CH1W { _CH1W { w : self } } # [ doc = "Bit 2 - Enable PPI channel 2." ] # [ inline ] pub fn ch2 ( & mut self ) -> _CH2W { _CH2W { w : self } } # [ doc = "Bit 3 - Enable PPI channel 3." ] # [ inline ] pub fn ch3 ( & mut self ) -> _CH3W { _CH3W { w : self } } # [ doc = "Bit 4 - Enable PPI channel 4." ] # [ inline ] pub fn ch4 ( & mut self ) -> _CH4W { _CH4W { w : self } } # [ doc = "Bit 5 - Enable PPI channel 5." ] # [ inline ] pub fn ch5 ( & mut self ) -> _CH5W { _CH5W { w : self } } # [ doc = "Bit 6 - Enable PPI channel 6." ] # [ inline ] pub fn ch6 ( & mut self ) -> _CH6W { _CH6W { w : self } } # [ doc = "Bit 7 - Enable PPI channel 7." ] # [ inline ] pub fn ch7 ( & mut self ) -> _CH7W { _CH7W { w : self } } # [ doc = "Bit 8 - Enable PPI channel 8." ] # [ inline ] pub fn ch8 ( & mut self ) -> _CH8W { _CH8W { w : self } } # [ doc = "Bit 9 - Enable PPI channel 9." ] # [ inline ] pub fn ch9 ( & mut self ) -> _CH9W { _CH9W { w : self } } # [ doc = "Bit 10 - Enable PPI channel 10." ] # [ inline ] pub fn ch10 ( & mut self ) -> _CH10W { _CH10W { w : self } } # [ doc = "Bit 11 - Enable PPI channel 11." ] # [ inline ] pub fn ch11 ( & mut self ) -> _CH11W { _CH11W { w : self } } # [ doc = "Bit 12 - Enable PPI channel 12." ] # [ inline ] pub fn ch12 ( & mut self ) -> _CH12W { _CH12W { w : self } } # [ doc = "Bit 13 - Enable PPI channel 13." ] # [ inline ] pub fn ch13 ( & mut self ) -> _CH13W { _CH13W { w : self } } # [ doc = "Bit 14 - Enable PPI channel 14." ] # [ inline ] pub fn ch14 ( & mut self ) -> _CH14W { _CH14W { w : self } } # [ doc = "Bit 15 - Enable PPI channel 15." ] # [ inline ] pub fn ch15 ( & mut self ) -> _CH15W { _CH15W { w : self } } # [ doc = "Bit 20 - Enable PPI channel 20." ] # [ inline ] pub fn ch20 ( & mut self ) -> _CH20W { _CH20W { w : self } } # [ doc = "Bit 21 - Enable PPI channel 21." ] # [ inline ] pub fn ch21 ( & mut self ) -> _CH21W { _CH21W { w : self } } # [ doc = "Bit 22 - Enable PPI channel 22." ] # [ inline ] pub fn ch22 ( & mut self ) -> _CH22W { _CH22W { w : self } } # [ doc = "Bit 23 - Enable PPI channel 23." ] # [ inline ] pub fn ch23 ( & mut self ) -> _CH23W { _CH23W { w : self } } # [ doc = "Bit 24 - Enable PPI channel 24." ] # [ inline ] pub fn ch24 ( & mut self ) -> _CH24W { _CH24W { w : self } } # [ doc = "Bit 25 - Enable PPI channel 25." ] # [ inline ] pub fn ch25 ( & mut self ) -> _CH25W { _CH25W { w : self } } # [ doc = "Bit 26 - Enable PPI channel 26." ] # [ inline ] pub fn ch26 ( & mut self ) -> _CH26W { _CH26W { w : self } } # [ doc = "Bit 27 - Enable PPI channel 27." ] # [ inline ] pub fn ch27 ( & mut self ) -> _CH27W { _CH27W { w : self } } # [ doc = "Bit 28 - Enable PPI channel 28." ] # [ inline ] pub fn ch28 ( & mut self ) -> _CH28W { _CH28W { w : self } } # [ doc = "Bit 29 - Enable PPI channel 29." ] # [ inline ] pub fn ch29 ( & mut self ) -> _CH29W { _CH29W { w : self } } # [ doc = "Bit 30 - Enable PPI channel 30." ] # [ inline ] pub fn ch30 ( & mut self ) -> _CH30W { _CH30W { w : self } } # [ doc = "Bit 31 - Enable PPI channel 31." ] # [ inline ] pub fn ch31 ( & mut self ) -> _CH31W { _CH31W { w : self } } } } # [ doc = "Channel enable set." ] pub struct CHENSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Channel enable set." ] pub mod chenset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CHENSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CH0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH0R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH0R :: DISABLED => false , CH0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH0R { match value { false => CH0R :: DISABLED , true => CH0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH0R :: ENABLED } } # [ doc = "Possible values of the field `CH1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH1R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH1R :: DISABLED => false , CH1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH1R { match value { false => CH1R :: DISABLED , true => CH1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH1R :: ENABLED } } # [ doc = "Possible values of the field `CH2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH2R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH2R :: DISABLED => false , CH2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH2R { match value { false => CH2R :: DISABLED , true => CH2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH2R :: ENABLED } } # [ doc = "Possible values of the field `CH3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH3R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH3R :: DISABLED => false , CH3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH3R { match value { false => CH3R :: DISABLED , true => CH3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH3R :: ENABLED } } # [ doc = "Possible values of the field `CH4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH4R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH4R :: DISABLED => false , CH4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH4R { match value { false => CH4R :: DISABLED , true => CH4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH4R :: ENABLED } } # [ doc = "Possible values of the field `CH5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH5R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH5R :: DISABLED => false , CH5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH5R { match value { false => CH5R :: DISABLED , true => CH5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH5R :: ENABLED } } # [ doc = "Possible values of the field `CH6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH6R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH6R :: DISABLED => false , CH6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH6R { match value { false => CH6R :: DISABLED , true => CH6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH6R :: ENABLED } } # [ doc = "Possible values of the field `CH7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH7R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH7R :: DISABLED => false , CH7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH7R { match value { false => CH7R :: DISABLED , true => CH7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH7R :: ENABLED } } # [ doc = "Possible values of the field `CH8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH8R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH8R :: DISABLED => false , CH8R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH8R { match value { false => CH8R :: DISABLED , true => CH8R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH8R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH8R :: ENABLED } } # [ doc = "Possible values of the field `CH9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH9R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH9R :: DISABLED => false , CH9R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH9R { match value { false => CH9R :: DISABLED , true => CH9R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH9R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH9R :: ENABLED } } # [ doc = "Possible values of the field `CH10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH10R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH10R :: DISABLED => false , CH10R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH10R { match value { false => CH10R :: DISABLED , true => CH10R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH10R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH10R :: ENABLED } } # [ doc = "Possible values of the field `CH11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH11R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH11R :: DISABLED => false , CH11R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH11R { match value { false => CH11R :: DISABLED , true => CH11R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH11R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH11R :: ENABLED } } # [ doc = "Possible values of the field `CH12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH12R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH12R :: DISABLED => false , CH12R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH12R { match value { false => CH12R :: DISABLED , true => CH12R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH12R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH12R :: ENABLED } } # [ doc = "Possible values of the field `CH13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH13R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH13R :: DISABLED => false , CH13R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH13R { match value { false => CH13R :: DISABLED , true => CH13R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH13R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH13R :: ENABLED } } # [ doc = "Possible values of the field `CH14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH14R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH14R :: DISABLED => false , CH14R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH14R { match value { false => CH14R :: DISABLED , true => CH14R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH14R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH14R :: ENABLED } } # [ doc = "Possible values of the field `CH15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH15R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH15R :: DISABLED => false , CH15R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH15R { match value { false => CH15R :: DISABLED , true => CH15R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH15R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH15R :: ENABLED } } # [ doc = "Possible values of the field `CH20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH20R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH20R :: DISABLED => false , CH20R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH20R { match value { false => CH20R :: DISABLED , true => CH20R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH20R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH20R :: ENABLED } } # [ doc = "Possible values of the field `CH21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH21R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH21R :: DISABLED => false , CH21R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH21R { match value { false => CH21R :: DISABLED , true => CH21R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH21R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH21R :: ENABLED } } # [ doc = "Possible values of the field `CH22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH22R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH22R :: DISABLED => false , CH22R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH22R { match value { false => CH22R :: DISABLED , true => CH22R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH22R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH22R :: ENABLED } } # [ doc = "Possible values of the field `CH23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH23R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH23R :: DISABLED => false , CH23R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH23R { match value { false => CH23R :: DISABLED , true => CH23R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH23R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH23R :: ENABLED } } # [ doc = "Possible values of the field `CH24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH24R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH24R :: DISABLED => false , CH24R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH24R { match value { false => CH24R :: DISABLED , true => CH24R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH24R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH24R :: ENABLED } } # [ doc = "Possible values of the field `CH25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH25R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH25R :: DISABLED => false , CH25R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH25R { match value { false => CH25R :: DISABLED , true => CH25R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH25R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH25R :: ENABLED } } # [ doc = "Possible values of the field `CH26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH26R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH26R :: DISABLED => false , CH26R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH26R { match value { false => CH26R :: DISABLED , true => CH26R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH26R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH26R :: ENABLED } } # [ doc = "Possible values of the field `CH27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH27R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH27R :: DISABLED => false , CH27R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH27R { match value { false => CH27R :: DISABLED , true => CH27R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH27R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH27R :: ENABLED } } # [ doc = "Possible values of the field `CH28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH28R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH28R :: DISABLED => false , CH28R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH28R { match value { false => CH28R :: DISABLED , true => CH28R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH28R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH28R :: ENABLED } } # [ doc = "Possible values of the field `CH29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH29R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH29R :: DISABLED => false , CH29R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH29R { match value { false => CH29R :: DISABLED , true => CH29R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH29R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH29R :: ENABLED } } # [ doc = "Possible values of the field `CH30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH30R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH30R :: DISABLED => false , CH30R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH30R { match value { false => CH30R :: DISABLED , true => CH30R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH30R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH30R :: ENABLED } } # [ doc = "Possible values of the field `CH31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH31R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH31R :: DISABLED => false , CH31R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH31R { match value { false => CH31R :: DISABLED , true => CH31R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH31R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH31R :: ENABLED } } # [ doc = "Values that can be written to the field `CH0`" ] pub enum CH0W { # [ doc = "Enable channel on write." ] SET } impl CH0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH0W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH0W < 'a > { w : & 'a mut W , } impl < 'a > _CH0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH0W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH1`" ] pub enum CH1W { # [ doc = "Enable channel on write." ] SET } impl CH1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH1W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH1W < 'a > { w : & 'a mut W , } impl < 'a > _CH1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH1W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH2`" ] pub enum CH2W { # [ doc = "Enable channel on write." ] SET } impl CH2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH2W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH2W < 'a > { w : & 'a mut W , } impl < 'a > _CH2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH2W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH3`" ] pub enum CH3W { # [ doc = "Enable channel on write." ] SET } impl CH3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH3W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH3W < 'a > { w : & 'a mut W , } impl < 'a > _CH3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH3W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH4`" ] pub enum CH4W { # [ doc = "Enable channel on write." ] SET } impl CH4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH4W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH4W < 'a > { w : & 'a mut W , } impl < 'a > _CH4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH4W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH5`" ] pub enum CH5W { # [ doc = "Enable channel on write." ] SET } impl CH5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH5W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH5W < 'a > { w : & 'a mut W , } impl < 'a > _CH5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH5W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH6`" ] pub enum CH6W { # [ doc = "Enable channel on write." ] SET } impl CH6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH6W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH6W < 'a > { w : & 'a mut W , } impl < 'a > _CH6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH6W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH7`" ] pub enum CH7W { # [ doc = "Enable channel on write." ] SET } impl CH7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH7W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH7W < 'a > { w : & 'a mut W , } impl < 'a > _CH7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH7W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH8`" ] pub enum CH8W { # [ doc = "Enable channel on write." ] SET } impl CH8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH8W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH8W < 'a > { w : & 'a mut W , } impl < 'a > _CH8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH8W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH9`" ] pub enum CH9W { # [ doc = "Enable channel on write." ] SET } impl CH9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH9W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH9W < 'a > { w : & 'a mut W , } impl < 'a > _CH9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH9W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH10`" ] pub enum CH10W { # [ doc = "Enable channel on write." ] SET } impl CH10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH10W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH10W < 'a > { w : & 'a mut W , } impl < 'a > _CH10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH10W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH11`" ] pub enum CH11W { # [ doc = "Enable channel on write." ] SET } impl CH11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH11W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH11W < 'a > { w : & 'a mut W , } impl < 'a > _CH11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH11W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH12`" ] pub enum CH12W { # [ doc = "Enable channel on write." ] SET } impl CH12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH12W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH12W < 'a > { w : & 'a mut W , } impl < 'a > _CH12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH12W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH13`" ] pub enum CH13W { # [ doc = "Enable channel on write." ] SET } impl CH13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH13W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH13W < 'a > { w : & 'a mut W , } impl < 'a > _CH13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH13W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH14`" ] pub enum CH14W { # [ doc = "Enable channel on write." ] SET } impl CH14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH14W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH14W < 'a > { w : & 'a mut W , } impl < 'a > _CH14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH14W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH15`" ] pub enum CH15W { # [ doc = "Enable channel on write." ] SET } impl CH15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH15W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH15W < 'a > { w : & 'a mut W , } impl < 'a > _CH15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH15W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH20`" ] pub enum CH20W { # [ doc = "Enable channel on write." ] SET } impl CH20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH20W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH20W < 'a > { w : & 'a mut W , } impl < 'a > _CH20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH20W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH21`" ] pub enum CH21W { # [ doc = "Enable channel on write." ] SET } impl CH21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH21W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH21W < 'a > { w : & 'a mut W , } impl < 'a > _CH21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH21W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH22`" ] pub enum CH22W { # [ doc = "Enable channel on write." ] SET } impl CH22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH22W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH22W < 'a > { w : & 'a mut W , } impl < 'a > _CH22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH22W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH23`" ] pub enum CH23W { # [ doc = "Enable channel on write." ] SET } impl CH23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH23W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH23W < 'a > { w : & 'a mut W , } impl < 'a > _CH23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH23W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH24`" ] pub enum CH24W { # [ doc = "Enable channel on write." ] SET } impl CH24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH24W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH24W < 'a > { w : & 'a mut W , } impl < 'a > _CH24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH24W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH25`" ] pub enum CH25W { # [ doc = "Enable channel on write." ] SET } impl CH25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH25W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH25W < 'a > { w : & 'a mut W , } impl < 'a > _CH25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH25W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH26`" ] pub enum CH26W { # [ doc = "Enable channel on write." ] SET } impl CH26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH26W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH26W < 'a > { w : & 'a mut W , } impl < 'a > _CH26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH26W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH27`" ] pub enum CH27W { # [ doc = "Enable channel on write." ] SET } impl CH27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH27W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH27W < 'a > { w : & 'a mut W , } impl < 'a > _CH27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH27W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH28`" ] pub enum CH28W { # [ doc = "Enable channel on write." ] SET } impl CH28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH28W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH28W < 'a > { w : & 'a mut W , } impl < 'a > _CH28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH28W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH29`" ] pub enum CH29W { # [ doc = "Enable channel on write." ] SET } impl CH29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH29W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH29W < 'a > { w : & 'a mut W , } impl < 'a > _CH29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH29W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH30`" ] pub enum CH30W { # [ doc = "Enable channel on write." ] SET } impl CH30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH30W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH30W < 'a > { w : & 'a mut W , } impl < 'a > _CH30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH30W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH31`" ] pub enum CH31W { # [ doc = "Enable channel on write." ] SET } impl CH31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH31W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _CH31W < 'a > { w : & 'a mut W , } impl < 'a > _CH31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Enable channel on write." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( CH31W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Enable PPI channel 0." ] # [ inline ] pub fn ch0 ( & self ) -> CH0R { CH0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Enable PPI channel 1." ] # [ inline ] pub fn ch1 ( & self ) -> CH1R { CH1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Enable PPI channel 2." ] # [ inline ] pub fn ch2 ( & self ) -> CH2R { CH2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Enable PPI channel 3." ] # [ inline ] pub fn ch3 ( & self ) -> CH3R { CH3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Enable PPI channel 4." ] # [ inline ] pub fn ch4 ( & self ) -> CH4R { CH4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Enable PPI channel 5." ] # [ inline ] pub fn ch5 ( & self ) -> CH5R { CH5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Enable PPI channel 6." ] # [ inline ] pub fn ch6 ( & self ) -> CH6R { CH6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Enable PPI channel 7." ] # [ inline ] pub fn ch7 ( & self ) -> CH7R { CH7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Enable PPI channel 8." ] # [ inline ] pub fn ch8 ( & self ) -> CH8R { CH8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Enable PPI channel 9." ] # [ inline ] pub fn ch9 ( & self ) -> CH9R { CH9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Enable PPI channel 10." ] # [ inline ] pub fn ch10 ( & self ) -> CH10R { CH10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Enable PPI channel 11." ] # [ inline ] pub fn ch11 ( & self ) -> CH11R { CH11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Enable PPI channel 12." ] # [ inline ] pub fn ch12 ( & self ) -> CH12R { CH12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Enable PPI channel 13." ] # [ inline ] pub fn ch13 ( & self ) -> CH13R { CH13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Enable PPI channel 14." ] # [ inline ] pub fn ch14 ( & self ) -> CH14R { CH14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Enable PPI channel 15." ] # [ inline ] pub fn ch15 ( & self ) -> CH15R { CH15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Enable PPI channel 20." ] # [ inline ] pub fn ch20 ( & self ) -> CH20R { CH20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Enable PPI channel 21." ] # [ inline ] pub fn ch21 ( & self ) -> CH21R { CH21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Enable PPI channel 22." ] # [ inline ] pub fn ch22 ( & self ) -> CH22R { CH22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Enable PPI channel 23." ] # [ inline ] pub fn ch23 ( & self ) -> CH23R { CH23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Enable PPI channel 24." ] # [ inline ] pub fn ch24 ( & self ) -> CH24R { CH24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Enable PPI channel 25." ] # [ inline ] pub fn ch25 ( & self ) -> CH25R { CH25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Enable PPI channel 26." ] # [ inline ] pub fn ch26 ( & self ) -> CH26R { CH26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Enable PPI channel 27." ] # [ inline ] pub fn ch27 ( & self ) -> CH27R { CH27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Enable PPI channel 28." ] # [ inline ] pub fn ch28 ( & self ) -> CH28R { CH28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Enable PPI channel 29." ] # [ inline ] pub fn ch29 ( & self ) -> CH29R { CH29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Enable PPI channel 30." ] # [ inline ] pub fn ch30 ( & self ) -> CH30R { CH30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Enable PPI channel 31." ] # [ inline ] pub fn ch31 ( & self ) -> CH31R { CH31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Enable PPI channel 0." ] # [ inline ] pub fn ch0 ( & mut self ) -> _CH0W { _CH0W { w : self } } # [ doc = "Bit 1 - Enable PPI channel 1." ] # [ inline ] pub fn ch1 ( & mut self ) -> _CH1W { _CH1W { w : self } } # [ doc = "Bit 2 - Enable PPI channel 2." ] # [ inline ] pub fn ch2 ( & mut self ) -> _CH2W { _CH2W { w : self } } # [ doc = "Bit 3 - Enable PPI channel 3." ] # [ inline ] pub fn ch3 ( & mut self ) -> _CH3W { _CH3W { w : self } } # [ doc = "Bit 4 - Enable PPI channel 4." ] # [ inline ] pub fn ch4 ( & mut self ) -> _CH4W { _CH4W { w : self } } # [ doc = "Bit 5 - Enable PPI channel 5." ] # [ inline ] pub fn ch5 ( & mut self ) -> _CH5W { _CH5W { w : self } } # [ doc = "Bit 6 - Enable PPI channel 6." ] # [ inline ] pub fn ch6 ( & mut self ) -> _CH6W { _CH6W { w : self } } # [ doc = "Bit 7 - Enable PPI channel 7." ] # [ inline ] pub fn ch7 ( & mut self ) -> _CH7W { _CH7W { w : self } } # [ doc = "Bit 8 - Enable PPI channel 8." ] # [ inline ] pub fn ch8 ( & mut self ) -> _CH8W { _CH8W { w : self } } # [ doc = "Bit 9 - Enable PPI channel 9." ] # [ inline ] pub fn ch9 ( & mut self ) -> _CH9W { _CH9W { w : self } } # [ doc = "Bit 10 - Enable PPI channel 10." ] # [ inline ] pub fn ch10 ( & mut self ) -> _CH10W { _CH10W { w : self } } # [ doc = "Bit 11 - Enable PPI channel 11." ] # [ inline ] pub fn ch11 ( & mut self ) -> _CH11W { _CH11W { w : self } } # [ doc = "Bit 12 - Enable PPI channel 12." ] # [ inline ] pub fn ch12 ( & mut self ) -> _CH12W { _CH12W { w : self } } # [ doc = "Bit 13 - Enable PPI channel 13." ] # [ inline ] pub fn ch13 ( & mut self ) -> _CH13W { _CH13W { w : self } } # [ doc = "Bit 14 - Enable PPI channel 14." ] # [ inline ] pub fn ch14 ( & mut self ) -> _CH14W { _CH14W { w : self } } # [ doc = "Bit 15 - Enable PPI channel 15." ] # [ inline ] pub fn ch15 ( & mut self ) -> _CH15W { _CH15W { w : self } } # [ doc = "Bit 20 - Enable PPI channel 20." ] # [ inline ] pub fn ch20 ( & mut self ) -> _CH20W { _CH20W { w : self } } # [ doc = "Bit 21 - Enable PPI channel 21." ] # [ inline ] pub fn ch21 ( & mut self ) -> _CH21W { _CH21W { w : self } } # [ doc = "Bit 22 - Enable PPI channel 22." ] # [ inline ] pub fn ch22 ( & mut self ) -> _CH22W { _CH22W { w : self } } # [ doc = "Bit 23 - Enable PPI channel 23." ] # [ inline ] pub fn ch23 ( & mut self ) -> _CH23W { _CH23W { w : self } } # [ doc = "Bit 24 - Enable PPI channel 24." ] # [ inline ] pub fn ch24 ( & mut self ) -> _CH24W { _CH24W { w : self } } # [ doc = "Bit 25 - Enable PPI channel 25." ] # [ inline ] pub fn ch25 ( & mut self ) -> _CH25W { _CH25W { w : self } } # [ doc = "Bit 26 - Enable PPI channel 26." ] # [ inline ] pub fn ch26 ( & mut self ) -> _CH26W { _CH26W { w : self } } # [ doc = "Bit 27 - Enable PPI channel 27." ] # [ inline ] pub fn ch27 ( & mut self ) -> _CH27W { _CH27W { w : self } } # [ doc = "Bit 28 - Enable PPI channel 28." ] # [ inline ] pub fn ch28 ( & mut self ) -> _CH28W { _CH28W { w : self } } # [ doc = "Bit 29 - Enable PPI channel 29." ] # [ inline ] pub fn ch29 ( & mut self ) -> _CH29W { _CH29W { w : self } } # [ doc = "Bit 30 - Enable PPI channel 30." ] # [ inline ] pub fn ch30 ( & mut self ) -> _CH30W { _CH30W { w : self } } # [ doc = "Bit 31 - Enable PPI channel 31." ] # [ inline ] pub fn ch31 ( & mut self ) -> _CH31W { _CH31W { w : self } } } } # [ doc = "Channel enable clear." ] pub struct CHENCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Channel enable clear." ] pub mod chenclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CHENCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CH0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH0R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH0R :: DISABLED => false , CH0R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH0R { match value { false => CH0R :: DISABLED , true => CH0R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH0R :: ENABLED } } # [ doc = "Possible values of the field `CH1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH1R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH1R :: DISABLED => false , CH1R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH1R { match value { false => CH1R :: DISABLED , true => CH1R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH1R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH1R :: ENABLED } } # [ doc = "Possible values of the field `CH2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH2R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH2R :: DISABLED => false , CH2R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH2R { match value { false => CH2R :: DISABLED , true => CH2R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH2R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH2R :: ENABLED } } # [ doc = "Possible values of the field `CH3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH3R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH3R :: DISABLED => false , CH3R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH3R { match value { false => CH3R :: DISABLED , true => CH3R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH3R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH3R :: ENABLED } } # [ doc = "Possible values of the field `CH4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH4R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH4R :: DISABLED => false , CH4R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH4R { match value { false => CH4R :: DISABLED , true => CH4R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH4R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH4R :: ENABLED } } # [ doc = "Possible values of the field `CH5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH5R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH5R :: DISABLED => false , CH5R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH5R { match value { false => CH5R :: DISABLED , true => CH5R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH5R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH5R :: ENABLED } } # [ doc = "Possible values of the field `CH6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH6R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH6R :: DISABLED => false , CH6R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH6R { match value { false => CH6R :: DISABLED , true => CH6R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH6R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH6R :: ENABLED } } # [ doc = "Possible values of the field `CH7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH7R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH7R :: DISABLED => false , CH7R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH7R { match value { false => CH7R :: DISABLED , true => CH7R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH7R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH7R :: ENABLED } } # [ doc = "Possible values of the field `CH8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH8R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH8R :: DISABLED => false , CH8R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH8R { match value { false => CH8R :: DISABLED , true => CH8R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH8R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH8R :: ENABLED } } # [ doc = "Possible values of the field `CH9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH9R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH9R :: DISABLED => false , CH9R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH9R { match value { false => CH9R :: DISABLED , true => CH9R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH9R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH9R :: ENABLED } } # [ doc = "Possible values of the field `CH10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH10R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH10R :: DISABLED => false , CH10R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH10R { match value { false => CH10R :: DISABLED , true => CH10R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH10R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH10R :: ENABLED } } # [ doc = "Possible values of the field `CH11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH11R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH11R :: DISABLED => false , CH11R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH11R { match value { false => CH11R :: DISABLED , true => CH11R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH11R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH11R :: ENABLED } } # [ doc = "Possible values of the field `CH12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH12R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH12R :: DISABLED => false , CH12R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH12R { match value { false => CH12R :: DISABLED , true => CH12R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH12R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH12R :: ENABLED } } # [ doc = "Possible values of the field `CH13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH13R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH13R :: DISABLED => false , CH13R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH13R { match value { false => CH13R :: DISABLED , true => CH13R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH13R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH13R :: ENABLED } } # [ doc = "Possible values of the field `CH14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH14R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH14R :: DISABLED => false , CH14R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH14R { match value { false => CH14R :: DISABLED , true => CH14R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH14R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH14R :: ENABLED } } # [ doc = "Possible values of the field `CH15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH15R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH15R :: DISABLED => false , CH15R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH15R { match value { false => CH15R :: DISABLED , true => CH15R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH15R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH15R :: ENABLED } } # [ doc = "Possible values of the field `CH20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH20R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH20R :: DISABLED => false , CH20R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH20R { match value { false => CH20R :: DISABLED , true => CH20R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH20R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH20R :: ENABLED } } # [ doc = "Possible values of the field `CH21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH21R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH21R :: DISABLED => false , CH21R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH21R { match value { false => CH21R :: DISABLED , true => CH21R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH21R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH21R :: ENABLED } } # [ doc = "Possible values of the field `CH22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH22R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH22R :: DISABLED => false , CH22R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH22R { match value { false => CH22R :: DISABLED , true => CH22R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH22R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH22R :: ENABLED } } # [ doc = "Possible values of the field `CH23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH23R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH23R :: DISABLED => false , CH23R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH23R { match value { false => CH23R :: DISABLED , true => CH23R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH23R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH23R :: ENABLED } } # [ doc = "Possible values of the field `CH24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH24R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH24R :: DISABLED => false , CH24R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH24R { match value { false => CH24R :: DISABLED , true => CH24R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH24R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH24R :: ENABLED } } # [ doc = "Possible values of the field `CH25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH25R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH25R :: DISABLED => false , CH25R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH25R { match value { false => CH25R :: DISABLED , true => CH25R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH25R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH25R :: ENABLED } } # [ doc = "Possible values of the field `CH26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH26R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH26R :: DISABLED => false , CH26R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH26R { match value { false => CH26R :: DISABLED , true => CH26R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH26R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH26R :: ENABLED } } # [ doc = "Possible values of the field `CH27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH27R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH27R :: DISABLED => false , CH27R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH27R { match value { false => CH27R :: DISABLED , true => CH27R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH27R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH27R :: ENABLED } } # [ doc = "Possible values of the field `CH28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH28R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH28R :: DISABLED => false , CH28R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH28R { match value { false => CH28R :: DISABLED , true => CH28R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH28R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH28R :: ENABLED } } # [ doc = "Possible values of the field `CH29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH29R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH29R :: DISABLED => false , CH29R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH29R { match value { false => CH29R :: DISABLED , true => CH29R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH29R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH29R :: ENABLED } } # [ doc = "Possible values of the field `CH30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH30R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH30R :: DISABLED => false , CH30R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH30R { match value { false => CH30R :: DISABLED , true => CH30R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH30R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH30R :: ENABLED } } # [ doc = "Possible values of the field `CH31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH31R { # [ doc = "Channel disabled." ] DISABLED , # [ doc = "Channel enabled." ] ENABLED } impl CH31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH31R :: DISABLED => false , CH31R :: ENABLED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH31R { match value { false => CH31R :: DISABLED , true => CH31R :: ENABLED , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == CH31R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == CH31R :: ENABLED } } # [ doc = "Values that can be written to the field `CH0`" ] pub enum CH0W { # [ doc = "Disable channel on write." ] CLEAR } impl CH0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH0W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH0W < 'a > { w : & 'a mut W , } impl < 'a > _CH0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH0W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH1`" ] pub enum CH1W { # [ doc = "Disable channel on write." ] CLEAR } impl CH1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH1W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH1W < 'a > { w : & 'a mut W , } impl < 'a > _CH1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH1W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH2`" ] pub enum CH2W { # [ doc = "Disable channel on write." ] CLEAR } impl CH2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH2W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH2W < 'a > { w : & 'a mut W , } impl < 'a > _CH2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH2W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH3`" ] pub enum CH3W { # [ doc = "Disable channel on write." ] CLEAR } impl CH3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH3W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH3W < 'a > { w : & 'a mut W , } impl < 'a > _CH3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH3W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH4`" ] pub enum CH4W { # [ doc = "Disable channel on write." ] CLEAR } impl CH4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH4W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH4W < 'a > { w : & 'a mut W , } impl < 'a > _CH4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH4W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH5`" ] pub enum CH5W { # [ doc = "Disable channel on write." ] CLEAR } impl CH5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH5W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH5W < 'a > { w : & 'a mut W , } impl < 'a > _CH5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH5W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH6`" ] pub enum CH6W { # [ doc = "Disable channel on write." ] CLEAR } impl CH6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH6W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH6W < 'a > { w : & 'a mut W , } impl < 'a > _CH6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH6W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH7`" ] pub enum CH7W { # [ doc = "Disable channel on write." ] CLEAR } impl CH7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH7W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH7W < 'a > { w : & 'a mut W , } impl < 'a > _CH7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH7W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH8`" ] pub enum CH8W { # [ doc = "Disable channel on write." ] CLEAR } impl CH8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH8W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH8W < 'a > { w : & 'a mut W , } impl < 'a > _CH8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH8W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH9`" ] pub enum CH9W { # [ doc = "Disable channel on write." ] CLEAR } impl CH9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH9W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH9W < 'a > { w : & 'a mut W , } impl < 'a > _CH9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH9W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH10`" ] pub enum CH10W { # [ doc = "Disable channel on write." ] CLEAR } impl CH10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH10W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH10W < 'a > { w : & 'a mut W , } impl < 'a > _CH10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH10W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH11`" ] pub enum CH11W { # [ doc = "Disable channel on write." ] CLEAR } impl CH11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH11W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH11W < 'a > { w : & 'a mut W , } impl < 'a > _CH11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH11W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH12`" ] pub enum CH12W { # [ doc = "Disable channel on write." ] CLEAR } impl CH12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH12W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH12W < 'a > { w : & 'a mut W , } impl < 'a > _CH12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH12W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH13`" ] pub enum CH13W { # [ doc = "Disable channel on write." ] CLEAR } impl CH13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH13W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH13W < 'a > { w : & 'a mut W , } impl < 'a > _CH13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH13W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH14`" ] pub enum CH14W { # [ doc = "Disable channel on write." ] CLEAR } impl CH14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH14W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH14W < 'a > { w : & 'a mut W , } impl < 'a > _CH14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH14W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH15`" ] pub enum CH15W { # [ doc = "Disable channel on write." ] CLEAR } impl CH15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH15W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH15W < 'a > { w : & 'a mut W , } impl < 'a > _CH15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH15W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH20`" ] pub enum CH20W { # [ doc = "Disable channel on write." ] CLEAR } impl CH20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH20W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH20W < 'a > { w : & 'a mut W , } impl < 'a > _CH20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH20W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH21`" ] pub enum CH21W { # [ doc = "Disable channel on write." ] CLEAR } impl CH21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH21W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH21W < 'a > { w : & 'a mut W , } impl < 'a > _CH21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH21W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH22`" ] pub enum CH22W { # [ doc = "Disable channel on write." ] CLEAR } impl CH22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH22W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH22W < 'a > { w : & 'a mut W , } impl < 'a > _CH22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH22W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH23`" ] pub enum CH23W { # [ doc = "Disable channel on write." ] CLEAR } impl CH23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH23W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH23W < 'a > { w : & 'a mut W , } impl < 'a > _CH23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH23W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH24`" ] pub enum CH24W { # [ doc = "Disable channel on write." ] CLEAR } impl CH24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH24W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH24W < 'a > { w : & 'a mut W , } impl < 'a > _CH24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH24W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH25`" ] pub enum CH25W { # [ doc = "Disable channel on write." ] CLEAR } impl CH25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH25W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH25W < 'a > { w : & 'a mut W , } impl < 'a > _CH25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH25W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH26`" ] pub enum CH26W { # [ doc = "Disable channel on write." ] CLEAR } impl CH26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH26W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH26W < 'a > { w : & 'a mut W , } impl < 'a > _CH26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH26W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH27`" ] pub enum CH27W { # [ doc = "Disable channel on write." ] CLEAR } impl CH27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH27W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH27W < 'a > { w : & 'a mut W , } impl < 'a > _CH27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH27W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH28`" ] pub enum CH28W { # [ doc = "Disable channel on write." ] CLEAR } impl CH28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH28W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH28W < 'a > { w : & 'a mut W , } impl < 'a > _CH28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH28W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH29`" ] pub enum CH29W { # [ doc = "Disable channel on write." ] CLEAR } impl CH29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH29W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH29W < 'a > { w : & 'a mut W , } impl < 'a > _CH29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH29W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH30`" ] pub enum CH30W { # [ doc = "Disable channel on write." ] CLEAR } impl CH30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH30W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH30W < 'a > { w : & 'a mut W , } impl < 'a > _CH30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH30W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH31`" ] pub enum CH31W { # [ doc = "Disable channel on write." ] CLEAR } impl CH31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH31W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _CH31W < 'a > { w : & 'a mut W , } impl < 'a > _CH31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable channel on write." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( CH31W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Disable PPI channel 0." ] # [ inline ] pub fn ch0 ( & self ) -> CH0R { CH0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Disable PPI channel 1." ] # [ inline ] pub fn ch1 ( & self ) -> CH1R { CH1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Disable PPI channel 2." ] # [ inline ] pub fn ch2 ( & self ) -> CH2R { CH2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Disable PPI channel 3." ] # [ inline ] pub fn ch3 ( & self ) -> CH3R { CH3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Disable PPI channel 4." ] # [ inline ] pub fn ch4 ( & self ) -> CH4R { CH4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Disable PPI channel 5." ] # [ inline ] pub fn ch5 ( & self ) -> CH5R { CH5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Disable PPI channel 6." ] # [ inline ] pub fn ch6 ( & self ) -> CH6R { CH6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Disable PPI channel 7." ] # [ inline ] pub fn ch7 ( & self ) -> CH7R { CH7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Disable PPI channel 8." ] # [ inline ] pub fn ch8 ( & self ) -> CH8R { CH8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Disable PPI channel 9." ] # [ inline ] pub fn ch9 ( & self ) -> CH9R { CH9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Disable PPI channel 10." ] # [ inline ] pub fn ch10 ( & self ) -> CH10R { CH10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Disable PPI channel 11." ] # [ inline ] pub fn ch11 ( & self ) -> CH11R { CH11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Disable PPI channel 12." ] # [ inline ] pub fn ch12 ( & self ) -> CH12R { CH12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Disable PPI channel 13." ] # [ inline ] pub fn ch13 ( & self ) -> CH13R { CH13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Disable PPI channel 14." ] # [ inline ] pub fn ch14 ( & self ) -> CH14R { CH14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Disable PPI channel 15." ] # [ inline ] pub fn ch15 ( & self ) -> CH15R { CH15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Disable PPI channel 20." ] # [ inline ] pub fn ch20 ( & self ) -> CH20R { CH20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Disable PPI channel 21." ] # [ inline ] pub fn ch21 ( & self ) -> CH21R { CH21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Disable PPI channel 22." ] # [ inline ] pub fn ch22 ( & self ) -> CH22R { CH22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Disable PPI channel 23." ] # [ inline ] pub fn ch23 ( & self ) -> CH23R { CH23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Disable PPI channel 24." ] # [ inline ] pub fn ch24 ( & self ) -> CH24R { CH24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Disable PPI channel 25." ] # [ inline ] pub fn ch25 ( & self ) -> CH25R { CH25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Disable PPI channel 26." ] # [ inline ] pub fn ch26 ( & self ) -> CH26R { CH26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Disable PPI channel 27." ] # [ inline ] pub fn ch27 ( & self ) -> CH27R { CH27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Disable PPI channel 28." ] # [ inline ] pub fn ch28 ( & self ) -> CH28R { CH28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Disable PPI channel 29." ] # [ inline ] pub fn ch29 ( & self ) -> CH29R { CH29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Disable PPI channel 30." ] # [ inline ] pub fn ch30 ( & self ) -> CH30R { CH30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Disable PPI channel 31." ] # [ inline ] pub fn ch31 ( & self ) -> CH31R { CH31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Disable PPI channel 0." ] # [ inline ] pub fn ch0 ( & mut self ) -> _CH0W { _CH0W { w : self } } # [ doc = "Bit 1 - Disable PPI channel 1." ] # [ inline ] pub fn ch1 ( & mut self ) -> _CH1W { _CH1W { w : self } } # [ doc = "Bit 2 - Disable PPI channel 2." ] # [ inline ] pub fn ch2 ( & mut self ) -> _CH2W { _CH2W { w : self } } # [ doc = "Bit 3 - Disable PPI channel 3." ] # [ inline ] pub fn ch3 ( & mut self ) -> _CH3W { _CH3W { w : self } } # [ doc = "Bit 4 - Disable PPI channel 4." ] # [ inline ] pub fn ch4 ( & mut self ) -> _CH4W { _CH4W { w : self } } # [ doc = "Bit 5 - Disable PPI channel 5." ] # [ inline ] pub fn ch5 ( & mut self ) -> _CH5W { _CH5W { w : self } } # [ doc = "Bit 6 - Disable PPI channel 6." ] # [ inline ] pub fn ch6 ( & mut self ) -> _CH6W { _CH6W { w : self } } # [ doc = "Bit 7 - Disable PPI channel 7." ] # [ inline ] pub fn ch7 ( & mut self ) -> _CH7W { _CH7W { w : self } } # [ doc = "Bit 8 - Disable PPI channel 8." ] # [ inline ] pub fn ch8 ( & mut self ) -> _CH8W { _CH8W { w : self } } # [ doc = "Bit 9 - Disable PPI channel 9." ] # [ inline ] pub fn ch9 ( & mut self ) -> _CH9W { _CH9W { w : self } } # [ doc = "Bit 10 - Disable PPI channel 10." ] # [ inline ] pub fn ch10 ( & mut self ) -> _CH10W { _CH10W { w : self } } # [ doc = "Bit 11 - Disable PPI channel 11." ] # [ inline ] pub fn ch11 ( & mut self ) -> _CH11W { _CH11W { w : self } } # [ doc = "Bit 12 - Disable PPI channel 12." ] # [ inline ] pub fn ch12 ( & mut self ) -> _CH12W { _CH12W { w : self } } # [ doc = "Bit 13 - Disable PPI channel 13." ] # [ inline ] pub fn ch13 ( & mut self ) -> _CH13W { _CH13W { w : self } } # [ doc = "Bit 14 - Disable PPI channel 14." ] # [ inline ] pub fn ch14 ( & mut self ) -> _CH14W { _CH14W { w : self } } # [ doc = "Bit 15 - Disable PPI channel 15." ] # [ inline ] pub fn ch15 ( & mut self ) -> _CH15W { _CH15W { w : self } } # [ doc = "Bit 20 - Disable PPI channel 20." ] # [ inline ] pub fn ch20 ( & mut self ) -> _CH20W { _CH20W { w : self } } # [ doc = "Bit 21 - Disable PPI channel 21." ] # [ inline ] pub fn ch21 ( & mut self ) -> _CH21W { _CH21W { w : self } } # [ doc = "Bit 22 - Disable PPI channel 22." ] # [ inline ] pub fn ch22 ( & mut self ) -> _CH22W { _CH22W { w : self } } # [ doc = "Bit 23 - Disable PPI channel 23." ] # [ inline ] pub fn ch23 ( & mut self ) -> _CH23W { _CH23W { w : self } } # [ doc = "Bit 24 - Disable PPI channel 24." ] # [ inline ] pub fn ch24 ( & mut self ) -> _CH24W { _CH24W { w : self } } # [ doc = "Bit 25 - Disable PPI channel 25." ] # [ inline ] pub fn ch25 ( & mut self ) -> _CH25W { _CH25W { w : self } } # [ doc = "Bit 26 - Disable PPI channel 26." ] # [ inline ] pub fn ch26 ( & mut self ) -> _CH26W { _CH26W { w : self } } # [ doc = "Bit 27 - Disable PPI channel 27." ] # [ inline ] pub fn ch27 ( & mut self ) -> _CH27W { _CH27W { w : self } } # [ doc = "Bit 28 - Disable PPI channel 28." ] # [ inline ] pub fn ch28 ( & mut self ) -> _CH28W { _CH28W { w : self } } # [ doc = "Bit 29 - Disable PPI channel 29." ] # [ inline ] pub fn ch29 ( & mut self ) -> _CH29W { _CH29W { w : self } } # [ doc = "Bit 30 - Disable PPI channel 30." ] # [ inline ] pub fn ch30 ( & mut self ) -> _CH30W { _CH30W { w : self } } # [ doc = "Bit 31 - Disable PPI channel 31." ] # [ inline ] pub fn ch31 ( & mut self ) -> _CH31W { _CH31W { w : self } } } } # [ doc = "Channel group configuration." ] pub struct CHG { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Channel group configuration." ] pub mod chg { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CHG { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `CH0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH0R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH0R :: EXCLUDED => false , CH0R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH0R { match value { false => CH0R :: EXCLUDED , true => CH0R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH0R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH0R :: INCLUDED } } # [ doc = "Possible values of the field `CH1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH1R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH1R :: EXCLUDED => false , CH1R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH1R { match value { false => CH1R :: EXCLUDED , true => CH1R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH1R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH1R :: INCLUDED } } # [ doc = "Possible values of the field `CH2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH2R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH2R :: EXCLUDED => false , CH2R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH2R { match value { false => CH2R :: EXCLUDED , true => CH2R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH2R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH2R :: INCLUDED } } # [ doc = "Possible values of the field `CH3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH3R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH3R :: EXCLUDED => false , CH3R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH3R { match value { false => CH3R :: EXCLUDED , true => CH3R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH3R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH3R :: INCLUDED } } # [ doc = "Possible values of the field `CH4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH4R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH4R :: EXCLUDED => false , CH4R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH4R { match value { false => CH4R :: EXCLUDED , true => CH4R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH4R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH4R :: INCLUDED } } # [ doc = "Possible values of the field `CH5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH5R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH5R :: EXCLUDED => false , CH5R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH5R { match value { false => CH5R :: EXCLUDED , true => CH5R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH5R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH5R :: INCLUDED } } # [ doc = "Possible values of the field `CH6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH6R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH6R :: EXCLUDED => false , CH6R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH6R { match value { false => CH6R :: EXCLUDED , true => CH6R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH6R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH6R :: INCLUDED } } # [ doc = "Possible values of the field `CH7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH7R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH7R :: EXCLUDED => false , CH7R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH7R { match value { false => CH7R :: EXCLUDED , true => CH7R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH7R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH7R :: INCLUDED } } # [ doc = "Possible values of the field `CH8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH8R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH8R :: EXCLUDED => false , CH8R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH8R { match value { false => CH8R :: EXCLUDED , true => CH8R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH8R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH8R :: INCLUDED } } # [ doc = "Possible values of the field `CH9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH9R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH9R :: EXCLUDED => false , CH9R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH9R { match value { false => CH9R :: EXCLUDED , true => CH9R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH9R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH9R :: INCLUDED } } # [ doc = "Possible values of the field `CH10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH10R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH10R :: EXCLUDED => false , CH10R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH10R { match value { false => CH10R :: EXCLUDED , true => CH10R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH10R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH10R :: INCLUDED } } # [ doc = "Possible values of the field `CH11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH11R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH11R :: EXCLUDED => false , CH11R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH11R { match value { false => CH11R :: EXCLUDED , true => CH11R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH11R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH11R :: INCLUDED } } # [ doc = "Possible values of the field `CH12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH12R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH12R :: EXCLUDED => false , CH12R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH12R { match value { false => CH12R :: EXCLUDED , true => CH12R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH12R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH12R :: INCLUDED } } # [ doc = "Possible values of the field `CH13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH13R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH13R :: EXCLUDED => false , CH13R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH13R { match value { false => CH13R :: EXCLUDED , true => CH13R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH13R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH13R :: INCLUDED } } # [ doc = "Possible values of the field `CH14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH14R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH14R :: EXCLUDED => false , CH14R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH14R { match value { false => CH14R :: EXCLUDED , true => CH14R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH14R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH14R :: INCLUDED } } # [ doc = "Possible values of the field `CH15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH15R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH15R :: EXCLUDED => false , CH15R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH15R { match value { false => CH15R :: EXCLUDED , true => CH15R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH15R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH15R :: INCLUDED } } # [ doc = "Possible values of the field `CH20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH20R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH20R :: EXCLUDED => false , CH20R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH20R { match value { false => CH20R :: EXCLUDED , true => CH20R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH20R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH20R :: INCLUDED } } # [ doc = "Possible values of the field `CH21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH21R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH21R :: EXCLUDED => false , CH21R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH21R { match value { false => CH21R :: EXCLUDED , true => CH21R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH21R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH21R :: INCLUDED } } # [ doc = "Possible values of the field `CH22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH22R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH22R :: EXCLUDED => false , CH22R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH22R { match value { false => CH22R :: EXCLUDED , true => CH22R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH22R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH22R :: INCLUDED } } # [ doc = "Possible values of the field `CH23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH23R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH23R :: EXCLUDED => false , CH23R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH23R { match value { false => CH23R :: EXCLUDED , true => CH23R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH23R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH23R :: INCLUDED } } # [ doc = "Possible values of the field `CH24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH24R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH24R :: EXCLUDED => false , CH24R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH24R { match value { false => CH24R :: EXCLUDED , true => CH24R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH24R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH24R :: INCLUDED } } # [ doc = "Possible values of the field `CH25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH25R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH25R :: EXCLUDED => false , CH25R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH25R { match value { false => CH25R :: EXCLUDED , true => CH25R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH25R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH25R :: INCLUDED } } # [ doc = "Possible values of the field `CH26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH26R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH26R :: EXCLUDED => false , CH26R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH26R { match value { false => CH26R :: EXCLUDED , true => CH26R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH26R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH26R :: INCLUDED } } # [ doc = "Possible values of the field `CH27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH27R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH27R :: EXCLUDED => false , CH27R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH27R { match value { false => CH27R :: EXCLUDED , true => CH27R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH27R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH27R :: INCLUDED } } # [ doc = "Possible values of the field `CH28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH28R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH28R :: EXCLUDED => false , CH28R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH28R { match value { false => CH28R :: EXCLUDED , true => CH28R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH28R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH28R :: INCLUDED } } # [ doc = "Possible values of the field `CH29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH29R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH29R :: EXCLUDED => false , CH29R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH29R { match value { false => CH29R :: EXCLUDED , true => CH29R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH29R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH29R :: INCLUDED } } # [ doc = "Possible values of the field `CH30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH30R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH30R :: EXCLUDED => false , CH30R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH30R { match value { false => CH30R :: EXCLUDED , true => CH30R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH30R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH30R :: INCLUDED } } # [ doc = "Possible values of the field `CH31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CH31R { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { CH31R :: EXCLUDED => false , CH31R :: INCLUDED => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> CH31R { match value { false => CH31R :: EXCLUDED , true => CH31R :: INCLUDED , } } # [ doc = "Checks if the value of the field is `EXCLUDED`" ] # [ inline ] pub fn is_excluded ( & self ) -> bool { * self == CH31R :: EXCLUDED } # [ doc = "Checks if the value of the field is `INCLUDED`" ] # [ inline ] pub fn is_included ( & self ) -> bool { * self == CH31R :: INCLUDED } } # [ doc = "Values that can be written to the field `CH0`" ] pub enum CH0W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH0W :: EXCLUDED => false , CH0W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH0W < 'a > { w : & 'a mut W , } impl < 'a > _CH0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH0W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH0W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH1`" ] pub enum CH1W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH1W :: EXCLUDED => false , CH1W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH1W < 'a > { w : & 'a mut W , } impl < 'a > _CH1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH1W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH1W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH2`" ] pub enum CH2W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH2W :: EXCLUDED => false , CH2W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH2W < 'a > { w : & 'a mut W , } impl < 'a > _CH2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH2W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH2W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH3`" ] pub enum CH3W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH3W :: EXCLUDED => false , CH3W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH3W < 'a > { w : & 'a mut W , } impl < 'a > _CH3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH3W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH3W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH4`" ] pub enum CH4W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH4W :: EXCLUDED => false , CH4W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH4W < 'a > { w : & 'a mut W , } impl < 'a > _CH4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH4W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH4W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH5`" ] pub enum CH5W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH5W :: EXCLUDED => false , CH5W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH5W < 'a > { w : & 'a mut W , } impl < 'a > _CH5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH5W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH5W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH6`" ] pub enum CH6W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH6W :: EXCLUDED => false , CH6W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH6W < 'a > { w : & 'a mut W , } impl < 'a > _CH6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH6W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH6W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH7`" ] pub enum CH7W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH7W :: EXCLUDED => false , CH7W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH7W < 'a > { w : & 'a mut W , } impl < 'a > _CH7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH7W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH7W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH8`" ] pub enum CH8W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH8W :: EXCLUDED => false , CH8W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH8W < 'a > { w : & 'a mut W , } impl < 'a > _CH8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH8W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH8W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH9`" ] pub enum CH9W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH9W :: EXCLUDED => false , CH9W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH9W < 'a > { w : & 'a mut W , } impl < 'a > _CH9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH9W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH9W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH10`" ] pub enum CH10W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH10W :: EXCLUDED => false , CH10W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH10W < 'a > { w : & 'a mut W , } impl < 'a > _CH10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH10W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH10W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH11`" ] pub enum CH11W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH11W :: EXCLUDED => false , CH11W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH11W < 'a > { w : & 'a mut W , } impl < 'a > _CH11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH11W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH11W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH12`" ] pub enum CH12W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH12W :: EXCLUDED => false , CH12W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH12W < 'a > { w : & 'a mut W , } impl < 'a > _CH12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH12W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH12W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH13`" ] pub enum CH13W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH13W :: EXCLUDED => false , CH13W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH13W < 'a > { w : & 'a mut W , } impl < 'a > _CH13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH13W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH13W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH14`" ] pub enum CH14W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH14W :: EXCLUDED => false , CH14W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH14W < 'a > { w : & 'a mut W , } impl < 'a > _CH14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH14W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH14W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH15`" ] pub enum CH15W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH15W :: EXCLUDED => false , CH15W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH15W < 'a > { w : & 'a mut W , } impl < 'a > _CH15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH15W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH15W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH20`" ] pub enum CH20W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH20W :: EXCLUDED => false , CH20W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH20W < 'a > { w : & 'a mut W , } impl < 'a > _CH20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH20W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH20W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH21`" ] pub enum CH21W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH21W :: EXCLUDED => false , CH21W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH21W < 'a > { w : & 'a mut W , } impl < 'a > _CH21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH21W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH21W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH22`" ] pub enum CH22W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH22W :: EXCLUDED => false , CH22W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH22W < 'a > { w : & 'a mut W , } impl < 'a > _CH22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH22W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH22W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH23`" ] pub enum CH23W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH23W :: EXCLUDED => false , CH23W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH23W < 'a > { w : & 'a mut W , } impl < 'a > _CH23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH23W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH23W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH24`" ] pub enum CH24W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH24W :: EXCLUDED => false , CH24W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH24W < 'a > { w : & 'a mut W , } impl < 'a > _CH24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH24W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH24W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH25`" ] pub enum CH25W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH25W :: EXCLUDED => false , CH25W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH25W < 'a > { w : & 'a mut W , } impl < 'a > _CH25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH25W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH25W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH26`" ] pub enum CH26W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH26W :: EXCLUDED => false , CH26W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH26W < 'a > { w : & 'a mut W , } impl < 'a > _CH26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH26W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH26W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH27`" ] pub enum CH27W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH27W :: EXCLUDED => false , CH27W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH27W < 'a > { w : & 'a mut W , } impl < 'a > _CH27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH27W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH27W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH28`" ] pub enum CH28W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH28W :: EXCLUDED => false , CH28W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH28W < 'a > { w : & 'a mut W , } impl < 'a > _CH28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH28W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH28W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH29`" ] pub enum CH29W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH29W :: EXCLUDED => false , CH29W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH29W < 'a > { w : & 'a mut W , } impl < 'a > _CH29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH29W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH29W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH30`" ] pub enum CH30W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH30W :: EXCLUDED => false , CH30W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH30W < 'a > { w : & 'a mut W , } impl < 'a > _CH30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH30W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH30W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `CH31`" ] pub enum CH31W { # [ doc = "Channel excluded." ] EXCLUDED , # [ doc = "Channel included." ] INCLUDED } impl CH31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { CH31W :: EXCLUDED => false , CH31W :: INCLUDED => true } } } # [ doc = r" Proxy" ] pub struct _CH31W < 'a > { w : & 'a mut W , } impl < 'a > _CH31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : CH31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Channel excluded." ] # [ inline ] pub fn excluded ( self ) -> & 'a mut W { self . variant ( CH31W :: EXCLUDED ) } # [ doc = "Channel included." ] # [ inline ] pub fn included ( self ) -> & 'a mut W { self . variant ( CH31W :: INCLUDED ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Include CH0 in channel group." ] # [ inline ] pub fn ch0 ( & self ) -> CH0R { CH0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Include CH1 in channel group." ] # [ inline ] pub fn ch1 ( & self ) -> CH1R { CH1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Include CH2 in channel group." ] # [ inline ] pub fn ch2 ( & self ) -> CH2R { CH2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Include CH3 in channel group." ] # [ inline ] pub fn ch3 ( & self ) -> CH3R { CH3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Include CH4 in channel group." ] # [ inline ] pub fn ch4 ( & self ) -> CH4R { CH4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Include CH5 in channel group." ] # [ inline ] pub fn ch5 ( & self ) -> CH5R { CH5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Include CH6 in channel group." ] # [ inline ] pub fn ch6 ( & self ) -> CH6R { CH6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Include CH7 in channel group." ] # [ inline ] pub fn ch7 ( & self ) -> CH7R { CH7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Include CH8 in channel group." ] # [ inline ] pub fn ch8 ( & self ) -> CH8R { CH8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Include CH9 in channel group." ] # [ inline ] pub fn ch9 ( & self ) -> CH9R { CH9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Include CH10 in channel group." ] # [ inline ] pub fn ch10 ( & self ) -> CH10R { CH10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Include CH11 in channel group." ] # [ inline ] pub fn ch11 ( & self ) -> CH11R { CH11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Include CH12 in channel group." ] # [ inline ] pub fn ch12 ( & self ) -> CH12R { CH12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Include CH13 in channel group." ] # [ inline ] pub fn ch13 ( & self ) -> CH13R { CH13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Include CH14 in channel group." ] # [ inline ] pub fn ch14 ( & self ) -> CH14R { CH14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Include CH15 in channel group." ] # [ inline ] pub fn ch15 ( & self ) -> CH15R { CH15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Include CH20 in channel group." ] # [ inline ] pub fn ch20 ( & self ) -> CH20R { CH20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Include CH21 in channel group." ] # [ inline ] pub fn ch21 ( & self ) -> CH21R { CH21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Include CH22 in channel group." ] # [ inline ] pub fn ch22 ( & self ) -> CH22R { CH22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Include CH23 in channel group." ] # [ inline ] pub fn ch23 ( & self ) -> CH23R { CH23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Include CH24 in channel group." ] # [ inline ] pub fn ch24 ( & self ) -> CH24R { CH24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Include CH25 in channel group." ] # [ inline ] pub fn ch25 ( & self ) -> CH25R { CH25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Include CH26 in channel group." ] # [ inline ] pub fn ch26 ( & self ) -> CH26R { CH26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Include CH27 in channel group." ] # [ inline ] pub fn ch27 ( & self ) -> CH27R { CH27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Include CH28 in channel group." ] # [ inline ] pub fn ch28 ( & self ) -> CH28R { CH28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Include CH29 in channel group." ] # [ inline ] pub fn ch29 ( & self ) -> CH29R { CH29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Include CH30 in channel group." ] # [ inline ] pub fn ch30 ( & self ) -> CH30R { CH30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Include CH31 in channel group." ] # [ inline ] pub fn ch31 ( & self ) -> CH31R { CH31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Include CH0 in channel group." ] # [ inline ] pub fn ch0 ( & mut self ) -> _CH0W { _CH0W { w : self } } # [ doc = "Bit 1 - Include CH1 in channel group." ] # [ inline ] pub fn ch1 ( & mut self ) -> _CH1W { _CH1W { w : self } } # [ doc = "Bit 2 - Include CH2 in channel group." ] # [ inline ] pub fn ch2 ( & mut self ) -> _CH2W { _CH2W { w : self } } # [ doc = "Bit 3 - Include CH3 in channel group." ] # [ inline ] pub fn ch3 ( & mut self ) -> _CH3W { _CH3W { w : self } } # [ doc = "Bit 4 - Include CH4 in channel group." ] # [ inline ] pub fn ch4 ( & mut self ) -> _CH4W { _CH4W { w : self } } # [ doc = "Bit 5 - Include CH5 in channel group." ] # [ inline ] pub fn ch5 ( & mut self ) -> _CH5W { _CH5W { w : self } } # [ doc = "Bit 6 - Include CH6 in channel group." ] # [ inline ] pub fn ch6 ( & mut self ) -> _CH6W { _CH6W { w : self } } # [ doc = "Bit 7 - Include CH7 in channel group." ] # [ inline ] pub fn ch7 ( & mut self ) -> _CH7W { _CH7W { w : self } } # [ doc = "Bit 8 - Include CH8 in channel group." ] # [ inline ] pub fn ch8 ( & mut self ) -> _CH8W { _CH8W { w : self } } # [ doc = "Bit 9 - Include CH9 in channel group." ] # [ inline ] pub fn ch9 ( & mut self ) -> _CH9W { _CH9W { w : self } } # [ doc = "Bit 10 - Include CH10 in channel group." ] # [ inline ] pub fn ch10 ( & mut self ) -> _CH10W { _CH10W { w : self } } # [ doc = "Bit 11 - Include CH11 in channel group." ] # [ inline ] pub fn ch11 ( & mut self ) -> _CH11W { _CH11W { w : self } } # [ doc = "Bit 12 - Include CH12 in channel group." ] # [ inline ] pub fn ch12 ( & mut self ) -> _CH12W { _CH12W { w : self } } # [ doc = "Bit 13 - Include CH13 in channel group." ] # [ inline ] pub fn ch13 ( & mut self ) -> _CH13W { _CH13W { w : self } } # [ doc = "Bit 14 - Include CH14 in channel group." ] # [ inline ] pub fn ch14 ( & mut self ) -> _CH14W { _CH14W { w : self } } # [ doc = "Bit 15 - Include CH15 in channel group." ] # [ inline ] pub fn ch15 ( & mut self ) -> _CH15W { _CH15W { w : self } } # [ doc = "Bit 20 - Include CH20 in channel group." ] # [ inline ] pub fn ch20 ( & mut self ) -> _CH20W { _CH20W { w : self } } # [ doc = "Bit 21 - Include CH21 in channel group." ] # [ inline ] pub fn ch21 ( & mut self ) -> _CH21W { _CH21W { w : self } } # [ doc = "Bit 22 - Include CH22 in channel group." ] # [ inline ] pub fn ch22 ( & mut self ) -> _CH22W { _CH22W { w : self } } # [ doc = "Bit 23 - Include CH23 in channel group." ] # [ inline ] pub fn ch23 ( & mut self ) -> _CH23W { _CH23W { w : self } } # [ doc = "Bit 24 - Include CH24 in channel group." ] # [ inline ] pub fn ch24 ( & mut self ) -> _CH24W { _CH24W { w : self } } # [ doc = "Bit 25 - Include CH25 in channel group." ] # [ inline ] pub fn ch25 ( & mut self ) -> _CH25W { _CH25W { w : self } } # [ doc = "Bit 26 - Include CH26 in channel group." ] # [ inline ] pub fn ch26 ( & mut self ) -> _CH26W { _CH26W { w : self } } # [ doc = "Bit 27 - Include CH27 in channel group." ] # [ inline ] pub fn ch27 ( & mut self ) -> _CH27W { _CH27W { w : self } } # [ doc = "Bit 28 - Include CH28 in channel group." ] # [ inline ] pub fn ch28 ( & mut self ) -> _CH28W { _CH28W { w : self } } # [ doc = "Bit 29 - Include CH29 in channel group." ] # [ inline ] pub fn ch29 ( & mut self ) -> _CH29W { _CH29W { w : self } } # [ doc = "Bit 30 - Include CH30 in channel group." ] # [ inline ] pub fn ch30 ( & mut self ) -> _CH30W { _CH30W { w : self } } # [ doc = "Bit 31 - Include CH31 in channel group." ] # [ inline ] pub fn ch31 ( & mut self ) -> _CH31W { _CH31W { w : self } } } } } # [ doc = "Factory Information Configuration." ] pub struct FICR { _marker : PhantomData < * const ( ) > } unsafe impl Send for FICR { } impl FICR { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const ficr :: RegisterBlock { 0x1000_0000 as * const _ } } impl Deref for FICR { type Target = ficr :: RegisterBlock ; fn deref ( & self ) -> & ficr :: RegisterBlock { unsafe { & * FICR :: ptr ( ) } } } # [ doc = "Factory Information Configuration." ] pub mod ficr { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 16usize ] , # [ doc = "0x10 - Code memory page size in bytes." ] pub codepagesize : CODEPAGESIZE , # [ doc = "0x14 - Code memory size in pages." ] pub codesize : CODESIZE , _reserved1 : [ u8 ; 16usize ] , # [ doc = "0x28 - Length of code region 0 in bytes." ] pub clenr0 : CLENR0 , # [ doc = "0x2c - Pre-programmed factory code present." ] pub ppfc : PPFC , _reserved2 : [ u8 ; 4usize ] , # [ doc = "0x34 - Number of individualy controllable RAM blocks." ] pub numramblock : NUMRAMBLOCK , # [ doc = "0x38 - Size of RAM block in bytes." ] pub sizeramblock : [ SIZERAMBLOCK ; 4 ] , _reserved3 : [ u8 ; 20usize ] , # [ doc = "0x5c - Configuration identifier." ] pub configid : CONFIGID , # [ doc = "0x60 - Device identifier." ] pub deviceid : [ DEVICEID ; 2 ] , _reserved4 : [ u8 ; 24usize ] , # [ doc = "0x80 - Encryption root." ] pub er : [ ER ; 4 ] , # [ doc = "0x90 - Identity root." ] pub ir : [ IR ; 4 ] , # [ doc = "0xa0 - Device address type." ] pub deviceaddrtype : DEVICEADDRTYPE , # [ doc = "0xa4 - Device address." ] pub deviceaddr : [ DEVICEADDR ; 2 ] , } # [ doc = "Code memory page size in bytes." ] pub struct CODEPAGESIZE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Code memory page size in bytes." ] pub mod codepagesize { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CODEPAGESIZE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Code memory size in pages." ] pub struct CODESIZE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Code memory size in pages." ] pub mod codesize { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CODESIZE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Length of code region 0 in bytes." ] pub struct CLENR0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Length of code region 0 in bytes." ] pub mod clenr0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CLENR0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Pre-programmed factory code present." ] pub struct PPFC { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Pre-programmed factory code present." ] pub mod ppfc { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PPFC { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PPFC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PPFCR { # [ doc = "Not present." ] NOTPRESENT , # [ doc = "Present." ] PRESENT , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl PPFCR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PPFCR :: NOTPRESENT => 0xff , PPFCR :: PRESENT => 0 , PPFCR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PPFCR { match value { 255 => PPFCR :: NOTPRESENT , 0 => PPFCR :: PRESENT , i => PPFCR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `NOTPRESENT`" ] # [ inline ] pub fn is_not_present ( & self ) -> bool { * self == PPFCR :: NOTPRESENT } # [ doc = "Checks if the value of the field is `PRESENT`" ] # [ inline ] pub fn is_present ( & self ) -> bool { * self == PPFCR :: PRESENT } } # [ doc = "Values that can be written to the field `PPFC`" ] pub enum PPFCW { # [ doc = "Not present." ] NOTPRESENT , # [ doc = "Present." ] PRESENT } impl PPFCW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PPFCW :: NOTPRESENT => 255 , PPFCW :: PRESENT => 0 } } } # [ doc = r" Proxy" ] pub struct _PPFCW < 'a > { w : & 'a mut W , } impl < 'a > _PPFCW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PPFCW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Not present." ] # [ inline ] pub fn not_present ( self ) -> & 'a mut W { self . variant ( PPFCW :: NOTPRESENT ) } # [ doc = "Present." ] # [ inline ] pub fn present ( self ) -> & 'a mut W { self . variant ( PPFCW :: PRESENT ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Pre-programmed factory code present." ] # [ inline ] pub fn ppfc ( & self ) -> PPFCR { PPFCR :: _from ( { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Pre-programmed factory code present." ] # [ inline ] pub fn ppfc ( & mut self ) -> _PPFCW { _PPFCW { w : self } } } } # [ doc = "Number of individualy controllable RAM blocks." ] pub struct NUMRAMBLOCK { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Number of individualy controllable RAM blocks." ] pub mod numramblock { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: NUMRAMBLOCK { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Size of RAM block in bytes." ] pub struct SIZERAMBLOCK { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Size of RAM block in bytes." ] pub mod sizeramblock { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: SIZERAMBLOCK { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Configuration identifier." ] pub struct CONFIGID { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Configuration identifier." ] pub mod configid { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CONFIGID { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = r" Value of the field" ] pub struct HWIDR { bits : u16 , } impl HWIDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Value of the field" ] pub struct FWIDR { bits : u16 , } impl FWIDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } # [ doc = r" Proxy" ] pub struct _HWIDW < 'a > { w : & 'a mut W , } impl < 'a > _HWIDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = r" Proxy" ] pub struct _FWIDW < 'a > { w : & 'a mut W , } impl < 'a > _FWIDW < 'a > { # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { const MASK : u16 = 0xffff ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Hardware Identification Number." ] # [ inline ] pub fn hwid ( & self ) -> HWIDR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; HWIDR { bits } } # [ doc = "Bits 16:31 - Firmware Identification Number pre-loaded into the flash." ] # [ inline ] pub fn fwid ( & self ) -> FWIDR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; FWIDR { bits } } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:15 - Hardware Identification Number." ] # [ inline ] pub fn hwid ( & mut self ) -> _HWIDW { _HWIDW { w : self } } # [ doc = "Bits 16:31 - Firmware Identification Number pre-loaded into the flash." ] # [ inline ] pub fn fwid ( & mut self ) -> _FWIDW { _FWIDW { w : self } } } } # [ doc = "Device identifier." ] pub struct DEVICEID { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Device identifier." ] pub mod deviceid { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DEVICEID { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Encryption root." ] pub struct ER { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Encryption root." ] pub mod er { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: ER { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Identity root." ] pub struct IR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Identity root." ] pub mod ir { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: IR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Device address type." ] pub struct DEVICEADDRTYPE { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Device address type." ] pub mod deviceaddrtype { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DEVICEADDRTYPE { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `DEVICEADDRTYPE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DEVICEADDRTYPER { # [ doc = "Public address." ] PUBLIC , # [ doc = "Random address." ] RANDOM } impl DEVICEADDRTYPER { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DEVICEADDRTYPER :: PUBLIC => false , DEVICEADDRTYPER :: RANDOM => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DEVICEADDRTYPER { match value { false => DEVICEADDRTYPER :: PUBLIC , true => DEVICEADDRTYPER :: RANDOM , } } # [ doc = "Checks if the value of the field is `PUBLIC`" ] # [ inline ] pub fn is_public ( & self ) -> bool { * self == DEVICEADDRTYPER :: PUBLIC } # [ doc = "Checks if the value of the field is `RANDOM`" ] # [ inline ] pub fn is_random ( & self ) -> bool { * self == DEVICEADDRTYPER :: RANDOM } } # [ doc = "Values that can be written to the field `DEVICEADDRTYPE`" ] pub enum DEVICEADDRTYPEW { # [ doc = "Public address." ] PUBLIC , # [ doc = "Random address." ] RANDOM } impl DEVICEADDRTYPEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DEVICEADDRTYPEW :: PUBLIC => false , DEVICEADDRTYPEW :: RANDOM => true } } } # [ doc = r" Proxy" ] pub struct _DEVICEADDRTYPEW < 'a > { w : & 'a mut W , } impl < 'a > _DEVICEADDRTYPEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DEVICEADDRTYPEW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Public address." ] # [ inline ] pub fn public ( self ) -> & 'a mut W { self . variant ( DEVICEADDRTYPEW :: PUBLIC ) } # [ doc = "Random address." ] # [ inline ] pub fn random ( self ) -> & 'a mut W { self . variant ( DEVICEADDRTYPEW :: RANDOM ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Device address type." ] # [ inline ] pub fn deviceaddrtype ( & self ) -> DEVICEADDRTYPER { DEVICEADDRTYPER :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Device address type." ] # [ inline ] pub fn deviceaddrtype ( & mut self ) -> _DEVICEADDRTYPEW { _DEVICEADDRTYPEW { w : self } } } } # [ doc = "Device address." ] pub struct DEVICEADDR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Device address." ] pub mod deviceaddr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DEVICEADDR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } } # [ doc = "User Information Configuration." ] pub struct UICR { _marker : PhantomData < * const ( ) > } unsafe impl Send for UICR { } impl UICR { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const uicr :: RegisterBlock { 0x1000_1000 as * const _ } } impl Deref for UICR { type Target = uicr :: RegisterBlock ; fn deref ( & self ) -> & uicr :: RegisterBlock { unsafe { & * UICR :: ptr ( ) } } } # [ doc = "User Information Configuration." ] pub mod uicr { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Length of code region 0." ] pub clenr0 : CLENR0 , # [ doc = "0x04 - Readback protection configuration." ] pub rbpconf : RBPCONF , # [ doc = "0x08 - Reset value for CLOCK XTALFREQ register." ] pub xtalfreq : XTALFREQ , _reserved0 : [ u8 ; 4usize ] , # [ doc = "0x10 - Firmware ID." ] pub fwid : FWID , } # [ doc = "Length of code region 0." ] pub struct CLENR0 { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Length of code region 0." ] pub mod clenr0 { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: CLENR0 { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } } } # [ doc = "Readback protection configuration." ] pub struct RBPCONF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Readback protection configuration." ] pub mod rbpconf { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: RBPCONF { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PR0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PR0R { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl PR0R { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PR0R :: DISABLED => 0xff , PR0R :: ENABLED => 0 , PR0R :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PR0R { match value { 255 => PR0R :: DISABLED , 0 => PR0R :: ENABLED , i => PR0R :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PR0R :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PR0R :: ENABLED } } # [ doc = "Possible values of the field `PALL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PALLR { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl PALLR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PALLR :: DISABLED => 0xff , PALLR :: ENABLED => 0 , PALLR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PALLR { match value { 255 => PALLR :: DISABLED , 0 => PALLR :: ENABLED , i => PALLR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PALLR :: DISABLED } # [ doc = "Checks if the value of the field is `ENABLED`" ] # [ inline ] pub fn is_enabled ( & self ) -> bool { * self == PALLR :: ENABLED } } # [ doc = "Values that can be written to the field `PR0`" ] pub enum PR0W { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl PR0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PR0W :: DISABLED => 255 , PR0W :: ENABLED => 0 } } } # [ doc = r" Proxy" ] pub struct _PR0W < 'a > { w : & 'a mut W , } impl < 'a > _PR0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PR0W ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PR0W :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PR0W :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PALL`" ] pub enum PALLW { # [ doc = "Disabled." ] DISABLED , # [ doc = "Enabled." ] ENABLED } impl PALLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PALLW :: DISABLED => 255 , PALLW :: ENABLED => 0 } } } # [ doc = r" Proxy" ] pub struct _PALLW < 'a > { w : & 'a mut W , } impl < 'a > _PALLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PALLW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PALLW :: DISABLED ) } # [ doc = "Enabled." ] # [ inline ] pub fn enabled ( self ) -> & 'a mut W { self . variant ( PALLW :: ENABLED ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip." ] # [ inline ] pub fn pr0 ( & self ) -> PR0R { PR0R :: _from ( { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:15 - Readback protect all code in the device." ] # [ inline ] pub fn pall ( & self ) -> PALLR { PALLR :: _from ( { const MASK : u8 = 0xff ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip." ] # [ inline ] pub fn pr0 ( & mut self ) -> _PR0W { _PR0W { w : self } } # [ doc = "Bits 8:15 - Readback protect all code in the device." ] # [ inline ] pub fn pall ( & mut self ) -> _PALLW { _PALLW { w : self } } } } # [ doc = "Reset value for CLOCK XTALFREQ register." ] pub struct XTALFREQ { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Reset value for CLOCK XTALFREQ register." ] pub mod xtalfreq { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: XTALFREQ { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `XTALFREQ`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum XTALFREQR { # [ doc = "16MHz Xtal is used." ] _16MHZ , # [ doc = "32MHz Xtal is used." ] _32MHZ , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl XTALFREQR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { XTALFREQR :: _16MHZ => 0xff , XTALFREQR :: _32MHZ => 0 , XTALFREQR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> XTALFREQR { match value { 255 => XTALFREQR :: _16MHZ , 0 => XTALFREQR :: _32MHZ , i => XTALFREQR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `_16MHZ`" ] # [ inline ] pub fn is_16mhz ( & self ) -> bool { * self == XTALFREQR :: _16MHZ } # [ doc = "Checks if the value of the field is `_32MHZ`" ] # [ inline ] pub fn is_32mhz ( & self ) -> bool { * self == XTALFREQR :: _32MHZ } } # [ doc = "Values that can be written to the field `XTALFREQ`" ] pub enum XTALFREQW { # [ doc = "16MHz Xtal is used." ] _16MHZ , # [ doc = "32MHz Xtal is used." ] _32MHZ } impl XTALFREQW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { XTALFREQW :: _16MHZ => 255 , XTALFREQW :: _32MHZ => 0 } } } # [ doc = r" Proxy" ] pub struct _XTALFREQW < 'a > { w : & 'a mut W , } impl < 'a > _XTALFREQW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : XTALFREQW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "16MHz Xtal is used." ] # [ inline ] pub fn _16mhz ( self ) -> & 'a mut W { self . variant ( XTALFREQW :: _16MHZ ) } # [ doc = "32MHz Xtal is used." ] # [ inline ] pub fn _32mhz ( self ) -> & 'a mut W { self . variant ( XTALFREQW :: _32MHZ ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:7 - Reset value for CLOCK XTALFREQ register." ] # [ inline ] pub fn xtalfreq ( & self ) -> XTALFREQR { XTALFREQR :: _from ( { const MASK : u8 = 0xff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bits 0:7 - Reset value for CLOCK XTALFREQ register." ] # [ inline ] pub fn xtalfreq ( & mut self ) -> _XTALFREQW { _XTALFREQW { w : self } } } } # [ doc = "Firmware ID." ] pub struct FWID { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Firmware ID." ] pub mod fwid { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: FWID { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = r" Value of the field" ] pub struct FWIDR { bits : u16 , } impl FWIDR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u16 { self . bits } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bits 0:15 - Identification number for the firmware loaded into the chip." ] # [ inline ] pub fn fwid ( & self ) -> FWIDR { let bits = { const MASK : u16 = 0xffff ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u16 } ; FWIDR { bits } } } } } # [ doc = "General purpose input and output." ] pub struct GPIO { _marker : PhantomData < * const ( ) > } unsafe impl Send for GPIO { } impl GPIO { # [ doc = r" Returns a pointer to the register block" ] pub fn ptr ( ) -> * const gpio :: RegisterBlock { 0x5000_0000 as * const _ } } impl Deref for GPIO { type Target = gpio :: RegisterBlock ; fn deref ( & self ) -> & gpio :: RegisterBlock { unsafe { & * GPIO :: ptr ( ) } } } # [ doc = "General purpose input and output." ] pub mod gpio { # [ doc = r" Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1284usize ] , # [ doc = "0x504 - Write GPIO port." ] pub out : OUT , # [ doc = "0x508 - Set individual bits in GPIO port." ] pub outset : OUTSET , # [ doc = "0x50c - Clear individual bits in GPIO port." ] pub outclr : OUTCLR , # [ doc = "0x510 - Read GPIO port." ] pub in_ : IN , # [ doc = "0x514 - Direction of GPIO pins." ] pub dir : DIR , # [ doc = "0x518 - DIR set register." ] pub dirset : DIRSET , # [ doc = "0x51c - DIR clear register." ] pub dirclr : DIRCLR , _reserved1 : [ u8 ; 480usize ] , # [ doc = "0x700 - Configuration of GPIO pins." ] pub pin_cnf : [ PIN_CNF ; 32 ] , } # [ doc = "Write GPIO port." ] pub struct OUT { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Write GPIO port." ] pub mod out { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: OUT { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PIN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN0R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN0R :: LOW => false , PIN0R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN0R { match value { false => PIN0R :: LOW , true => PIN0R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN0R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN0R :: HIGH } } # [ doc = "Possible values of the field `PIN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN1R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN1R :: LOW => false , PIN1R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN1R { match value { false => PIN1R :: LOW , true => PIN1R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN1R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN1R :: HIGH } } # [ doc = "Possible values of the field `PIN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN2R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN2R :: LOW => false , PIN2R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN2R { match value { false => PIN2R :: LOW , true => PIN2R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN2R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN2R :: HIGH } } # [ doc = "Possible values of the field `PIN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN3R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN3R :: LOW => false , PIN3R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN3R { match value { false => PIN3R :: LOW , true => PIN3R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN3R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN3R :: HIGH } } # [ doc = "Possible values of the field `PIN4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN4R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN4R :: LOW => false , PIN4R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN4R { match value { false => PIN4R :: LOW , true => PIN4R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN4R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN4R :: HIGH } } # [ doc = "Possible values of the field `PIN5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN5R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN5R :: LOW => false , PIN5R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN5R { match value { false => PIN5R :: LOW , true => PIN5R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN5R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN5R :: HIGH } } # [ doc = "Possible values of the field `PIN6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN6R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN6R :: LOW => false , PIN6R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN6R { match value { false => PIN6R :: LOW , true => PIN6R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN6R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN6R :: HIGH } } # [ doc = "Possible values of the field `PIN7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN7R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN7R :: LOW => false , PIN7R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN7R { match value { false => PIN7R :: LOW , true => PIN7R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN7R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN7R :: HIGH } } # [ doc = "Possible values of the field `PIN8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN8R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN8R :: LOW => false , PIN8R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN8R { match value { false => PIN8R :: LOW , true => PIN8R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN8R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN8R :: HIGH } } # [ doc = "Possible values of the field `PIN9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN9R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN9R :: LOW => false , PIN9R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN9R { match value { false => PIN9R :: LOW , true => PIN9R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN9R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN9R :: HIGH } } # [ doc = "Possible values of the field `PIN10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN10R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN10R :: LOW => false , PIN10R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN10R { match value { false => PIN10R :: LOW , true => PIN10R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN10R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN10R :: HIGH } } # [ doc = "Possible values of the field `PIN11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN11R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN11R :: LOW => false , PIN11R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN11R { match value { false => PIN11R :: LOW , true => PIN11R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN11R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN11R :: HIGH } } # [ doc = "Possible values of the field `PIN12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN12R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN12R :: LOW => false , PIN12R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN12R { match value { false => PIN12R :: LOW , true => PIN12R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN12R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN12R :: HIGH } } # [ doc = "Possible values of the field `PIN13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN13R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN13R :: LOW => false , PIN13R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN13R { match value { false => PIN13R :: LOW , true => PIN13R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN13R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN13R :: HIGH } } # [ doc = "Possible values of the field `PIN14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN14R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN14R :: LOW => false , PIN14R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN14R { match value { false => PIN14R :: LOW , true => PIN14R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN14R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN14R :: HIGH } } # [ doc = "Possible values of the field `PIN15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN15R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN15R :: LOW => false , PIN15R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN15R { match value { false => PIN15R :: LOW , true => PIN15R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN15R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN15R :: HIGH } } # [ doc = "Possible values of the field `PIN16`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN16R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN16R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN16R :: LOW => false , PIN16R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN16R { match value { false => PIN16R :: LOW , true => PIN16R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN16R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN16R :: HIGH } } # [ doc = "Possible values of the field `PIN17`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN17R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN17R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN17R :: LOW => false , PIN17R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN17R { match value { false => PIN17R :: LOW , true => PIN17R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN17R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN17R :: HIGH } } # [ doc = "Possible values of the field `PIN18`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN18R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN18R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN18R :: LOW => false , PIN18R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN18R { match value { false => PIN18R :: LOW , true => PIN18R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN18R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN18R :: HIGH } } # [ doc = "Possible values of the field `PIN19`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN19R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN19R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN19R :: LOW => false , PIN19R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN19R { match value { false => PIN19R :: LOW , true => PIN19R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN19R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN19R :: HIGH } } # [ doc = "Possible values of the field `PIN20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN20R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN20R :: LOW => false , PIN20R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN20R { match value { false => PIN20R :: LOW , true => PIN20R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN20R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN20R :: HIGH } } # [ doc = "Possible values of the field `PIN21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN21R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN21R :: LOW => false , PIN21R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN21R { match value { false => PIN21R :: LOW , true => PIN21R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN21R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN21R :: HIGH } } # [ doc = "Possible values of the field `PIN22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN22R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN22R :: LOW => false , PIN22R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN22R { match value { false => PIN22R :: LOW , true => PIN22R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN22R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN22R :: HIGH } } # [ doc = "Possible values of the field `PIN23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN23R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN23R :: LOW => false , PIN23R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN23R { match value { false => PIN23R :: LOW , true => PIN23R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN23R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN23R :: HIGH } } # [ doc = "Possible values of the field `PIN24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN24R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN24R :: LOW => false , PIN24R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN24R { match value { false => PIN24R :: LOW , true => PIN24R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN24R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN24R :: HIGH } } # [ doc = "Possible values of the field `PIN25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN25R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN25R :: LOW => false , PIN25R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN25R { match value { false => PIN25R :: LOW , true => PIN25R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN25R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN25R :: HIGH } } # [ doc = "Possible values of the field `PIN26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN26R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN26R :: LOW => false , PIN26R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN26R { match value { false => PIN26R :: LOW , true => PIN26R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN26R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN26R :: HIGH } } # [ doc = "Possible values of the field `PIN27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN27R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN27R :: LOW => false , PIN27R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN27R { match value { false => PIN27R :: LOW , true => PIN27R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN27R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN27R :: HIGH } } # [ doc = "Possible values of the field `PIN28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN28R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN28R :: LOW => false , PIN28R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN28R { match value { false => PIN28R :: LOW , true => PIN28R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN28R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN28R :: HIGH } } # [ doc = "Possible values of the field `PIN29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN29R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN29R :: LOW => false , PIN29R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN29R { match value { false => PIN29R :: LOW , true => PIN29R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN29R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN29R :: HIGH } } # [ doc = "Possible values of the field `PIN30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN30R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN30R :: LOW => false , PIN30R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN30R { match value { false => PIN30R :: LOW , true => PIN30R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN30R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN30R :: HIGH } } # [ doc = "Possible values of the field `PIN31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN31R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN31R :: LOW => false , PIN31R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN31R { match value { false => PIN31R :: LOW , true => PIN31R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN31R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN31R :: HIGH } } # [ doc = "Values that can be written to the field `PIN0`" ] pub enum PIN0W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN0W :: LOW => false , PIN0W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN0W < 'a > { w : & 'a mut W , } impl < 'a > _PIN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN0W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN0W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN1`" ] pub enum PIN1W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN1W :: LOW => false , PIN1W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN1W < 'a > { w : & 'a mut W , } impl < 'a > _PIN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN1W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN1W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN2`" ] pub enum PIN2W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN2W :: LOW => false , PIN2W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN2W < 'a > { w : & 'a mut W , } impl < 'a > _PIN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN2W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN2W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN3`" ] pub enum PIN3W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN3W :: LOW => false , PIN3W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN3W < 'a > { w : & 'a mut W , } impl < 'a > _PIN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN3W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN3W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN4`" ] pub enum PIN4W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN4W :: LOW => false , PIN4W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN4W < 'a > { w : & 'a mut W , } impl < 'a > _PIN4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN4W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN4W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN5`" ] pub enum PIN5W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN5W :: LOW => false , PIN5W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN5W < 'a > { w : & 'a mut W , } impl < 'a > _PIN5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN5W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN5W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN6`" ] pub enum PIN6W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN6W :: LOW => false , PIN6W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN6W < 'a > { w : & 'a mut W , } impl < 'a > _PIN6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN6W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN6W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN7`" ] pub enum PIN7W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN7W :: LOW => false , PIN7W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN7W < 'a > { w : & 'a mut W , } impl < 'a > _PIN7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN7W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN7W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN8`" ] pub enum PIN8W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN8W :: LOW => false , PIN8W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN8W < 'a > { w : & 'a mut W , } impl < 'a > _PIN8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN8W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN8W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN9`" ] pub enum PIN9W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN9W :: LOW => false , PIN9W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN9W < 'a > { w : & 'a mut W , } impl < 'a > _PIN9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN9W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN9W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN10`" ] pub enum PIN10W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN10W :: LOW => false , PIN10W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN10W < 'a > { w : & 'a mut W , } impl < 'a > _PIN10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN10W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN10W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN11`" ] pub enum PIN11W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN11W :: LOW => false , PIN11W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN11W < 'a > { w : & 'a mut W , } impl < 'a > _PIN11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN11W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN11W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN12`" ] pub enum PIN12W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN12W :: LOW => false , PIN12W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN12W < 'a > { w : & 'a mut W , } impl < 'a > _PIN12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN12W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN12W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN13`" ] pub enum PIN13W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN13W :: LOW => false , PIN13W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN13W < 'a > { w : & 'a mut W , } impl < 'a > _PIN13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN13W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN13W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN14`" ] pub enum PIN14W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN14W :: LOW => false , PIN14W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN14W < 'a > { w : & 'a mut W , } impl < 'a > _PIN14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN14W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN14W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN15`" ] pub enum PIN15W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN15W :: LOW => false , PIN15W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN15W < 'a > { w : & 'a mut W , } impl < 'a > _PIN15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN15W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN15W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN16`" ] pub enum PIN16W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN16W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN16W :: LOW => false , PIN16W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN16W < 'a > { w : & 'a mut W , } impl < 'a > _PIN16W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN16W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN16W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN16W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN17`" ] pub enum PIN17W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN17W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN17W :: LOW => false , PIN17W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN17W < 'a > { w : & 'a mut W , } impl < 'a > _PIN17W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN17W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN17W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN17W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN18`" ] pub enum PIN18W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN18W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN18W :: LOW => false , PIN18W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN18W < 'a > { w : & 'a mut W , } impl < 'a > _PIN18W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN18W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN18W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN18W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN19`" ] pub enum PIN19W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN19W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN19W :: LOW => false , PIN19W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN19W < 'a > { w : & 'a mut W , } impl < 'a > _PIN19W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN19W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN19W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN19W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN20`" ] pub enum PIN20W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN20W :: LOW => false , PIN20W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN20W < 'a > { w : & 'a mut W , } impl < 'a > _PIN20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN20W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN20W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN21`" ] pub enum PIN21W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN21W :: LOW => false , PIN21W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN21W < 'a > { w : & 'a mut W , } impl < 'a > _PIN21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN21W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN21W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN22`" ] pub enum PIN22W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN22W :: LOW => false , PIN22W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN22W < 'a > { w : & 'a mut W , } impl < 'a > _PIN22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN22W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN22W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN23`" ] pub enum PIN23W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN23W :: LOW => false , PIN23W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN23W < 'a > { w : & 'a mut W , } impl < 'a > _PIN23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN23W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN23W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN24`" ] pub enum PIN24W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN24W :: LOW => false , PIN24W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN24W < 'a > { w : & 'a mut W , } impl < 'a > _PIN24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN24W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN24W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN25`" ] pub enum PIN25W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN25W :: LOW => false , PIN25W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN25W < 'a > { w : & 'a mut W , } impl < 'a > _PIN25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN25W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN25W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN26`" ] pub enum PIN26W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN26W :: LOW => false , PIN26W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN26W < 'a > { w : & 'a mut W , } impl < 'a > _PIN26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN26W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN26W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN27`" ] pub enum PIN27W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN27W :: LOW => false , PIN27W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN27W < 'a > { w : & 'a mut W , } impl < 'a > _PIN27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN27W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN27W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN28`" ] pub enum PIN28W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN28W :: LOW => false , PIN28W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN28W < 'a > { w : & 'a mut W , } impl < 'a > _PIN28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN28W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN28W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN29`" ] pub enum PIN29W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN29W :: LOW => false , PIN29W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN29W < 'a > { w : & 'a mut W , } impl < 'a > _PIN29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN29W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN29W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN30`" ] pub enum PIN30W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN30W :: LOW => false , PIN30W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN30W < 'a > { w : & 'a mut W , } impl < 'a > _PIN30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN30W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN30W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN31`" ] pub enum PIN31W { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN31W :: LOW => false , PIN31W :: HIGH => true } } } # [ doc = r" Proxy" ] pub struct _PIN31W < 'a > { w : & 'a mut W , } impl < 'a > _PIN31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin driver is low." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( PIN31W :: LOW ) } # [ doc = "Pin driver is high." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( PIN31W :: HIGH ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Pin 0." ] # [ inline ] pub fn pin0 ( & self ) -> PIN0R { PIN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Pin 1." ] # [ inline ] pub fn pin1 ( & self ) -> PIN1R { PIN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Pin 2." ] # [ inline ] pub fn pin2 ( & self ) -> PIN2R { PIN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Pin 3." ] # [ inline ] pub fn pin3 ( & self ) -> PIN3R { PIN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Pin 4." ] # [ inline ] pub fn pin4 ( & self ) -> PIN4R { PIN4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Pin 5." ] # [ inline ] pub fn pin5 ( & self ) -> PIN5R { PIN5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Pin 6." ] # [ inline ] pub fn pin6 ( & self ) -> PIN6R { PIN6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Pin 7." ] # [ inline ] pub fn pin7 ( & self ) -> PIN7R { PIN7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Pin 8." ] # [ inline ] pub fn pin8 ( & self ) -> PIN8R { PIN8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Pin 9." ] # [ inline ] pub fn pin9 ( & self ) -> PIN9R { PIN9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Pin 10." ] # [ inline ] pub fn pin10 ( & self ) -> PIN10R { PIN10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Pin 11." ] # [ inline ] pub fn pin11 ( & self ) -> PIN11R { PIN11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Pin 12." ] # [ inline ] pub fn pin12 ( & self ) -> PIN12R { PIN12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Pin 13." ] # [ inline ] pub fn pin13 ( & self ) -> PIN13R { PIN13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Pin 14." ] # [ inline ] pub fn pin14 ( & self ) -> PIN14R { PIN14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Pin 15." ] # [ inline ] pub fn pin15 ( & self ) -> PIN15R { PIN15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Pin 16." ] # [ inline ] pub fn pin16 ( & self ) -> PIN16R { PIN16R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Pin 17." ] # [ inline ] pub fn pin17 ( & self ) -> PIN17R { PIN17R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Pin 18." ] # [ inline ] pub fn pin18 ( & self ) -> PIN18R { PIN18R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Pin 19." ] # [ inline ] pub fn pin19 ( & self ) -> PIN19R { PIN19R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Pin 20." ] # [ inline ] pub fn pin20 ( & self ) -> PIN20R { PIN20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Pin 21." ] # [ inline ] pub fn pin21 ( & self ) -> PIN21R { PIN21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Pin 22." ] # [ inline ] pub fn pin22 ( & self ) -> PIN22R { PIN22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Pin 23." ] # [ inline ] pub fn pin23 ( & self ) -> PIN23R { PIN23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Pin 24." ] # [ inline ] pub fn pin24 ( & self ) -> PIN24R { PIN24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Pin 25." ] # [ inline ] pub fn pin25 ( & self ) -> PIN25R { PIN25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Pin 26." ] # [ inline ] pub fn pin26 ( & self ) -> PIN26R { PIN26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Pin 27." ] # [ inline ] pub fn pin27 ( & self ) -> PIN27R { PIN27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Pin 28." ] # [ inline ] pub fn pin28 ( & self ) -> PIN28R { PIN28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Pin 29." ] # [ inline ] pub fn pin29 ( & self ) -> PIN29R { PIN29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Pin 30." ] # [ inline ] pub fn pin30 ( & self ) -> PIN30R { PIN30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Pin 31." ] # [ inline ] pub fn pin31 ( & self ) -> PIN31R { PIN31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Pin 0." ] # [ inline ] pub fn pin0 ( & mut self ) -> _PIN0W { _PIN0W { w : self } } # [ doc = "Bit 1 - Pin 1." ] # [ inline ] pub fn pin1 ( & mut self ) -> _PIN1W { _PIN1W { w : self } } # [ doc = "Bit 2 - Pin 2." ] # [ inline ] pub fn pin2 ( & mut self ) -> _PIN2W { _PIN2W { w : self } } # [ doc = "Bit 3 - Pin 3." ] # [ inline ] pub fn pin3 ( & mut self ) -> _PIN3W { _PIN3W { w : self } } # [ doc = "Bit 4 - Pin 4." ] # [ inline ] pub fn pin4 ( & mut self ) -> _PIN4W { _PIN4W { w : self } } # [ doc = "Bit 5 - Pin 5." ] # [ inline ] pub fn pin5 ( & mut self ) -> _PIN5W { _PIN5W { w : self } } # [ doc = "Bit 6 - Pin 6." ] # [ inline ] pub fn pin6 ( & mut self ) -> _PIN6W { _PIN6W { w : self } } # [ doc = "Bit 7 - Pin 7." ] # [ inline ] pub fn pin7 ( & mut self ) -> _PIN7W { _PIN7W { w : self } } # [ doc = "Bit 8 - Pin 8." ] # [ inline ] pub fn pin8 ( & mut self ) -> _PIN8W { _PIN8W { w : self } } # [ doc = "Bit 9 - Pin 9." ] # [ inline ] pub fn pin9 ( & mut self ) -> _PIN9W { _PIN9W { w : self } } # [ doc = "Bit 10 - Pin 10." ] # [ inline ] pub fn pin10 ( & mut self ) -> _PIN10W { _PIN10W { w : self } } # [ doc = "Bit 11 - Pin 11." ] # [ inline ] pub fn pin11 ( & mut self ) -> _PIN11W { _PIN11W { w : self } } # [ doc = "Bit 12 - Pin 12." ] # [ inline ] pub fn pin12 ( & mut self ) -> _PIN12W { _PIN12W { w : self } } # [ doc = "Bit 13 - Pin 13." ] # [ inline ] pub fn pin13 ( & mut self ) -> _PIN13W { _PIN13W { w : self } } # [ doc = "Bit 14 - Pin 14." ] # [ inline ] pub fn pin14 ( & mut self ) -> _PIN14W { _PIN14W { w : self } } # [ doc = "Bit 15 - Pin 15." ] # [ inline ] pub fn pin15 ( & mut self ) -> _PIN15W { _PIN15W { w : self } } # [ doc = "Bit 16 - Pin 16." ] # [ inline ] pub fn pin16 ( & mut self ) -> _PIN16W { _PIN16W { w : self } } # [ doc = "Bit 17 - Pin 17." ] # [ inline ] pub fn pin17 ( & mut self ) -> _PIN17W { _PIN17W { w : self } } # [ doc = "Bit 18 - Pin 18." ] # [ inline ] pub fn pin18 ( & mut self ) -> _PIN18W { _PIN18W { w : self } } # [ doc = "Bit 19 - Pin 19." ] # [ inline ] pub fn pin19 ( & mut self ) -> _PIN19W { _PIN19W { w : self } } # [ doc = "Bit 20 - Pin 20." ] # [ inline ] pub fn pin20 ( & mut self ) -> _PIN20W { _PIN20W { w : self } } # [ doc = "Bit 21 - Pin 21." ] # [ inline ] pub fn pin21 ( & mut self ) -> _PIN21W { _PIN21W { w : self } } # [ doc = "Bit 22 - Pin 22." ] # [ inline ] pub fn pin22 ( & mut self ) -> _PIN22W { _PIN22W { w : self } } # [ doc = "Bit 23 - Pin 23." ] # [ inline ] pub fn pin23 ( & mut self ) -> _PIN23W { _PIN23W { w : self } } # [ doc = "Bit 24 - Pin 24." ] # [ inline ] pub fn pin24 ( & mut self ) -> _PIN24W { _PIN24W { w : self } } # [ doc = "Bit 25 - Pin 25." ] # [ inline ] pub fn pin25 ( & mut self ) -> _PIN25W { _PIN25W { w : self } } # [ doc = "Bit 26 - Pin 26." ] # [ inline ] pub fn pin26 ( & mut self ) -> _PIN26W { _PIN26W { w : self } } # [ doc = "Bit 27 - Pin 27." ] # [ inline ] pub fn pin27 ( & mut self ) -> _PIN27W { _PIN27W { w : self } } # [ doc = "Bit 28 - Pin 28." ] # [ inline ] pub fn pin28 ( & mut self ) -> _PIN28W { _PIN28W { w : self } } # [ doc = "Bit 29 - Pin 29." ] # [ inline ] pub fn pin29 ( & mut self ) -> _PIN29W { _PIN29W { w : self } } # [ doc = "Bit 30 - Pin 30." ] # [ inline ] pub fn pin30 ( & mut self ) -> _PIN30W { _PIN30W { w : self } } # [ doc = "Bit 31 - Pin 31." ] # [ inline ] pub fn pin31 ( & mut self ) -> _PIN31W { _PIN31W { w : self } } } } # [ doc = "Set individual bits in GPIO port." ] pub struct OUTSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Set individual bits in GPIO port." ] pub mod outset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: OUTSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PIN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN0R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN0R :: LOW => false , PIN0R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN0R { match value { false => PIN0R :: LOW , true => PIN0R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN0R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN0R :: HIGH } } # [ doc = "Possible values of the field `PIN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN1R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN1R :: LOW => false , PIN1R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN1R { match value { false => PIN1R :: LOW , true => PIN1R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN1R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN1R :: HIGH } } # [ doc = "Possible values of the field `PIN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN2R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN2R :: LOW => false , PIN2R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN2R { match value { false => PIN2R :: LOW , true => PIN2R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN2R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN2R :: HIGH } } # [ doc = "Possible values of the field `PIN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN3R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN3R :: LOW => false , PIN3R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN3R { match value { false => PIN3R :: LOW , true => PIN3R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN3R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN3R :: HIGH } } # [ doc = "Possible values of the field `PIN4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN4R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN4R :: LOW => false , PIN4R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN4R { match value { false => PIN4R :: LOW , true => PIN4R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN4R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN4R :: HIGH } } # [ doc = "Possible values of the field `PIN5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN5R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN5R :: LOW => false , PIN5R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN5R { match value { false => PIN5R :: LOW , true => PIN5R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN5R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN5R :: HIGH } } # [ doc = "Possible values of the field `PIN6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN6R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN6R :: LOW => false , PIN6R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN6R { match value { false => PIN6R :: LOW , true => PIN6R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN6R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN6R :: HIGH } } # [ doc = "Possible values of the field `PIN7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN7R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN7R :: LOW => false , PIN7R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN7R { match value { false => PIN7R :: LOW , true => PIN7R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN7R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN7R :: HIGH } } # [ doc = "Possible values of the field `PIN8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN8R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN8R :: LOW => false , PIN8R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN8R { match value { false => PIN8R :: LOW , true => PIN8R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN8R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN8R :: HIGH } } # [ doc = "Possible values of the field `PIN9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN9R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN9R :: LOW => false , PIN9R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN9R { match value { false => PIN9R :: LOW , true => PIN9R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN9R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN9R :: HIGH } } # [ doc = "Possible values of the field `PIN10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN10R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN10R :: LOW => false , PIN10R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN10R { match value { false => PIN10R :: LOW , true => PIN10R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN10R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN10R :: HIGH } } # [ doc = "Possible values of the field `PIN11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN11R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN11R :: LOW => false , PIN11R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN11R { match value { false => PIN11R :: LOW , true => PIN11R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN11R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN11R :: HIGH } } # [ doc = "Possible values of the field `PIN12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN12R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN12R :: LOW => false , PIN12R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN12R { match value { false => PIN12R :: LOW , true => PIN12R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN12R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN12R :: HIGH } } # [ doc = "Possible values of the field `PIN13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN13R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN13R :: LOW => false , PIN13R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN13R { match value { false => PIN13R :: LOW , true => PIN13R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN13R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN13R :: HIGH } } # [ doc = "Possible values of the field `PIN14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN14R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN14R :: LOW => false , PIN14R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN14R { match value { false => PIN14R :: LOW , true => PIN14R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN14R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN14R :: HIGH } } # [ doc = "Possible values of the field `PIN15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN15R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN15R :: LOW => false , PIN15R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN15R { match value { false => PIN15R :: LOW , true => PIN15R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN15R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN15R :: HIGH } } # [ doc = "Possible values of the field `PIN16`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN16R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN16R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN16R :: LOW => false , PIN16R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN16R { match value { false => PIN16R :: LOW , true => PIN16R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN16R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN16R :: HIGH } } # [ doc = "Possible values of the field `PIN17`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN17R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN17R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN17R :: LOW => false , PIN17R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN17R { match value { false => PIN17R :: LOW , true => PIN17R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN17R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN17R :: HIGH } } # [ doc = "Possible values of the field `PIN18`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN18R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN18R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN18R :: LOW => false , PIN18R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN18R { match value { false => PIN18R :: LOW , true => PIN18R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN18R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN18R :: HIGH } } # [ doc = "Possible values of the field `PIN19`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN19R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN19R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN19R :: LOW => false , PIN19R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN19R { match value { false => PIN19R :: LOW , true => PIN19R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN19R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN19R :: HIGH } } # [ doc = "Possible values of the field `PIN20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN20R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN20R :: LOW => false , PIN20R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN20R { match value { false => PIN20R :: LOW , true => PIN20R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN20R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN20R :: HIGH } } # [ doc = "Possible values of the field `PIN21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN21R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN21R :: LOW => false , PIN21R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN21R { match value { false => PIN21R :: LOW , true => PIN21R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN21R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN21R :: HIGH } } # [ doc = "Possible values of the field `PIN22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN22R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN22R :: LOW => false , PIN22R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN22R { match value { false => PIN22R :: LOW , true => PIN22R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN22R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN22R :: HIGH } } # [ doc = "Possible values of the field `PIN23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN23R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN23R :: LOW => false , PIN23R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN23R { match value { false => PIN23R :: LOW , true => PIN23R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN23R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN23R :: HIGH } } # [ doc = "Possible values of the field `PIN24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN24R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN24R :: LOW => false , PIN24R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN24R { match value { false => PIN24R :: LOW , true => PIN24R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN24R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN24R :: HIGH } } # [ doc = "Possible values of the field `PIN25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN25R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN25R :: LOW => false , PIN25R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN25R { match value { false => PIN25R :: LOW , true => PIN25R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN25R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN25R :: HIGH } } # [ doc = "Possible values of the field `PIN26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN26R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN26R :: LOW => false , PIN26R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN26R { match value { false => PIN26R :: LOW , true => PIN26R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN26R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN26R :: HIGH } } # [ doc = "Possible values of the field `PIN27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN27R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN27R :: LOW => false , PIN27R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN27R { match value { false => PIN27R :: LOW , true => PIN27R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN27R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN27R :: HIGH } } # [ doc = "Possible values of the field `PIN28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN28R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN28R :: LOW => false , PIN28R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN28R { match value { false => PIN28R :: LOW , true => PIN28R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN28R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN28R :: HIGH } } # [ doc = "Possible values of the field `PIN29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN29R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN29R :: LOW => false , PIN29R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN29R { match value { false => PIN29R :: LOW , true => PIN29R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN29R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN29R :: HIGH } } # [ doc = "Possible values of the field `PIN30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN30R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN30R :: LOW => false , PIN30R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN30R { match value { false => PIN30R :: LOW , true => PIN30R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN30R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN30R :: HIGH } } # [ doc = "Possible values of the field `PIN31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN31R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN31R :: LOW => false , PIN31R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN31R { match value { false => PIN31R :: LOW , true => PIN31R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN31R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN31R :: HIGH } } # [ doc = "Values that can be written to the field `PIN0`" ] pub enum PIN0W { # [ doc = "Set pin driver high." ] SET } impl PIN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN0W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN0W < 'a > { w : & 'a mut W , } impl < 'a > _PIN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN0W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN1`" ] pub enum PIN1W { # [ doc = "Set pin driver high." ] SET } impl PIN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN1W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN1W < 'a > { w : & 'a mut W , } impl < 'a > _PIN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN1W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN2`" ] pub enum PIN2W { # [ doc = "Set pin driver high." ] SET } impl PIN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN2W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN2W < 'a > { w : & 'a mut W , } impl < 'a > _PIN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN2W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN3`" ] pub enum PIN3W { # [ doc = "Set pin driver high." ] SET } impl PIN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN3W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN3W < 'a > { w : & 'a mut W , } impl < 'a > _PIN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN3W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN4`" ] pub enum PIN4W { # [ doc = "Set pin driver high." ] SET } impl PIN4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN4W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN4W < 'a > { w : & 'a mut W , } impl < 'a > _PIN4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN4W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN5`" ] pub enum PIN5W { # [ doc = "Set pin driver high." ] SET } impl PIN5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN5W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN5W < 'a > { w : & 'a mut W , } impl < 'a > _PIN5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN5W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN6`" ] pub enum PIN6W { # [ doc = "Set pin driver high." ] SET } impl PIN6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN6W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN6W < 'a > { w : & 'a mut W , } impl < 'a > _PIN6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN6W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN7`" ] pub enum PIN7W { # [ doc = "Set pin driver high." ] SET } impl PIN7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN7W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN7W < 'a > { w : & 'a mut W , } impl < 'a > _PIN7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN7W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN8`" ] pub enum PIN8W { # [ doc = "Set pin driver high." ] SET } impl PIN8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN8W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN8W < 'a > { w : & 'a mut W , } impl < 'a > _PIN8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN8W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN9`" ] pub enum PIN9W { # [ doc = "Set pin driver high." ] SET } impl PIN9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN9W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN9W < 'a > { w : & 'a mut W , } impl < 'a > _PIN9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN9W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN10`" ] pub enum PIN10W { # [ doc = "Set pin driver high." ] SET } impl PIN10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN10W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN10W < 'a > { w : & 'a mut W , } impl < 'a > _PIN10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN10W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN11`" ] pub enum PIN11W { # [ doc = "Set pin driver high." ] SET } impl PIN11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN11W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN11W < 'a > { w : & 'a mut W , } impl < 'a > _PIN11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN11W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN12`" ] pub enum PIN12W { # [ doc = "Set pin driver high." ] SET } impl PIN12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN12W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN12W < 'a > { w : & 'a mut W , } impl < 'a > _PIN12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN12W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN13`" ] pub enum PIN13W { # [ doc = "Set pin driver high." ] SET } impl PIN13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN13W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN13W < 'a > { w : & 'a mut W , } impl < 'a > _PIN13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN13W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN14`" ] pub enum PIN14W { # [ doc = "Set pin driver high." ] SET } impl PIN14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN14W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN14W < 'a > { w : & 'a mut W , } impl < 'a > _PIN14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN14W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN15`" ] pub enum PIN15W { # [ doc = "Set pin driver high." ] SET } impl PIN15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN15W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN15W < 'a > { w : & 'a mut W , } impl < 'a > _PIN15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN15W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN16`" ] pub enum PIN16W { # [ doc = "Set pin driver high." ] SET } impl PIN16W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN16W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN16W < 'a > { w : & 'a mut W , } impl < 'a > _PIN16W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN16W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN16W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN17`" ] pub enum PIN17W { # [ doc = "Set pin driver high." ] SET } impl PIN17W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN17W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN17W < 'a > { w : & 'a mut W , } impl < 'a > _PIN17W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN17W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN17W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN18`" ] pub enum PIN18W { # [ doc = "Set pin driver high." ] SET } impl PIN18W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN18W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN18W < 'a > { w : & 'a mut W , } impl < 'a > _PIN18W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN18W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN18W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN19`" ] pub enum PIN19W { # [ doc = "Set pin driver high." ] SET } impl PIN19W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN19W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN19W < 'a > { w : & 'a mut W , } impl < 'a > _PIN19W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN19W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN19W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN20`" ] pub enum PIN20W { # [ doc = "Set pin driver high." ] SET } impl PIN20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN20W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN20W < 'a > { w : & 'a mut W , } impl < 'a > _PIN20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN20W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN21`" ] pub enum PIN21W { # [ doc = "Set pin driver high." ] SET } impl PIN21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN21W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN21W < 'a > { w : & 'a mut W , } impl < 'a > _PIN21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN21W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN22`" ] pub enum PIN22W { # [ doc = "Set pin driver high." ] SET } impl PIN22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN22W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN22W < 'a > { w : & 'a mut W , } impl < 'a > _PIN22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN22W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN23`" ] pub enum PIN23W { # [ doc = "Set pin driver high." ] SET } impl PIN23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN23W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN23W < 'a > { w : & 'a mut W , } impl < 'a > _PIN23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN23W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN24`" ] pub enum PIN24W { # [ doc = "Set pin driver high." ] SET } impl PIN24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN24W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN24W < 'a > { w : & 'a mut W , } impl < 'a > _PIN24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN24W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN25`" ] pub enum PIN25W { # [ doc = "Set pin driver high." ] SET } impl PIN25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN25W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN25W < 'a > { w : & 'a mut W , } impl < 'a > _PIN25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN25W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN26`" ] pub enum PIN26W { # [ doc = "Set pin driver high." ] SET } impl PIN26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN26W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN26W < 'a > { w : & 'a mut W , } impl < 'a > _PIN26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN26W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN27`" ] pub enum PIN27W { # [ doc = "Set pin driver high." ] SET } impl PIN27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN27W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN27W < 'a > { w : & 'a mut W , } impl < 'a > _PIN27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN27W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN28`" ] pub enum PIN28W { # [ doc = "Set pin driver high." ] SET } impl PIN28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN28W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN28W < 'a > { w : & 'a mut W , } impl < 'a > _PIN28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN28W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN29`" ] pub enum PIN29W { # [ doc = "Set pin driver high." ] SET } impl PIN29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN29W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN29W < 'a > { w : & 'a mut W , } impl < 'a > _PIN29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN29W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN30`" ] pub enum PIN30W { # [ doc = "Set pin driver high." ] SET } impl PIN30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN30W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN30W < 'a > { w : & 'a mut W , } impl < 'a > _PIN30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN30W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN31`" ] pub enum PIN31W { # [ doc = "Set pin driver high." ] SET } impl PIN31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN31W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN31W < 'a > { w : & 'a mut W , } impl < 'a > _PIN31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver high." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN31W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Pin 0." ] # [ inline ] pub fn pin0 ( & self ) -> PIN0R { PIN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Pin 1." ] # [ inline ] pub fn pin1 ( & self ) -> PIN1R { PIN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Pin 2." ] # [ inline ] pub fn pin2 ( & self ) -> PIN2R { PIN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Pin 3." ] # [ inline ] pub fn pin3 ( & self ) -> PIN3R { PIN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Pin 4." ] # [ inline ] pub fn pin4 ( & self ) -> PIN4R { PIN4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Pin 5." ] # [ inline ] pub fn pin5 ( & self ) -> PIN5R { PIN5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Pin 6." ] # [ inline ] pub fn pin6 ( & self ) -> PIN6R { PIN6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Pin 7." ] # [ inline ] pub fn pin7 ( & self ) -> PIN7R { PIN7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Pin 8." ] # [ inline ] pub fn pin8 ( & self ) -> PIN8R { PIN8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Pin 9." ] # [ inline ] pub fn pin9 ( & self ) -> PIN9R { PIN9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Pin 10." ] # [ inline ] pub fn pin10 ( & self ) -> PIN10R { PIN10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Pin 11." ] # [ inline ] pub fn pin11 ( & self ) -> PIN11R { PIN11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Pin 12." ] # [ inline ] pub fn pin12 ( & self ) -> PIN12R { PIN12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Pin 13." ] # [ inline ] pub fn pin13 ( & self ) -> PIN13R { PIN13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Pin 14." ] # [ inline ] pub fn pin14 ( & self ) -> PIN14R { PIN14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Pin 15." ] # [ inline ] pub fn pin15 ( & self ) -> PIN15R { PIN15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Pin 16." ] # [ inline ] pub fn pin16 ( & self ) -> PIN16R { PIN16R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Pin 17." ] # [ inline ] pub fn pin17 ( & self ) -> PIN17R { PIN17R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Pin 18." ] # [ inline ] pub fn pin18 ( & self ) -> PIN18R { PIN18R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Pin 19." ] # [ inline ] pub fn pin19 ( & self ) -> PIN19R { PIN19R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Pin 20." ] # [ inline ] pub fn pin20 ( & self ) -> PIN20R { PIN20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Pin 21." ] # [ inline ] pub fn pin21 ( & self ) -> PIN21R { PIN21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Pin 22." ] # [ inline ] pub fn pin22 ( & self ) -> PIN22R { PIN22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Pin 23." ] # [ inline ] pub fn pin23 ( & self ) -> PIN23R { PIN23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Pin 24." ] # [ inline ] pub fn pin24 ( & self ) -> PIN24R { PIN24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Pin 25." ] # [ inline ] pub fn pin25 ( & self ) -> PIN25R { PIN25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Pin 26." ] # [ inline ] pub fn pin26 ( & self ) -> PIN26R { PIN26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Pin 27." ] # [ inline ] pub fn pin27 ( & self ) -> PIN27R { PIN27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Pin 28." ] # [ inline ] pub fn pin28 ( & self ) -> PIN28R { PIN28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Pin 29." ] # [ inline ] pub fn pin29 ( & self ) -> PIN29R { PIN29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Pin 30." ] # [ inline ] pub fn pin30 ( & self ) -> PIN30R { PIN30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Pin 31." ] # [ inline ] pub fn pin31 ( & self ) -> PIN31R { PIN31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Pin 0." ] # [ inline ] pub fn pin0 ( & mut self ) -> _PIN0W { _PIN0W { w : self } } # [ doc = "Bit 1 - Pin 1." ] # [ inline ] pub fn pin1 ( & mut self ) -> _PIN1W { _PIN1W { w : self } } # [ doc = "Bit 2 - Pin 2." ] # [ inline ] pub fn pin2 ( & mut self ) -> _PIN2W { _PIN2W { w : self } } # [ doc = "Bit 3 - Pin 3." ] # [ inline ] pub fn pin3 ( & mut self ) -> _PIN3W { _PIN3W { w : self } } # [ doc = "Bit 4 - Pin 4." ] # [ inline ] pub fn pin4 ( & mut self ) -> _PIN4W { _PIN4W { w : self } } # [ doc = "Bit 5 - Pin 5." ] # [ inline ] pub fn pin5 ( & mut self ) -> _PIN5W { _PIN5W { w : self } } # [ doc = "Bit 6 - Pin 6." ] # [ inline ] pub fn pin6 ( & mut self ) -> _PIN6W { _PIN6W { w : self } } # [ doc = "Bit 7 - Pin 7." ] # [ inline ] pub fn pin7 ( & mut self ) -> _PIN7W { _PIN7W { w : self } } # [ doc = "Bit 8 - Pin 8." ] # [ inline ] pub fn pin8 ( & mut self ) -> _PIN8W { _PIN8W { w : self } } # [ doc = "Bit 9 - Pin 9." ] # [ inline ] pub fn pin9 ( & mut self ) -> _PIN9W { _PIN9W { w : self } } # [ doc = "Bit 10 - Pin 10." ] # [ inline ] pub fn pin10 ( & mut self ) -> _PIN10W { _PIN10W { w : self } } # [ doc = "Bit 11 - Pin 11." ] # [ inline ] pub fn pin11 ( & mut self ) -> _PIN11W { _PIN11W { w : self } } # [ doc = "Bit 12 - Pin 12." ] # [ inline ] pub fn pin12 ( & mut self ) -> _PIN12W { _PIN12W { w : self } } # [ doc = "Bit 13 - Pin 13." ] # [ inline ] pub fn pin13 ( & mut self ) -> _PIN13W { _PIN13W { w : self } } # [ doc = "Bit 14 - Pin 14." ] # [ inline ] pub fn pin14 ( & mut self ) -> _PIN14W { _PIN14W { w : self } } # [ doc = "Bit 15 - Pin 15." ] # [ inline ] pub fn pin15 ( & mut self ) -> _PIN15W { _PIN15W { w : self } } # [ doc = "Bit 16 - Pin 16." ] # [ inline ] pub fn pin16 ( & mut self ) -> _PIN16W { _PIN16W { w : self } } # [ doc = "Bit 17 - Pin 17." ] # [ inline ] pub fn pin17 ( & mut self ) -> _PIN17W { _PIN17W { w : self } } # [ doc = "Bit 18 - Pin 18." ] # [ inline ] pub fn pin18 ( & mut self ) -> _PIN18W { _PIN18W { w : self } } # [ doc = "Bit 19 - Pin 19." ] # [ inline ] pub fn pin19 ( & mut self ) -> _PIN19W { _PIN19W { w : self } } # [ doc = "Bit 20 - Pin 20." ] # [ inline ] pub fn pin20 ( & mut self ) -> _PIN20W { _PIN20W { w : self } } # [ doc = "Bit 21 - Pin 21." ] # [ inline ] pub fn pin21 ( & mut self ) -> _PIN21W { _PIN21W { w : self } } # [ doc = "Bit 22 - Pin 22." ] # [ inline ] pub fn pin22 ( & mut self ) -> _PIN22W { _PIN22W { w : self } } # [ doc = "Bit 23 - Pin 23." ] # [ inline ] pub fn pin23 ( & mut self ) -> _PIN23W { _PIN23W { w : self } } # [ doc = "Bit 24 - Pin 24." ] # [ inline ] pub fn pin24 ( & mut self ) -> _PIN24W { _PIN24W { w : self } } # [ doc = "Bit 25 - Pin 25." ] # [ inline ] pub fn pin25 ( & mut self ) -> _PIN25W { _PIN25W { w : self } } # [ doc = "Bit 26 - Pin 26." ] # [ inline ] pub fn pin26 ( & mut self ) -> _PIN26W { _PIN26W { w : self } } # [ doc = "Bit 27 - Pin 27." ] # [ inline ] pub fn pin27 ( & mut self ) -> _PIN27W { _PIN27W { w : self } } # [ doc = "Bit 28 - Pin 28." ] # [ inline ] pub fn pin28 ( & mut self ) -> _PIN28W { _PIN28W { w : self } } # [ doc = "Bit 29 - Pin 29." ] # [ inline ] pub fn pin29 ( & mut self ) -> _PIN29W { _PIN29W { w : self } } # [ doc = "Bit 30 - Pin 30." ] # [ inline ] pub fn pin30 ( & mut self ) -> _PIN30W { _PIN30W { w : self } } # [ doc = "Bit 31 - Pin 31." ] # [ inline ] pub fn pin31 ( & mut self ) -> _PIN31W { _PIN31W { w : self } } } } # [ doc = "Clear individual bits in GPIO port." ] pub struct OUTCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Clear individual bits in GPIO port." ] pub mod outclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: OUTCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PIN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN0R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN0R :: LOW => false , PIN0R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN0R { match value { false => PIN0R :: LOW , true => PIN0R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN0R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN0R :: HIGH } } # [ doc = "Possible values of the field `PIN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN1R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN1R :: LOW => false , PIN1R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN1R { match value { false => PIN1R :: LOW , true => PIN1R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN1R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN1R :: HIGH } } # [ doc = "Possible values of the field `PIN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN2R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN2R :: LOW => false , PIN2R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN2R { match value { false => PIN2R :: LOW , true => PIN2R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN2R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN2R :: HIGH } } # [ doc = "Possible values of the field `PIN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN3R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN3R :: LOW => false , PIN3R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN3R { match value { false => PIN3R :: LOW , true => PIN3R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN3R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN3R :: HIGH } } # [ doc = "Possible values of the field `PIN4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN4R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN4R :: LOW => false , PIN4R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN4R { match value { false => PIN4R :: LOW , true => PIN4R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN4R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN4R :: HIGH } } # [ doc = "Possible values of the field `PIN5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN5R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN5R :: LOW => false , PIN5R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN5R { match value { false => PIN5R :: LOW , true => PIN5R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN5R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN5R :: HIGH } } # [ doc = "Possible values of the field `PIN6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN6R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN6R :: LOW => false , PIN6R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN6R { match value { false => PIN6R :: LOW , true => PIN6R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN6R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN6R :: HIGH } } # [ doc = "Possible values of the field `PIN7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN7R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN7R :: LOW => false , PIN7R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN7R { match value { false => PIN7R :: LOW , true => PIN7R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN7R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN7R :: HIGH } } # [ doc = "Possible values of the field `PIN8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN8R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN8R :: LOW => false , PIN8R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN8R { match value { false => PIN8R :: LOW , true => PIN8R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN8R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN8R :: HIGH } } # [ doc = "Possible values of the field `PIN9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN9R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN9R :: LOW => false , PIN9R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN9R { match value { false => PIN9R :: LOW , true => PIN9R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN9R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN9R :: HIGH } } # [ doc = "Possible values of the field `PIN10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN10R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN10R :: LOW => false , PIN10R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN10R { match value { false => PIN10R :: LOW , true => PIN10R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN10R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN10R :: HIGH } } # [ doc = "Possible values of the field `PIN11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN11R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN11R :: LOW => false , PIN11R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN11R { match value { false => PIN11R :: LOW , true => PIN11R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN11R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN11R :: HIGH } } # [ doc = "Possible values of the field `PIN12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN12R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN12R :: LOW => false , PIN12R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN12R { match value { false => PIN12R :: LOW , true => PIN12R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN12R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN12R :: HIGH } } # [ doc = "Possible values of the field `PIN13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN13R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN13R :: LOW => false , PIN13R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN13R { match value { false => PIN13R :: LOW , true => PIN13R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN13R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN13R :: HIGH } } # [ doc = "Possible values of the field `PIN14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN14R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN14R :: LOW => false , PIN14R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN14R { match value { false => PIN14R :: LOW , true => PIN14R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN14R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN14R :: HIGH } } # [ doc = "Possible values of the field `PIN15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN15R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN15R :: LOW => false , PIN15R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN15R { match value { false => PIN15R :: LOW , true => PIN15R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN15R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN15R :: HIGH } } # [ doc = "Possible values of the field `PIN16`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN16R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN16R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN16R :: LOW => false , PIN16R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN16R { match value { false => PIN16R :: LOW , true => PIN16R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN16R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN16R :: HIGH } } # [ doc = "Possible values of the field `PIN17`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN17R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN17R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN17R :: LOW => false , PIN17R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN17R { match value { false => PIN17R :: LOW , true => PIN17R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN17R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN17R :: HIGH } } # [ doc = "Possible values of the field `PIN18`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN18R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN18R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN18R :: LOW => false , PIN18R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN18R { match value { false => PIN18R :: LOW , true => PIN18R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN18R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN18R :: HIGH } } # [ doc = "Possible values of the field `PIN19`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN19R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN19R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN19R :: LOW => false , PIN19R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN19R { match value { false => PIN19R :: LOW , true => PIN19R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN19R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN19R :: HIGH } } # [ doc = "Possible values of the field `PIN20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN20R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN20R :: LOW => false , PIN20R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN20R { match value { false => PIN20R :: LOW , true => PIN20R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN20R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN20R :: HIGH } } # [ doc = "Possible values of the field `PIN21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN21R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN21R :: LOW => false , PIN21R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN21R { match value { false => PIN21R :: LOW , true => PIN21R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN21R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN21R :: HIGH } } # [ doc = "Possible values of the field `PIN22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN22R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN22R :: LOW => false , PIN22R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN22R { match value { false => PIN22R :: LOW , true => PIN22R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN22R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN22R :: HIGH } } # [ doc = "Possible values of the field `PIN23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN23R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN23R :: LOW => false , PIN23R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN23R { match value { false => PIN23R :: LOW , true => PIN23R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN23R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN23R :: HIGH } } # [ doc = "Possible values of the field `PIN24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN24R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN24R :: LOW => false , PIN24R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN24R { match value { false => PIN24R :: LOW , true => PIN24R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN24R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN24R :: HIGH } } # [ doc = "Possible values of the field `PIN25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN25R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN25R :: LOW => false , PIN25R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN25R { match value { false => PIN25R :: LOW , true => PIN25R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN25R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN25R :: HIGH } } # [ doc = "Possible values of the field `PIN26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN26R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN26R :: LOW => false , PIN26R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN26R { match value { false => PIN26R :: LOW , true => PIN26R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN26R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN26R :: HIGH } } # [ doc = "Possible values of the field `PIN27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN27R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN27R :: LOW => false , PIN27R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN27R { match value { false => PIN27R :: LOW , true => PIN27R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN27R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN27R :: HIGH } } # [ doc = "Possible values of the field `PIN28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN28R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN28R :: LOW => false , PIN28R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN28R { match value { false => PIN28R :: LOW , true => PIN28R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN28R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN28R :: HIGH } } # [ doc = "Possible values of the field `PIN29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN29R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN29R :: LOW => false , PIN29R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN29R { match value { false => PIN29R :: LOW , true => PIN29R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN29R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN29R :: HIGH } } # [ doc = "Possible values of the field `PIN30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN30R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN30R :: LOW => false , PIN30R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN30R { match value { false => PIN30R :: LOW , true => PIN30R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN30R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN30R :: HIGH } } # [ doc = "Possible values of the field `PIN31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN31R { # [ doc = "Pin driver is low." ] LOW , # [ doc = "Pin driver is high." ] HIGH } impl PIN31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN31R :: LOW => false , PIN31R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN31R { match value { false => PIN31R :: LOW , true => PIN31R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN31R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN31R :: HIGH } } # [ doc = "Values that can be written to the field `PIN0`" ] pub enum PIN0W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN0W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN0W < 'a > { w : & 'a mut W , } impl < 'a > _PIN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN0W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN1`" ] pub enum PIN1W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN1W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN1W < 'a > { w : & 'a mut W , } impl < 'a > _PIN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN1W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN2`" ] pub enum PIN2W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN2W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN2W < 'a > { w : & 'a mut W , } impl < 'a > _PIN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN2W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN3`" ] pub enum PIN3W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN3W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN3W < 'a > { w : & 'a mut W , } impl < 'a > _PIN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN3W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN4`" ] pub enum PIN4W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN4W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN4W < 'a > { w : & 'a mut W , } impl < 'a > _PIN4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN4W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN5`" ] pub enum PIN5W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN5W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN5W < 'a > { w : & 'a mut W , } impl < 'a > _PIN5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN5W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN6`" ] pub enum PIN6W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN6W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN6W < 'a > { w : & 'a mut W , } impl < 'a > _PIN6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN6W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN7`" ] pub enum PIN7W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN7W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN7W < 'a > { w : & 'a mut W , } impl < 'a > _PIN7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN7W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN8`" ] pub enum PIN8W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN8W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN8W < 'a > { w : & 'a mut W , } impl < 'a > _PIN8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN8W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN9`" ] pub enum PIN9W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN9W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN9W < 'a > { w : & 'a mut W , } impl < 'a > _PIN9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN9W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN10`" ] pub enum PIN10W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN10W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN10W < 'a > { w : & 'a mut W , } impl < 'a > _PIN10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN10W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN11`" ] pub enum PIN11W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN11W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN11W < 'a > { w : & 'a mut W , } impl < 'a > _PIN11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN11W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN12`" ] pub enum PIN12W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN12W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN12W < 'a > { w : & 'a mut W , } impl < 'a > _PIN12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN12W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN13`" ] pub enum PIN13W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN13W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN13W < 'a > { w : & 'a mut W , } impl < 'a > _PIN13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN13W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN14`" ] pub enum PIN14W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN14W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN14W < 'a > { w : & 'a mut W , } impl < 'a > _PIN14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN14W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN15`" ] pub enum PIN15W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN15W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN15W < 'a > { w : & 'a mut W , } impl < 'a > _PIN15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN15W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN16`" ] pub enum PIN16W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN16W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN16W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN16W < 'a > { w : & 'a mut W , } impl < 'a > _PIN16W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN16W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN16W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN17`" ] pub enum PIN17W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN17W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN17W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN17W < 'a > { w : & 'a mut W , } impl < 'a > _PIN17W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN17W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN17W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN18`" ] pub enum PIN18W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN18W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN18W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN18W < 'a > { w : & 'a mut W , } impl < 'a > _PIN18W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN18W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN18W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN19`" ] pub enum PIN19W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN19W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN19W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN19W < 'a > { w : & 'a mut W , } impl < 'a > _PIN19W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN19W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN19W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN20`" ] pub enum PIN20W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN20W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN20W < 'a > { w : & 'a mut W , } impl < 'a > _PIN20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN20W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN21`" ] pub enum PIN21W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN21W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN21W < 'a > { w : & 'a mut W , } impl < 'a > _PIN21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN21W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN22`" ] pub enum PIN22W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN22W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN22W < 'a > { w : & 'a mut W , } impl < 'a > _PIN22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN22W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN23`" ] pub enum PIN23W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN23W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN23W < 'a > { w : & 'a mut W , } impl < 'a > _PIN23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN23W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN24`" ] pub enum PIN24W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN24W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN24W < 'a > { w : & 'a mut W , } impl < 'a > _PIN24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN24W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN25`" ] pub enum PIN25W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN25W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN25W < 'a > { w : & 'a mut W , } impl < 'a > _PIN25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN25W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN26`" ] pub enum PIN26W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN26W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN26W < 'a > { w : & 'a mut W , } impl < 'a > _PIN26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN26W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN27`" ] pub enum PIN27W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN27W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN27W < 'a > { w : & 'a mut W , } impl < 'a > _PIN27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN27W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN28`" ] pub enum PIN28W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN28W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN28W < 'a > { w : & 'a mut W , } impl < 'a > _PIN28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN28W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN29`" ] pub enum PIN29W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN29W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN29W < 'a > { w : & 'a mut W , } impl < 'a > _PIN29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN29W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN30`" ] pub enum PIN30W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN30W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN30W < 'a > { w : & 'a mut W , } impl < 'a > _PIN30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN30W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN31`" ] pub enum PIN31W { # [ doc = "Set pin driver low." ] CLEAR } impl PIN31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN31W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN31W < 'a > { w : & 'a mut W , } impl < 'a > _PIN31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin driver low." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN31W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Pin 0." ] # [ inline ] pub fn pin0 ( & self ) -> PIN0R { PIN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Pin 1." ] # [ inline ] pub fn pin1 ( & self ) -> PIN1R { PIN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Pin 2." ] # [ inline ] pub fn pin2 ( & self ) -> PIN2R { PIN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Pin 3." ] # [ inline ] pub fn pin3 ( & self ) -> PIN3R { PIN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Pin 4." ] # [ inline ] pub fn pin4 ( & self ) -> PIN4R { PIN4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Pin 5." ] # [ inline ] pub fn pin5 ( & self ) -> PIN5R { PIN5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Pin 6." ] # [ inline ] pub fn pin6 ( & self ) -> PIN6R { PIN6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Pin 7." ] # [ inline ] pub fn pin7 ( & self ) -> PIN7R { PIN7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Pin 8." ] # [ inline ] pub fn pin8 ( & self ) -> PIN8R { PIN8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Pin 9." ] # [ inline ] pub fn pin9 ( & self ) -> PIN9R { PIN9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Pin 10." ] # [ inline ] pub fn pin10 ( & self ) -> PIN10R { PIN10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Pin 11." ] # [ inline ] pub fn pin11 ( & self ) -> PIN11R { PIN11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Pin 12." ] # [ inline ] pub fn pin12 ( & self ) -> PIN12R { PIN12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Pin 13." ] # [ inline ] pub fn pin13 ( & self ) -> PIN13R { PIN13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Pin 14." ] # [ inline ] pub fn pin14 ( & self ) -> PIN14R { PIN14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Pin 15." ] # [ inline ] pub fn pin15 ( & self ) -> PIN15R { PIN15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Pin 16." ] # [ inline ] pub fn pin16 ( & self ) -> PIN16R { PIN16R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Pin 17." ] # [ inline ] pub fn pin17 ( & self ) -> PIN17R { PIN17R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Pin 18." ] # [ inline ] pub fn pin18 ( & self ) -> PIN18R { PIN18R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Pin 19." ] # [ inline ] pub fn pin19 ( & self ) -> PIN19R { PIN19R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Pin 20." ] # [ inline ] pub fn pin20 ( & self ) -> PIN20R { PIN20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Pin 21." ] # [ inline ] pub fn pin21 ( & self ) -> PIN21R { PIN21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Pin 22." ] # [ inline ] pub fn pin22 ( & self ) -> PIN22R { PIN22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Pin 23." ] # [ inline ] pub fn pin23 ( & self ) -> PIN23R { PIN23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Pin 24." ] # [ inline ] pub fn pin24 ( & self ) -> PIN24R { PIN24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Pin 25." ] # [ inline ] pub fn pin25 ( & self ) -> PIN25R { PIN25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Pin 26." ] # [ inline ] pub fn pin26 ( & self ) -> PIN26R { PIN26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Pin 27." ] # [ inline ] pub fn pin27 ( & self ) -> PIN27R { PIN27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Pin 28." ] # [ inline ] pub fn pin28 ( & self ) -> PIN28R { PIN28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Pin 29." ] # [ inline ] pub fn pin29 ( & self ) -> PIN29R { PIN29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Pin 30." ] # [ inline ] pub fn pin30 ( & self ) -> PIN30R { PIN30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Pin 31." ] # [ inline ] pub fn pin31 ( & self ) -> PIN31R { PIN31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Pin 0." ] # [ inline ] pub fn pin0 ( & mut self ) -> _PIN0W { _PIN0W { w : self } } # [ doc = "Bit 1 - Pin 1." ] # [ inline ] pub fn pin1 ( & mut self ) -> _PIN1W { _PIN1W { w : self } } # [ doc = "Bit 2 - Pin 2." ] # [ inline ] pub fn pin2 ( & mut self ) -> _PIN2W { _PIN2W { w : self } } # [ doc = "Bit 3 - Pin 3." ] # [ inline ] pub fn pin3 ( & mut self ) -> _PIN3W { _PIN3W { w : self } } # [ doc = "Bit 4 - Pin 4." ] # [ inline ] pub fn pin4 ( & mut self ) -> _PIN4W { _PIN4W { w : self } } # [ doc = "Bit 5 - Pin 5." ] # [ inline ] pub fn pin5 ( & mut self ) -> _PIN5W { _PIN5W { w : self } } # [ doc = "Bit 6 - Pin 6." ] # [ inline ] pub fn pin6 ( & mut self ) -> _PIN6W { _PIN6W { w : self } } # [ doc = "Bit 7 - Pin 7." ] # [ inline ] pub fn pin7 ( & mut self ) -> _PIN7W { _PIN7W { w : self } } # [ doc = "Bit 8 - Pin 8." ] # [ inline ] pub fn pin8 ( & mut self ) -> _PIN8W { _PIN8W { w : self } } # [ doc = "Bit 9 - Pin 9." ] # [ inline ] pub fn pin9 ( & mut self ) -> _PIN9W { _PIN9W { w : self } } # [ doc = "Bit 10 - Pin 10." ] # [ inline ] pub fn pin10 ( & mut self ) -> _PIN10W { _PIN10W { w : self } } # [ doc = "Bit 11 - Pin 11." ] # [ inline ] pub fn pin11 ( & mut self ) -> _PIN11W { _PIN11W { w : self } } # [ doc = "Bit 12 - Pin 12." ] # [ inline ] pub fn pin12 ( & mut self ) -> _PIN12W { _PIN12W { w : self } } # [ doc = "Bit 13 - Pin 13." ] # [ inline ] pub fn pin13 ( & mut self ) -> _PIN13W { _PIN13W { w : self } } # [ doc = "Bit 14 - Pin 14." ] # [ inline ] pub fn pin14 ( & mut self ) -> _PIN14W { _PIN14W { w : self } } # [ doc = "Bit 15 - Pin 15." ] # [ inline ] pub fn pin15 ( & mut self ) -> _PIN15W { _PIN15W { w : self } } # [ doc = "Bit 16 - Pin 16." ] # [ inline ] pub fn pin16 ( & mut self ) -> _PIN16W { _PIN16W { w : self } } # [ doc = "Bit 17 - Pin 17." ] # [ inline ] pub fn pin17 ( & mut self ) -> _PIN17W { _PIN17W { w : self } } # [ doc = "Bit 18 - Pin 18." ] # [ inline ] pub fn pin18 ( & mut self ) -> _PIN18W { _PIN18W { w : self } } # [ doc = "Bit 19 - Pin 19." ] # [ inline ] pub fn pin19 ( & mut self ) -> _PIN19W { _PIN19W { w : self } } # [ doc = "Bit 20 - Pin 20." ] # [ inline ] pub fn pin20 ( & mut self ) -> _PIN20W { _PIN20W { w : self } } # [ doc = "Bit 21 - Pin 21." ] # [ inline ] pub fn pin21 ( & mut self ) -> _PIN21W { _PIN21W { w : self } } # [ doc = "Bit 22 - Pin 22." ] # [ inline ] pub fn pin22 ( & mut self ) -> _PIN22W { _PIN22W { w : self } } # [ doc = "Bit 23 - Pin 23." ] # [ inline ] pub fn pin23 ( & mut self ) -> _PIN23W { _PIN23W { w : self } } # [ doc = "Bit 24 - Pin 24." ] # [ inline ] pub fn pin24 ( & mut self ) -> _PIN24W { _PIN24W { w : self } } # [ doc = "Bit 25 - Pin 25." ] # [ inline ] pub fn pin25 ( & mut self ) -> _PIN25W { _PIN25W { w : self } } # [ doc = "Bit 26 - Pin 26." ] # [ inline ] pub fn pin26 ( & mut self ) -> _PIN26W { _PIN26W { w : self } } # [ doc = "Bit 27 - Pin 27." ] # [ inline ] pub fn pin27 ( & mut self ) -> _PIN27W { _PIN27W { w : self } } # [ doc = "Bit 28 - Pin 28." ] # [ inline ] pub fn pin28 ( & mut self ) -> _PIN28W { _PIN28W { w : self } } # [ doc = "Bit 29 - Pin 29." ] # [ inline ] pub fn pin29 ( & mut self ) -> _PIN29W { _PIN29W { w : self } } # [ doc = "Bit 30 - Pin 30." ] # [ inline ] pub fn pin30 ( & mut self ) -> _PIN30W { _PIN30W { w : self } } # [ doc = "Bit 31 - Pin 31." ] # [ inline ] pub fn pin31 ( & mut self ) -> _PIN31W { _PIN31W { w : self } } } } # [ doc = "Read GPIO port." ] pub struct IN { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Read GPIO port." ] pub mod in_ { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } impl super :: IN { # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } } # [ doc = "Possible values of the field `PIN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN0R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN0R :: LOW => false , PIN0R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN0R { match value { false => PIN0R :: LOW , true => PIN0R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN0R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN0R :: HIGH } } # [ doc = "Possible values of the field `PIN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN1R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN1R :: LOW => false , PIN1R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN1R { match value { false => PIN1R :: LOW , true => PIN1R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN1R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN1R :: HIGH } } # [ doc = "Possible values of the field `PIN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN2R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN2R :: LOW => false , PIN2R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN2R { match value { false => PIN2R :: LOW , true => PIN2R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN2R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN2R :: HIGH } } # [ doc = "Possible values of the field `PIN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN3R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN3R :: LOW => false , PIN3R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN3R { match value { false => PIN3R :: LOW , true => PIN3R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN3R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN3R :: HIGH } } # [ doc = "Possible values of the field `PIN4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN4R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN4R :: LOW => false , PIN4R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN4R { match value { false => PIN4R :: LOW , true => PIN4R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN4R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN4R :: HIGH } } # [ doc = "Possible values of the field `PIN5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN5R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN5R :: LOW => false , PIN5R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN5R { match value { false => PIN5R :: LOW , true => PIN5R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN5R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN5R :: HIGH } } # [ doc = "Possible values of the field `PIN6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN6R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN6R :: LOW => false , PIN6R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN6R { match value { false => PIN6R :: LOW , true => PIN6R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN6R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN6R :: HIGH } } # [ doc = "Possible values of the field `PIN7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN7R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN7R :: LOW => false , PIN7R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN7R { match value { false => PIN7R :: LOW , true => PIN7R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN7R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN7R :: HIGH } } # [ doc = "Possible values of the field `PIN8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN8R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN8R :: LOW => false , PIN8R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN8R { match value { false => PIN8R :: LOW , true => PIN8R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN8R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN8R :: HIGH } } # [ doc = "Possible values of the field `PIN9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN9R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN9R :: LOW => false , PIN9R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN9R { match value { false => PIN9R :: LOW , true => PIN9R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN9R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN9R :: HIGH } } # [ doc = "Possible values of the field `PIN10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN10R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN10R :: LOW => false , PIN10R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN10R { match value { false => PIN10R :: LOW , true => PIN10R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN10R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN10R :: HIGH } } # [ doc = "Possible values of the field `PIN11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN11R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN11R :: LOW => false , PIN11R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN11R { match value { false => PIN11R :: LOW , true => PIN11R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN11R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN11R :: HIGH } } # [ doc = "Possible values of the field `PIN12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN12R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN12R :: LOW => false , PIN12R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN12R { match value { false => PIN12R :: LOW , true => PIN12R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN12R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN12R :: HIGH } } # [ doc = "Possible values of the field `PIN13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN13R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN13R :: LOW => false , PIN13R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN13R { match value { false => PIN13R :: LOW , true => PIN13R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN13R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN13R :: HIGH } } # [ doc = "Possible values of the field `PIN14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN14R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN14R :: LOW => false , PIN14R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN14R { match value { false => PIN14R :: LOW , true => PIN14R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN14R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN14R :: HIGH } } # [ doc = "Possible values of the field `PIN15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN15R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN15R :: LOW => false , PIN15R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN15R { match value { false => PIN15R :: LOW , true => PIN15R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN15R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN15R :: HIGH } } # [ doc = "Possible values of the field `PIN16`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN16R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN16R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN16R :: LOW => false , PIN16R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN16R { match value { false => PIN16R :: LOW , true => PIN16R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN16R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN16R :: HIGH } } # [ doc = "Possible values of the field `PIN17`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN17R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN17R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN17R :: LOW => false , PIN17R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN17R { match value { false => PIN17R :: LOW , true => PIN17R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN17R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN17R :: HIGH } } # [ doc = "Possible values of the field `PIN18`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN18R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN18R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN18R :: LOW => false , PIN18R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN18R { match value { false => PIN18R :: LOW , true => PIN18R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN18R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN18R :: HIGH } } # [ doc = "Possible values of the field `PIN19`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN19R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN19R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN19R :: LOW => false , PIN19R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN19R { match value { false => PIN19R :: LOW , true => PIN19R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN19R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN19R :: HIGH } } # [ doc = "Possible values of the field `PIN20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN20R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN20R :: LOW => false , PIN20R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN20R { match value { false => PIN20R :: LOW , true => PIN20R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN20R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN20R :: HIGH } } # [ doc = "Possible values of the field `PIN21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN21R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN21R :: LOW => false , PIN21R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN21R { match value { false => PIN21R :: LOW , true => PIN21R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN21R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN21R :: HIGH } } # [ doc = "Possible values of the field `PIN22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN22R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN22R :: LOW => false , PIN22R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN22R { match value { false => PIN22R :: LOW , true => PIN22R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN22R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN22R :: HIGH } } # [ doc = "Possible values of the field `PIN23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN23R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN23R :: LOW => false , PIN23R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN23R { match value { false => PIN23R :: LOW , true => PIN23R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN23R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN23R :: HIGH } } # [ doc = "Possible values of the field `PIN24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN24R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN24R :: LOW => false , PIN24R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN24R { match value { false => PIN24R :: LOW , true => PIN24R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN24R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN24R :: HIGH } } # [ doc = "Possible values of the field `PIN25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN25R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN25R :: LOW => false , PIN25R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN25R { match value { false => PIN25R :: LOW , true => PIN25R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN25R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN25R :: HIGH } } # [ doc = "Possible values of the field `PIN26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN26R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN26R :: LOW => false , PIN26R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN26R { match value { false => PIN26R :: LOW , true => PIN26R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN26R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN26R :: HIGH } } # [ doc = "Possible values of the field `PIN27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN27R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN27R :: LOW => false , PIN27R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN27R { match value { false => PIN27R :: LOW , true => PIN27R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN27R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN27R :: HIGH } } # [ doc = "Possible values of the field `PIN28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN28R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN28R :: LOW => false , PIN28R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN28R { match value { false => PIN28R :: LOW , true => PIN28R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN28R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN28R :: HIGH } } # [ doc = "Possible values of the field `PIN29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN29R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN29R :: LOW => false , PIN29R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN29R { match value { false => PIN29R :: LOW , true => PIN29R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN29R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN29R :: HIGH } } # [ doc = "Possible values of the field `PIN30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN30R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN30R :: LOW => false , PIN30R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN30R { match value { false => PIN30R :: LOW , true => PIN30R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN30R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN30R :: HIGH } } # [ doc = "Possible values of the field `PIN31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN31R { # [ doc = "Pin input is low." ] LOW , # [ doc = "Pin input is high." ] HIGH } impl PIN31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN31R :: LOW => false , PIN31R :: HIGH => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN31R { match value { false => PIN31R :: LOW , true => PIN31R :: HIGH , } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == PIN31R :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == PIN31R :: HIGH } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Pin 0." ] # [ inline ] pub fn pin0 ( & self ) -> PIN0R { PIN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Pin 1." ] # [ inline ] pub fn pin1 ( & self ) -> PIN1R { PIN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Pin 2." ] # [ inline ] pub fn pin2 ( & self ) -> PIN2R { PIN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Pin 3." ] # [ inline ] pub fn pin3 ( & self ) -> PIN3R { PIN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Pin 4." ] # [ inline ] pub fn pin4 ( & self ) -> PIN4R { PIN4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Pin 5." ] # [ inline ] pub fn pin5 ( & self ) -> PIN5R { PIN5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Pin 6." ] # [ inline ] pub fn pin6 ( & self ) -> PIN6R { PIN6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Pin 7." ] # [ inline ] pub fn pin7 ( & self ) -> PIN7R { PIN7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Pin 8." ] # [ inline ] pub fn pin8 ( & self ) -> PIN8R { PIN8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Pin 9." ] # [ inline ] pub fn pin9 ( & self ) -> PIN9R { PIN9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Pin 10." ] # [ inline ] pub fn pin10 ( & self ) -> PIN10R { PIN10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Pin 11." ] # [ inline ] pub fn pin11 ( & self ) -> PIN11R { PIN11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Pin 12." ] # [ inline ] pub fn pin12 ( & self ) -> PIN12R { PIN12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Pin 13." ] # [ inline ] pub fn pin13 ( & self ) -> PIN13R { PIN13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Pin 14." ] # [ inline ] pub fn pin14 ( & self ) -> PIN14R { PIN14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Pin 15." ] # [ inline ] pub fn pin15 ( & self ) -> PIN15R { PIN15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Pin 16." ] # [ inline ] pub fn pin16 ( & self ) -> PIN16R { PIN16R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Pin 17." ] # [ inline ] pub fn pin17 ( & self ) -> PIN17R { PIN17R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Pin 18." ] # [ inline ] pub fn pin18 ( & self ) -> PIN18R { PIN18R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Pin 19." ] # [ inline ] pub fn pin19 ( & self ) -> PIN19R { PIN19R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Pin 20." ] # [ inline ] pub fn pin20 ( & self ) -> PIN20R { PIN20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Pin 21." ] # [ inline ] pub fn pin21 ( & self ) -> PIN21R { PIN21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Pin 22." ] # [ inline ] pub fn pin22 ( & self ) -> PIN22R { PIN22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Pin 23." ] # [ inline ] pub fn pin23 ( & self ) -> PIN23R { PIN23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Pin 24." ] # [ inline ] pub fn pin24 ( & self ) -> PIN24R { PIN24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Pin 25." ] # [ inline ] pub fn pin25 ( & self ) -> PIN25R { PIN25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Pin 26." ] # [ inline ] pub fn pin26 ( & self ) -> PIN26R { PIN26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Pin 27." ] # [ inline ] pub fn pin27 ( & self ) -> PIN27R { PIN27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Pin 28." ] # [ inline ] pub fn pin28 ( & self ) -> PIN28R { PIN28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Pin 29." ] # [ inline ] pub fn pin29 ( & self ) -> PIN29R { PIN29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Pin 30." ] # [ inline ] pub fn pin30 ( & self ) -> PIN30R { PIN30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Pin 31." ] # [ inline ] pub fn pin31 ( & self ) -> PIN31R { PIN31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } } # [ doc = "Direction of GPIO pins." ] pub struct DIR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Direction of GPIO pins." ] pub mod dir { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DIR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PIN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN0R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN0R :: INPUT => false , PIN0R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN0R { match value { false => PIN0R :: INPUT , true => PIN0R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN0R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN0R :: OUTPUT } } # [ doc = "Possible values of the field `PIN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN1R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN1R :: INPUT => false , PIN1R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN1R { match value { false => PIN1R :: INPUT , true => PIN1R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN1R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN1R :: OUTPUT } } # [ doc = "Possible values of the field `PIN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN2R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN2R :: INPUT => false , PIN2R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN2R { match value { false => PIN2R :: INPUT , true => PIN2R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN2R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN2R :: OUTPUT } } # [ doc = "Possible values of the field `PIN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN3R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN3R :: INPUT => false , PIN3R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN3R { match value { false => PIN3R :: INPUT , true => PIN3R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN3R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN3R :: OUTPUT } } # [ doc = "Possible values of the field `PIN4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN4R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN4R :: INPUT => false , PIN4R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN4R { match value { false => PIN4R :: INPUT , true => PIN4R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN4R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN4R :: OUTPUT } } # [ doc = "Possible values of the field `PIN5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN5R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN5R :: INPUT => false , PIN5R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN5R { match value { false => PIN5R :: INPUT , true => PIN5R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN5R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN5R :: OUTPUT } } # [ doc = "Possible values of the field `PIN6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN6R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN6R :: INPUT => false , PIN6R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN6R { match value { false => PIN6R :: INPUT , true => PIN6R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN6R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN6R :: OUTPUT } } # [ doc = "Possible values of the field `PIN7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN7R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN7R :: INPUT => false , PIN7R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN7R { match value { false => PIN7R :: INPUT , true => PIN7R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN7R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN7R :: OUTPUT } } # [ doc = "Possible values of the field `PIN8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN8R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN8R :: INPUT => false , PIN8R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN8R { match value { false => PIN8R :: INPUT , true => PIN8R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN8R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN8R :: OUTPUT } } # [ doc = "Possible values of the field `PIN9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN9R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN9R :: INPUT => false , PIN9R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN9R { match value { false => PIN9R :: INPUT , true => PIN9R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN9R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN9R :: OUTPUT } } # [ doc = "Possible values of the field `PIN10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN10R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN10R :: INPUT => false , PIN10R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN10R { match value { false => PIN10R :: INPUT , true => PIN10R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN10R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN10R :: OUTPUT } } # [ doc = "Possible values of the field `PIN11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN11R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN11R :: INPUT => false , PIN11R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN11R { match value { false => PIN11R :: INPUT , true => PIN11R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN11R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN11R :: OUTPUT } } # [ doc = "Possible values of the field `PIN12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN12R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN12R :: INPUT => false , PIN12R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN12R { match value { false => PIN12R :: INPUT , true => PIN12R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN12R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN12R :: OUTPUT } } # [ doc = "Possible values of the field `PIN13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN13R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN13R :: INPUT => false , PIN13R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN13R { match value { false => PIN13R :: INPUT , true => PIN13R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN13R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN13R :: OUTPUT } } # [ doc = "Possible values of the field `PIN14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN14R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN14R :: INPUT => false , PIN14R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN14R { match value { false => PIN14R :: INPUT , true => PIN14R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN14R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN14R :: OUTPUT } } # [ doc = "Possible values of the field `PIN15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN15R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN15R :: INPUT => false , PIN15R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN15R { match value { false => PIN15R :: INPUT , true => PIN15R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN15R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN15R :: OUTPUT } } # [ doc = "Possible values of the field `PIN16`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN16R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN16R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN16R :: INPUT => false , PIN16R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN16R { match value { false => PIN16R :: INPUT , true => PIN16R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN16R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN16R :: OUTPUT } } # [ doc = "Possible values of the field `PIN17`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN17R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN17R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN17R :: INPUT => false , PIN17R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN17R { match value { false => PIN17R :: INPUT , true => PIN17R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN17R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN17R :: OUTPUT } } # [ doc = "Possible values of the field `PIN18`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN18R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN18R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN18R :: INPUT => false , PIN18R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN18R { match value { false => PIN18R :: INPUT , true => PIN18R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN18R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN18R :: OUTPUT } } # [ doc = "Possible values of the field `PIN19`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN19R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN19R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN19R :: INPUT => false , PIN19R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN19R { match value { false => PIN19R :: INPUT , true => PIN19R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN19R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN19R :: OUTPUT } } # [ doc = "Possible values of the field `PIN20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN20R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN20R :: INPUT => false , PIN20R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN20R { match value { false => PIN20R :: INPUT , true => PIN20R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN20R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN20R :: OUTPUT } } # [ doc = "Possible values of the field `PIN21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN21R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN21R :: INPUT => false , PIN21R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN21R { match value { false => PIN21R :: INPUT , true => PIN21R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN21R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN21R :: OUTPUT } } # [ doc = "Possible values of the field `PIN22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN22R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN22R :: INPUT => false , PIN22R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN22R { match value { false => PIN22R :: INPUT , true => PIN22R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN22R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN22R :: OUTPUT } } # [ doc = "Possible values of the field `PIN23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN23R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN23R :: INPUT => false , PIN23R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN23R { match value { false => PIN23R :: INPUT , true => PIN23R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN23R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN23R :: OUTPUT } } # [ doc = "Possible values of the field `PIN24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN24R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN24R :: INPUT => false , PIN24R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN24R { match value { false => PIN24R :: INPUT , true => PIN24R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN24R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN24R :: OUTPUT } } # [ doc = "Possible values of the field `PIN25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN25R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN25R :: INPUT => false , PIN25R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN25R { match value { false => PIN25R :: INPUT , true => PIN25R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN25R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN25R :: OUTPUT } } # [ doc = "Possible values of the field `PIN26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN26R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN26R :: INPUT => false , PIN26R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN26R { match value { false => PIN26R :: INPUT , true => PIN26R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN26R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN26R :: OUTPUT } } # [ doc = "Possible values of the field `PIN27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN27R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN27R :: INPUT => false , PIN27R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN27R { match value { false => PIN27R :: INPUT , true => PIN27R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN27R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN27R :: OUTPUT } } # [ doc = "Possible values of the field `PIN28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN28R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN28R :: INPUT => false , PIN28R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN28R { match value { false => PIN28R :: INPUT , true => PIN28R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN28R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN28R :: OUTPUT } } # [ doc = "Possible values of the field `PIN29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN29R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN29R :: INPUT => false , PIN29R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN29R { match value { false => PIN29R :: INPUT , true => PIN29R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN29R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN29R :: OUTPUT } } # [ doc = "Possible values of the field `PIN30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN30R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN30R :: INPUT => false , PIN30R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN30R { match value { false => PIN30R :: INPUT , true => PIN30R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN30R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN30R :: OUTPUT } } # [ doc = "Possible values of the field `PIN31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN31R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN31R :: INPUT => false , PIN31R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN31R { match value { false => PIN31R :: INPUT , true => PIN31R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN31R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN31R :: OUTPUT } } # [ doc = "Values that can be written to the field `PIN0`" ] pub enum PIN0W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN0W :: INPUT => false , PIN0W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN0W < 'a > { w : & 'a mut W , } impl < 'a > _PIN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN0W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN0W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN1`" ] pub enum PIN1W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN1W :: INPUT => false , PIN1W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN1W < 'a > { w : & 'a mut W , } impl < 'a > _PIN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN1W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN1W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN2`" ] pub enum PIN2W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN2W :: INPUT => false , PIN2W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN2W < 'a > { w : & 'a mut W , } impl < 'a > _PIN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN2W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN2W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN3`" ] pub enum PIN3W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN3W :: INPUT => false , PIN3W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN3W < 'a > { w : & 'a mut W , } impl < 'a > _PIN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN3W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN3W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN4`" ] pub enum PIN4W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN4W :: INPUT => false , PIN4W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN4W < 'a > { w : & 'a mut W , } impl < 'a > _PIN4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN4W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN4W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN5`" ] pub enum PIN5W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN5W :: INPUT => false , PIN5W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN5W < 'a > { w : & 'a mut W , } impl < 'a > _PIN5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN5W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN5W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN6`" ] pub enum PIN6W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN6W :: INPUT => false , PIN6W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN6W < 'a > { w : & 'a mut W , } impl < 'a > _PIN6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN6W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN6W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN7`" ] pub enum PIN7W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN7W :: INPUT => false , PIN7W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN7W < 'a > { w : & 'a mut W , } impl < 'a > _PIN7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN7W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN7W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN8`" ] pub enum PIN8W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN8W :: INPUT => false , PIN8W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN8W < 'a > { w : & 'a mut W , } impl < 'a > _PIN8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN8W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN8W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN9`" ] pub enum PIN9W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN9W :: INPUT => false , PIN9W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN9W < 'a > { w : & 'a mut W , } impl < 'a > _PIN9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN9W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN9W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN10`" ] pub enum PIN10W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN10W :: INPUT => false , PIN10W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN10W < 'a > { w : & 'a mut W , } impl < 'a > _PIN10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN10W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN10W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN11`" ] pub enum PIN11W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN11W :: INPUT => false , PIN11W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN11W < 'a > { w : & 'a mut W , } impl < 'a > _PIN11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN11W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN11W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN12`" ] pub enum PIN12W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN12W :: INPUT => false , PIN12W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN12W < 'a > { w : & 'a mut W , } impl < 'a > _PIN12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN12W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN12W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN13`" ] pub enum PIN13W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN13W :: INPUT => false , PIN13W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN13W < 'a > { w : & 'a mut W , } impl < 'a > _PIN13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN13W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN13W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN14`" ] pub enum PIN14W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN14W :: INPUT => false , PIN14W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN14W < 'a > { w : & 'a mut W , } impl < 'a > _PIN14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN14W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN14W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN15`" ] pub enum PIN15W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN15W :: INPUT => false , PIN15W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN15W < 'a > { w : & 'a mut W , } impl < 'a > _PIN15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN15W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN15W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN16`" ] pub enum PIN16W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN16W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN16W :: INPUT => false , PIN16W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN16W < 'a > { w : & 'a mut W , } impl < 'a > _PIN16W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN16W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN16W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN16W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN17`" ] pub enum PIN17W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN17W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN17W :: INPUT => false , PIN17W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN17W < 'a > { w : & 'a mut W , } impl < 'a > _PIN17W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN17W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN17W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN17W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN18`" ] pub enum PIN18W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN18W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN18W :: INPUT => false , PIN18W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN18W < 'a > { w : & 'a mut W , } impl < 'a > _PIN18W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN18W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN18W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN18W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN19`" ] pub enum PIN19W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN19W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN19W :: INPUT => false , PIN19W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN19W < 'a > { w : & 'a mut W , } impl < 'a > _PIN19W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN19W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN19W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN19W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN20`" ] pub enum PIN20W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN20W :: INPUT => false , PIN20W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN20W < 'a > { w : & 'a mut W , } impl < 'a > _PIN20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN20W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN20W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN21`" ] pub enum PIN21W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN21W :: INPUT => false , PIN21W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN21W < 'a > { w : & 'a mut W , } impl < 'a > _PIN21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN21W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN21W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN22`" ] pub enum PIN22W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN22W :: INPUT => false , PIN22W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN22W < 'a > { w : & 'a mut W , } impl < 'a > _PIN22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN22W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN22W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN23`" ] pub enum PIN23W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN23W :: INPUT => false , PIN23W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN23W < 'a > { w : & 'a mut W , } impl < 'a > _PIN23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN23W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN23W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN24`" ] pub enum PIN24W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN24W :: INPUT => false , PIN24W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN24W < 'a > { w : & 'a mut W , } impl < 'a > _PIN24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN24W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN24W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN25`" ] pub enum PIN25W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN25W :: INPUT => false , PIN25W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN25W < 'a > { w : & 'a mut W , } impl < 'a > _PIN25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN25W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN25W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN26`" ] pub enum PIN26W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN26W :: INPUT => false , PIN26W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN26W < 'a > { w : & 'a mut W , } impl < 'a > _PIN26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN26W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN26W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN27`" ] pub enum PIN27W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN27W :: INPUT => false , PIN27W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN27W < 'a > { w : & 'a mut W , } impl < 'a > _PIN27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN27W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN27W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN28`" ] pub enum PIN28W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN28W :: INPUT => false , PIN28W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN28W < 'a > { w : & 'a mut W , } impl < 'a > _PIN28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN28W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN28W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN29`" ] pub enum PIN29W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN29W :: INPUT => false , PIN29W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN29W < 'a > { w : & 'a mut W , } impl < 'a > _PIN29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN29W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN29W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN30`" ] pub enum PIN30W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN30W :: INPUT => false , PIN30W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN30W < 'a > { w : & 'a mut W , } impl < 'a > _PIN30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN30W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN30W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN31`" ] pub enum PIN31W { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN31W :: INPUT => false , PIN31W :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _PIN31W < 'a > { w : & 'a mut W , } impl < 'a > _PIN31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Pin set as input." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( PIN31W :: INPUT ) } # [ doc = "Pin set as output." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( PIN31W :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Pin 0." ] # [ inline ] pub fn pin0 ( & self ) -> PIN0R { PIN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Pin 1." ] # [ inline ] pub fn pin1 ( & self ) -> PIN1R { PIN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Pin 2." ] # [ inline ] pub fn pin2 ( & self ) -> PIN2R { PIN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Pin 3." ] # [ inline ] pub fn pin3 ( & self ) -> PIN3R { PIN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Pin 4." ] # [ inline ] pub fn pin4 ( & self ) -> PIN4R { PIN4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Pin 5." ] # [ inline ] pub fn pin5 ( & self ) -> PIN5R { PIN5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Pin 6." ] # [ inline ] pub fn pin6 ( & self ) -> PIN6R { PIN6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Pin 7." ] # [ inline ] pub fn pin7 ( & self ) -> PIN7R { PIN7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Pin 8." ] # [ inline ] pub fn pin8 ( & self ) -> PIN8R { PIN8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Pin 9." ] # [ inline ] pub fn pin9 ( & self ) -> PIN9R { PIN9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Pin 10." ] # [ inline ] pub fn pin10 ( & self ) -> PIN10R { PIN10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Pin 11." ] # [ inline ] pub fn pin11 ( & self ) -> PIN11R { PIN11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Pin 12." ] # [ inline ] pub fn pin12 ( & self ) -> PIN12R { PIN12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Pin 13." ] # [ inline ] pub fn pin13 ( & self ) -> PIN13R { PIN13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Pin 14." ] # [ inline ] pub fn pin14 ( & self ) -> PIN14R { PIN14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Pin 15." ] # [ inline ] pub fn pin15 ( & self ) -> PIN15R { PIN15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Pin 16." ] # [ inline ] pub fn pin16 ( & self ) -> PIN16R { PIN16R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Pin 17." ] # [ inline ] pub fn pin17 ( & self ) -> PIN17R { PIN17R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Pin 18." ] # [ inline ] pub fn pin18 ( & self ) -> PIN18R { PIN18R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Pin 19." ] # [ inline ] pub fn pin19 ( & self ) -> PIN19R { PIN19R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Pin 20." ] # [ inline ] pub fn pin20 ( & self ) -> PIN20R { PIN20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Pin 21." ] # [ inline ] pub fn pin21 ( & self ) -> PIN21R { PIN21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Pin 22." ] # [ inline ] pub fn pin22 ( & self ) -> PIN22R { PIN22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Pin 23." ] # [ inline ] pub fn pin23 ( & self ) -> PIN23R { PIN23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Pin 24." ] # [ inline ] pub fn pin24 ( & self ) -> PIN24R { PIN24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Pin 25." ] # [ inline ] pub fn pin25 ( & self ) -> PIN25R { PIN25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Pin 26." ] # [ inline ] pub fn pin26 ( & self ) -> PIN26R { PIN26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Pin 27." ] # [ inline ] pub fn pin27 ( & self ) -> PIN27R { PIN27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Pin 28." ] # [ inline ] pub fn pin28 ( & self ) -> PIN28R { PIN28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Pin 29." ] # [ inline ] pub fn pin29 ( & self ) -> PIN29R { PIN29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Pin 30." ] # [ inline ] pub fn pin30 ( & self ) -> PIN30R { PIN30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Pin 31." ] # [ inline ] pub fn pin31 ( & self ) -> PIN31R { PIN31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Pin 0." ] # [ inline ] pub fn pin0 ( & mut self ) -> _PIN0W { _PIN0W { w : self } } # [ doc = "Bit 1 - Pin 1." ] # [ inline ] pub fn pin1 ( & mut self ) -> _PIN1W { _PIN1W { w : self } } # [ doc = "Bit 2 - Pin 2." ] # [ inline ] pub fn pin2 ( & mut self ) -> _PIN2W { _PIN2W { w : self } } # [ doc = "Bit 3 - Pin 3." ] # [ inline ] pub fn pin3 ( & mut self ) -> _PIN3W { _PIN3W { w : self } } # [ doc = "Bit 4 - Pin 4." ] # [ inline ] pub fn pin4 ( & mut self ) -> _PIN4W { _PIN4W { w : self } } # [ doc = "Bit 5 - Pin 5." ] # [ inline ] pub fn pin5 ( & mut self ) -> _PIN5W { _PIN5W { w : self } } # [ doc = "Bit 6 - Pin 6." ] # [ inline ] pub fn pin6 ( & mut self ) -> _PIN6W { _PIN6W { w : self } } # [ doc = "Bit 7 - Pin 7." ] # [ inline ] pub fn pin7 ( & mut self ) -> _PIN7W { _PIN7W { w : self } } # [ doc = "Bit 8 - Pin 8." ] # [ inline ] pub fn pin8 ( & mut self ) -> _PIN8W { _PIN8W { w : self } } # [ doc = "Bit 9 - Pin 9." ] # [ inline ] pub fn pin9 ( & mut self ) -> _PIN9W { _PIN9W { w : self } } # [ doc = "Bit 10 - Pin 10." ] # [ inline ] pub fn pin10 ( & mut self ) -> _PIN10W { _PIN10W { w : self } } # [ doc = "Bit 11 - Pin 11." ] # [ inline ] pub fn pin11 ( & mut self ) -> _PIN11W { _PIN11W { w : self } } # [ doc = "Bit 12 - Pin 12." ] # [ inline ] pub fn pin12 ( & mut self ) -> _PIN12W { _PIN12W { w : self } } # [ doc = "Bit 13 - Pin 13." ] # [ inline ] pub fn pin13 ( & mut self ) -> _PIN13W { _PIN13W { w : self } } # [ doc = "Bit 14 - Pin 14." ] # [ inline ] pub fn pin14 ( & mut self ) -> _PIN14W { _PIN14W { w : self } } # [ doc = "Bit 15 - Pin 15." ] # [ inline ] pub fn pin15 ( & mut self ) -> _PIN15W { _PIN15W { w : self } } # [ doc = "Bit 16 - Pin 16." ] # [ inline ] pub fn pin16 ( & mut self ) -> _PIN16W { _PIN16W { w : self } } # [ doc = "Bit 17 - Pin 17." ] # [ inline ] pub fn pin17 ( & mut self ) -> _PIN17W { _PIN17W { w : self } } # [ doc = "Bit 18 - Pin 18." ] # [ inline ] pub fn pin18 ( & mut self ) -> _PIN18W { _PIN18W { w : self } } # [ doc = "Bit 19 - Pin 19." ] # [ inline ] pub fn pin19 ( & mut self ) -> _PIN19W { _PIN19W { w : self } } # [ doc = "Bit 20 - Pin 20." ] # [ inline ] pub fn pin20 ( & mut self ) -> _PIN20W { _PIN20W { w : self } } # [ doc = "Bit 21 - Pin 21." ] # [ inline ] pub fn pin21 ( & mut self ) -> _PIN21W { _PIN21W { w : self } } # [ doc = "Bit 22 - Pin 22." ] # [ inline ] pub fn pin22 ( & mut self ) -> _PIN22W { _PIN22W { w : self } } # [ doc = "Bit 23 - Pin 23." ] # [ inline ] pub fn pin23 ( & mut self ) -> _PIN23W { _PIN23W { w : self } } # [ doc = "Bit 24 - Pin 24." ] # [ inline ] pub fn pin24 ( & mut self ) -> _PIN24W { _PIN24W { w : self } } # [ doc = "Bit 25 - Pin 25." ] # [ inline ] pub fn pin25 ( & mut self ) -> _PIN25W { _PIN25W { w : self } } # [ doc = "Bit 26 - Pin 26." ] # [ inline ] pub fn pin26 ( & mut self ) -> _PIN26W { _PIN26W { w : self } } # [ doc = "Bit 27 - Pin 27." ] # [ inline ] pub fn pin27 ( & mut self ) -> _PIN27W { _PIN27W { w : self } } # [ doc = "Bit 28 - Pin 28." ] # [ inline ] pub fn pin28 ( & mut self ) -> _PIN28W { _PIN28W { w : self } } # [ doc = "Bit 29 - Pin 29." ] # [ inline ] pub fn pin29 ( & mut self ) -> _PIN29W { _PIN29W { w : self } } # [ doc = "Bit 30 - Pin 30." ] # [ inline ] pub fn pin30 ( & mut self ) -> _PIN30W { _PIN30W { w : self } } # [ doc = "Bit 31 - Pin 31." ] # [ inline ] pub fn pin31 ( & mut self ) -> _PIN31W { _PIN31W { w : self } } } } # [ doc = "DIR set register." ] pub struct DIRSET { register : :: vcell :: VolatileCell < u32 > } # [ doc = "DIR set register." ] pub mod dirset { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DIRSET { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PIN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN0R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN0R :: INPUT => false , PIN0R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN0R { match value { false => PIN0R :: INPUT , true => PIN0R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN0R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN0R :: OUTPUT } } # [ doc = "Possible values of the field `PIN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN1R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN1R :: INPUT => false , PIN1R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN1R { match value { false => PIN1R :: INPUT , true => PIN1R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN1R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN1R :: OUTPUT } } # [ doc = "Possible values of the field `PIN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN2R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN2R :: INPUT => false , PIN2R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN2R { match value { false => PIN2R :: INPUT , true => PIN2R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN2R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN2R :: OUTPUT } } # [ doc = "Possible values of the field `PIN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN3R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN3R :: INPUT => false , PIN3R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN3R { match value { false => PIN3R :: INPUT , true => PIN3R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN3R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN3R :: OUTPUT } } # [ doc = "Possible values of the field `PIN4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN4R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN4R :: INPUT => false , PIN4R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN4R { match value { false => PIN4R :: INPUT , true => PIN4R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN4R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN4R :: OUTPUT } } # [ doc = "Possible values of the field `PIN5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN5R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN5R :: INPUT => false , PIN5R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN5R { match value { false => PIN5R :: INPUT , true => PIN5R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN5R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN5R :: OUTPUT } } # [ doc = "Possible values of the field `PIN6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN6R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN6R :: INPUT => false , PIN6R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN6R { match value { false => PIN6R :: INPUT , true => PIN6R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN6R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN6R :: OUTPUT } } # [ doc = "Possible values of the field `PIN7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN7R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN7R :: INPUT => false , PIN7R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN7R { match value { false => PIN7R :: INPUT , true => PIN7R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN7R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN7R :: OUTPUT } } # [ doc = "Possible values of the field `PIN8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN8R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN8R :: INPUT => false , PIN8R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN8R { match value { false => PIN8R :: INPUT , true => PIN8R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN8R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN8R :: OUTPUT } } # [ doc = "Possible values of the field `PIN9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN9R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN9R :: INPUT => false , PIN9R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN9R { match value { false => PIN9R :: INPUT , true => PIN9R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN9R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN9R :: OUTPUT } } # [ doc = "Possible values of the field `PIN10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN10R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN10R :: INPUT => false , PIN10R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN10R { match value { false => PIN10R :: INPUT , true => PIN10R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN10R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN10R :: OUTPUT } } # [ doc = "Possible values of the field `PIN11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN11R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN11R :: INPUT => false , PIN11R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN11R { match value { false => PIN11R :: INPUT , true => PIN11R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN11R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN11R :: OUTPUT } } # [ doc = "Possible values of the field `PIN12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN12R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN12R :: INPUT => false , PIN12R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN12R { match value { false => PIN12R :: INPUT , true => PIN12R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN12R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN12R :: OUTPUT } } # [ doc = "Possible values of the field `PIN13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN13R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN13R :: INPUT => false , PIN13R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN13R { match value { false => PIN13R :: INPUT , true => PIN13R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN13R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN13R :: OUTPUT } } # [ doc = "Possible values of the field `PIN14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN14R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN14R :: INPUT => false , PIN14R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN14R { match value { false => PIN14R :: INPUT , true => PIN14R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN14R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN14R :: OUTPUT } } # [ doc = "Possible values of the field `PIN15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN15R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN15R :: INPUT => false , PIN15R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN15R { match value { false => PIN15R :: INPUT , true => PIN15R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN15R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN15R :: OUTPUT } } # [ doc = "Possible values of the field `PIN16`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN16R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN16R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN16R :: INPUT => false , PIN16R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN16R { match value { false => PIN16R :: INPUT , true => PIN16R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN16R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN16R :: OUTPUT } } # [ doc = "Possible values of the field `PIN17`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN17R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN17R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN17R :: INPUT => false , PIN17R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN17R { match value { false => PIN17R :: INPUT , true => PIN17R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN17R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN17R :: OUTPUT } } # [ doc = "Possible values of the field `PIN18`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN18R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN18R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN18R :: INPUT => false , PIN18R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN18R { match value { false => PIN18R :: INPUT , true => PIN18R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN18R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN18R :: OUTPUT } } # [ doc = "Possible values of the field `PIN19`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN19R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN19R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN19R :: INPUT => false , PIN19R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN19R { match value { false => PIN19R :: INPUT , true => PIN19R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN19R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN19R :: OUTPUT } } # [ doc = "Possible values of the field `PIN20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN20R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN20R :: INPUT => false , PIN20R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN20R { match value { false => PIN20R :: INPUT , true => PIN20R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN20R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN20R :: OUTPUT } } # [ doc = "Possible values of the field `PIN21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN21R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN21R :: INPUT => false , PIN21R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN21R { match value { false => PIN21R :: INPUT , true => PIN21R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN21R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN21R :: OUTPUT } } # [ doc = "Possible values of the field `PIN22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN22R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN22R :: INPUT => false , PIN22R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN22R { match value { false => PIN22R :: INPUT , true => PIN22R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN22R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN22R :: OUTPUT } } # [ doc = "Possible values of the field `PIN23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN23R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN23R :: INPUT => false , PIN23R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN23R { match value { false => PIN23R :: INPUT , true => PIN23R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN23R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN23R :: OUTPUT } } # [ doc = "Possible values of the field `PIN24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN24R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN24R :: INPUT => false , PIN24R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN24R { match value { false => PIN24R :: INPUT , true => PIN24R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN24R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN24R :: OUTPUT } } # [ doc = "Possible values of the field `PIN25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN25R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN25R :: INPUT => false , PIN25R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN25R { match value { false => PIN25R :: INPUT , true => PIN25R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN25R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN25R :: OUTPUT } } # [ doc = "Possible values of the field `PIN26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN26R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN26R :: INPUT => false , PIN26R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN26R { match value { false => PIN26R :: INPUT , true => PIN26R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN26R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN26R :: OUTPUT } } # [ doc = "Possible values of the field `PIN27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN27R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN27R :: INPUT => false , PIN27R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN27R { match value { false => PIN27R :: INPUT , true => PIN27R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN27R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN27R :: OUTPUT } } # [ doc = "Possible values of the field `PIN28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN28R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN28R :: INPUT => false , PIN28R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN28R { match value { false => PIN28R :: INPUT , true => PIN28R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN28R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN28R :: OUTPUT } } # [ doc = "Possible values of the field `PIN29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN29R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN29R :: INPUT => false , PIN29R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN29R { match value { false => PIN29R :: INPUT , true => PIN29R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN29R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN29R :: OUTPUT } } # [ doc = "Possible values of the field `PIN30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN30R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN30R :: INPUT => false , PIN30R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN30R { match value { false => PIN30R :: INPUT , true => PIN30R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN30R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN30R :: OUTPUT } } # [ doc = "Possible values of the field `PIN31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN31R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN31R :: INPUT => false , PIN31R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN31R { match value { false => PIN31R :: INPUT , true => PIN31R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN31R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN31R :: OUTPUT } } # [ doc = "Values that can be written to the field `PIN0`" ] pub enum PIN0W { # [ doc = "Set pin as output." ] SET } impl PIN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN0W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN0W < 'a > { w : & 'a mut W , } impl < 'a > _PIN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN0W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN1`" ] pub enum PIN1W { # [ doc = "Set pin as output." ] SET } impl PIN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN1W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN1W < 'a > { w : & 'a mut W , } impl < 'a > _PIN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN1W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN2`" ] pub enum PIN2W { # [ doc = "Set pin as output." ] SET } impl PIN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN2W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN2W < 'a > { w : & 'a mut W , } impl < 'a > _PIN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN2W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN3`" ] pub enum PIN3W { # [ doc = "Set pin as output." ] SET } impl PIN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN3W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN3W < 'a > { w : & 'a mut W , } impl < 'a > _PIN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN3W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN4`" ] pub enum PIN4W { # [ doc = "Set pin as output." ] SET } impl PIN4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN4W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN4W < 'a > { w : & 'a mut W , } impl < 'a > _PIN4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN4W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN5`" ] pub enum PIN5W { # [ doc = "Set pin as output." ] SET } impl PIN5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN5W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN5W < 'a > { w : & 'a mut W , } impl < 'a > _PIN5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN5W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN6`" ] pub enum PIN6W { # [ doc = "Set pin as output." ] SET } impl PIN6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN6W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN6W < 'a > { w : & 'a mut W , } impl < 'a > _PIN6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN6W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN7`" ] pub enum PIN7W { # [ doc = "Set pin as output." ] SET } impl PIN7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN7W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN7W < 'a > { w : & 'a mut W , } impl < 'a > _PIN7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN7W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN8`" ] pub enum PIN8W { # [ doc = "Set pin as output." ] SET } impl PIN8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN8W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN8W < 'a > { w : & 'a mut W , } impl < 'a > _PIN8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN8W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN9`" ] pub enum PIN9W { # [ doc = "Set pin as output." ] SET } impl PIN9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN9W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN9W < 'a > { w : & 'a mut W , } impl < 'a > _PIN9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN9W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN10`" ] pub enum PIN10W { # [ doc = "Set pin as output." ] SET } impl PIN10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN10W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN10W < 'a > { w : & 'a mut W , } impl < 'a > _PIN10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN10W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN11`" ] pub enum PIN11W { # [ doc = "Set pin as output." ] SET } impl PIN11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN11W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN11W < 'a > { w : & 'a mut W , } impl < 'a > _PIN11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN11W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN12`" ] pub enum PIN12W { # [ doc = "Set pin as output." ] SET } impl PIN12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN12W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN12W < 'a > { w : & 'a mut W , } impl < 'a > _PIN12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN12W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN13`" ] pub enum PIN13W { # [ doc = "Set pin as output." ] SET } impl PIN13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN13W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN13W < 'a > { w : & 'a mut W , } impl < 'a > _PIN13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN13W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN14`" ] pub enum PIN14W { # [ doc = "Set pin as output." ] SET } impl PIN14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN14W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN14W < 'a > { w : & 'a mut W , } impl < 'a > _PIN14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN14W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN15`" ] pub enum PIN15W { # [ doc = "Set pin as output." ] SET } impl PIN15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN15W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN15W < 'a > { w : & 'a mut W , } impl < 'a > _PIN15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN15W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN16`" ] pub enum PIN16W { # [ doc = "Set pin as output." ] SET } impl PIN16W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN16W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN16W < 'a > { w : & 'a mut W , } impl < 'a > _PIN16W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN16W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN16W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN17`" ] pub enum PIN17W { # [ doc = "Set pin as output." ] SET } impl PIN17W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN17W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN17W < 'a > { w : & 'a mut W , } impl < 'a > _PIN17W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN17W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN17W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN18`" ] pub enum PIN18W { # [ doc = "Set pin as output." ] SET } impl PIN18W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN18W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN18W < 'a > { w : & 'a mut W , } impl < 'a > _PIN18W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN18W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN18W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN19`" ] pub enum PIN19W { # [ doc = "Set pin as output." ] SET } impl PIN19W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN19W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN19W < 'a > { w : & 'a mut W , } impl < 'a > _PIN19W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN19W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN19W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN20`" ] pub enum PIN20W { # [ doc = "Set pin as output." ] SET } impl PIN20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN20W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN20W < 'a > { w : & 'a mut W , } impl < 'a > _PIN20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN20W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN21`" ] pub enum PIN21W { # [ doc = "Set pin as output." ] SET } impl PIN21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN21W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN21W < 'a > { w : & 'a mut W , } impl < 'a > _PIN21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN21W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN22`" ] pub enum PIN22W { # [ doc = "Set pin as output." ] SET } impl PIN22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN22W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN22W < 'a > { w : & 'a mut W , } impl < 'a > _PIN22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN22W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN23`" ] pub enum PIN23W { # [ doc = "Set pin as output." ] SET } impl PIN23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN23W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN23W < 'a > { w : & 'a mut W , } impl < 'a > _PIN23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN23W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN24`" ] pub enum PIN24W { # [ doc = "Set pin as output." ] SET } impl PIN24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN24W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN24W < 'a > { w : & 'a mut W , } impl < 'a > _PIN24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN24W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN25`" ] pub enum PIN25W { # [ doc = "Set pin as output." ] SET } impl PIN25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN25W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN25W < 'a > { w : & 'a mut W , } impl < 'a > _PIN25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN25W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN26`" ] pub enum PIN26W { # [ doc = "Set pin as output." ] SET } impl PIN26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN26W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN26W < 'a > { w : & 'a mut W , } impl < 'a > _PIN26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN26W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN27`" ] pub enum PIN27W { # [ doc = "Set pin as output." ] SET } impl PIN27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN27W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN27W < 'a > { w : & 'a mut W , } impl < 'a > _PIN27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN27W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN28`" ] pub enum PIN28W { # [ doc = "Set pin as output." ] SET } impl PIN28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN28W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN28W < 'a > { w : & 'a mut W , } impl < 'a > _PIN28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN28W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN29`" ] pub enum PIN29W { # [ doc = "Set pin as output." ] SET } impl PIN29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN29W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN29W < 'a > { w : & 'a mut W , } impl < 'a > _PIN29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN29W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN30`" ] pub enum PIN30W { # [ doc = "Set pin as output." ] SET } impl PIN30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN30W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN30W < 'a > { w : & 'a mut W , } impl < 'a > _PIN30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN30W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN31`" ] pub enum PIN31W { # [ doc = "Set pin as output." ] SET } impl PIN31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN31W :: SET => true } } } # [ doc = r" Proxy" ] pub struct _PIN31W < 'a > { w : & 'a mut W , } impl < 'a > _PIN31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as output." ] # [ inline ] pub fn set ( self ) -> & 'a mut W { self . variant ( PIN31W :: SET ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Set as output pin 0." ] # [ inline ] pub fn pin0 ( & self ) -> PIN0R { PIN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Set as output pin 1." ] # [ inline ] pub fn pin1 ( & self ) -> PIN1R { PIN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Set as output pin 2." ] # [ inline ] pub fn pin2 ( & self ) -> PIN2R { PIN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Set as output pin 3." ] # [ inline ] pub fn pin3 ( & self ) -> PIN3R { PIN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Set as output pin 4." ] # [ inline ] pub fn pin4 ( & self ) -> PIN4R { PIN4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Set as output pin 5." ] # [ inline ] pub fn pin5 ( & self ) -> PIN5R { PIN5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Set as output pin 6." ] # [ inline ] pub fn pin6 ( & self ) -> PIN6R { PIN6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Set as output pin 7." ] # [ inline ] pub fn pin7 ( & self ) -> PIN7R { PIN7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Set as output pin 8." ] # [ inline ] pub fn pin8 ( & self ) -> PIN8R { PIN8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Set as output pin 9." ] # [ inline ] pub fn pin9 ( & self ) -> PIN9R { PIN9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Set as output pin 10." ] # [ inline ] pub fn pin10 ( & self ) -> PIN10R { PIN10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Set as output pin 11." ] # [ inline ] pub fn pin11 ( & self ) -> PIN11R { PIN11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Set as output pin 12." ] # [ inline ] pub fn pin12 ( & self ) -> PIN12R { PIN12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Set as output pin 13." ] # [ inline ] pub fn pin13 ( & self ) -> PIN13R { PIN13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Set as output pin 14." ] # [ inline ] pub fn pin14 ( & self ) -> PIN14R { PIN14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Set as output pin 15." ] # [ inline ] pub fn pin15 ( & self ) -> PIN15R { PIN15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Set as output pin 16." ] # [ inline ] pub fn pin16 ( & self ) -> PIN16R { PIN16R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Set as output pin 17." ] # [ inline ] pub fn pin17 ( & self ) -> PIN17R { PIN17R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Set as output pin 18." ] # [ inline ] pub fn pin18 ( & self ) -> PIN18R { PIN18R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Set as output pin 19." ] # [ inline ] pub fn pin19 ( & self ) -> PIN19R { PIN19R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Set as output pin 20." ] # [ inline ] pub fn pin20 ( & self ) -> PIN20R { PIN20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Set as output pin 21." ] # [ inline ] pub fn pin21 ( & self ) -> PIN21R { PIN21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Set as output pin 22." ] # [ inline ] pub fn pin22 ( & self ) -> PIN22R { PIN22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Set as output pin 23." ] # [ inline ] pub fn pin23 ( & self ) -> PIN23R { PIN23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Set as output pin 24." ] # [ inline ] pub fn pin24 ( & self ) -> PIN24R { PIN24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Set as output pin 25." ] # [ inline ] pub fn pin25 ( & self ) -> PIN25R { PIN25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Set as output pin 26." ] # [ inline ] pub fn pin26 ( & self ) -> PIN26R { PIN26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Set as output pin 27." ] # [ inline ] pub fn pin27 ( & self ) -> PIN27R { PIN27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Set as output pin 28." ] # [ inline ] pub fn pin28 ( & self ) -> PIN28R { PIN28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Set as output pin 29." ] # [ inline ] pub fn pin29 ( & self ) -> PIN29R { PIN29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Set as output pin 30." ] # [ inline ] pub fn pin30 ( & self ) -> PIN30R { PIN30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Set as output pin 31." ] # [ inline ] pub fn pin31 ( & self ) -> PIN31R { PIN31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Set as output pin 0." ] # [ inline ] pub fn pin0 ( & mut self ) -> _PIN0W { _PIN0W { w : self } } # [ doc = "Bit 1 - Set as output pin 1." ] # [ inline ] pub fn pin1 ( & mut self ) -> _PIN1W { _PIN1W { w : self } } # [ doc = "Bit 2 - Set as output pin 2." ] # [ inline ] pub fn pin2 ( & mut self ) -> _PIN2W { _PIN2W { w : self } } # [ doc = "Bit 3 - Set as output pin 3." ] # [ inline ] pub fn pin3 ( & mut self ) -> _PIN3W { _PIN3W { w : self } } # [ doc = "Bit 4 - Set as output pin 4." ] # [ inline ] pub fn pin4 ( & mut self ) -> _PIN4W { _PIN4W { w : self } } # [ doc = "Bit 5 - Set as output pin 5." ] # [ inline ] pub fn pin5 ( & mut self ) -> _PIN5W { _PIN5W { w : self } } # [ doc = "Bit 6 - Set as output pin 6." ] # [ inline ] pub fn pin6 ( & mut self ) -> _PIN6W { _PIN6W { w : self } } # [ doc = "Bit 7 - Set as output pin 7." ] # [ inline ] pub fn pin7 ( & mut self ) -> _PIN7W { _PIN7W { w : self } } # [ doc = "Bit 8 - Set as output pin 8." ] # [ inline ] pub fn pin8 ( & mut self ) -> _PIN8W { _PIN8W { w : self } } # [ doc = "Bit 9 - Set as output pin 9." ] # [ inline ] pub fn pin9 ( & mut self ) -> _PIN9W { _PIN9W { w : self } } # [ doc = "Bit 10 - Set as output pin 10." ] # [ inline ] pub fn pin10 ( & mut self ) -> _PIN10W { _PIN10W { w : self } } # [ doc = "Bit 11 - Set as output pin 11." ] # [ inline ] pub fn pin11 ( & mut self ) -> _PIN11W { _PIN11W { w : self } } # [ doc = "Bit 12 - Set as output pin 12." ] # [ inline ] pub fn pin12 ( & mut self ) -> _PIN12W { _PIN12W { w : self } } # [ doc = "Bit 13 - Set as output pin 13." ] # [ inline ] pub fn pin13 ( & mut self ) -> _PIN13W { _PIN13W { w : self } } # [ doc = "Bit 14 - Set as output pin 14." ] # [ inline ] pub fn pin14 ( & mut self ) -> _PIN14W { _PIN14W { w : self } } # [ doc = "Bit 15 - Set as output pin 15." ] # [ inline ] pub fn pin15 ( & mut self ) -> _PIN15W { _PIN15W { w : self } } # [ doc = "Bit 16 - Set as output pin 16." ] # [ inline ] pub fn pin16 ( & mut self ) -> _PIN16W { _PIN16W { w : self } } # [ doc = "Bit 17 - Set as output pin 17." ] # [ inline ] pub fn pin17 ( & mut self ) -> _PIN17W { _PIN17W { w : self } } # [ doc = "Bit 18 - Set as output pin 18." ] # [ inline ] pub fn pin18 ( & mut self ) -> _PIN18W { _PIN18W { w : self } } # [ doc = "Bit 19 - Set as output pin 19." ] # [ inline ] pub fn pin19 ( & mut self ) -> _PIN19W { _PIN19W { w : self } } # [ doc = "Bit 20 - Set as output pin 20." ] # [ inline ] pub fn pin20 ( & mut self ) -> _PIN20W { _PIN20W { w : self } } # [ doc = "Bit 21 - Set as output pin 21." ] # [ inline ] pub fn pin21 ( & mut self ) -> _PIN21W { _PIN21W { w : self } } # [ doc = "Bit 22 - Set as output pin 22." ] # [ inline ] pub fn pin22 ( & mut self ) -> _PIN22W { _PIN22W { w : self } } # [ doc = "Bit 23 - Set as output pin 23." ] # [ inline ] pub fn pin23 ( & mut self ) -> _PIN23W { _PIN23W { w : self } } # [ doc = "Bit 24 - Set as output pin 24." ] # [ inline ] pub fn pin24 ( & mut self ) -> _PIN24W { _PIN24W { w : self } } # [ doc = "Bit 25 - Set as output pin 25." ] # [ inline ] pub fn pin25 ( & mut self ) -> _PIN25W { _PIN25W { w : self } } # [ doc = "Bit 26 - Set as output pin 26." ] # [ inline ] pub fn pin26 ( & mut self ) -> _PIN26W { _PIN26W { w : self } } # [ doc = "Bit 27 - Set as output pin 27." ] # [ inline ] pub fn pin27 ( & mut self ) -> _PIN27W { _PIN27W { w : self } } # [ doc = "Bit 28 - Set as output pin 28." ] # [ inline ] pub fn pin28 ( & mut self ) -> _PIN28W { _PIN28W { w : self } } # [ doc = "Bit 29 - Set as output pin 29." ] # [ inline ] pub fn pin29 ( & mut self ) -> _PIN29W { _PIN29W { w : self } } # [ doc = "Bit 30 - Set as output pin 30." ] # [ inline ] pub fn pin30 ( & mut self ) -> _PIN30W { _PIN30W { w : self } } # [ doc = "Bit 31 - Set as output pin 31." ] # [ inline ] pub fn pin31 ( & mut self ) -> _PIN31W { _PIN31W { w : self } } } } # [ doc = "DIR clear register." ] pub struct DIRCLR { register : :: vcell :: VolatileCell < u32 > } # [ doc = "DIR clear register." ] pub mod dirclr { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: DIRCLR { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `PIN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN0R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN0R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN0R :: INPUT => false , PIN0R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN0R { match value { false => PIN0R :: INPUT , true => PIN0R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN0R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN0R :: OUTPUT } } # [ doc = "Possible values of the field `PIN1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN1R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN1R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN1R :: INPUT => false , PIN1R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN1R { match value { false => PIN1R :: INPUT , true => PIN1R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN1R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN1R :: OUTPUT } } # [ doc = "Possible values of the field `PIN2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN2R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN2R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN2R :: INPUT => false , PIN2R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN2R { match value { false => PIN2R :: INPUT , true => PIN2R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN2R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN2R :: OUTPUT } } # [ doc = "Possible values of the field `PIN3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN3R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN3R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN3R :: INPUT => false , PIN3R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN3R { match value { false => PIN3R :: INPUT , true => PIN3R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN3R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN3R :: OUTPUT } } # [ doc = "Possible values of the field `PIN4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN4R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN4R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN4R :: INPUT => false , PIN4R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN4R { match value { false => PIN4R :: INPUT , true => PIN4R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN4R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN4R :: OUTPUT } } # [ doc = "Possible values of the field `PIN5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN5R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN5R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN5R :: INPUT => false , PIN5R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN5R { match value { false => PIN5R :: INPUT , true => PIN5R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN5R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN5R :: OUTPUT } } # [ doc = "Possible values of the field `PIN6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN6R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN6R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN6R :: INPUT => false , PIN6R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN6R { match value { false => PIN6R :: INPUT , true => PIN6R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN6R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN6R :: OUTPUT } } # [ doc = "Possible values of the field `PIN7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN7R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN7R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN7R :: INPUT => false , PIN7R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN7R { match value { false => PIN7R :: INPUT , true => PIN7R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN7R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN7R :: OUTPUT } } # [ doc = "Possible values of the field `PIN8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN8R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN8R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN8R :: INPUT => false , PIN8R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN8R { match value { false => PIN8R :: INPUT , true => PIN8R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN8R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN8R :: OUTPUT } } # [ doc = "Possible values of the field `PIN9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN9R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN9R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN9R :: INPUT => false , PIN9R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN9R { match value { false => PIN9R :: INPUT , true => PIN9R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN9R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN9R :: OUTPUT } } # [ doc = "Possible values of the field `PIN10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN10R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN10R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN10R :: INPUT => false , PIN10R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN10R { match value { false => PIN10R :: INPUT , true => PIN10R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN10R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN10R :: OUTPUT } } # [ doc = "Possible values of the field `PIN11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN11R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN11R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN11R :: INPUT => false , PIN11R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN11R { match value { false => PIN11R :: INPUT , true => PIN11R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN11R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN11R :: OUTPUT } } # [ doc = "Possible values of the field `PIN12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN12R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN12R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN12R :: INPUT => false , PIN12R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN12R { match value { false => PIN12R :: INPUT , true => PIN12R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN12R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN12R :: OUTPUT } } # [ doc = "Possible values of the field `PIN13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN13R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN13R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN13R :: INPUT => false , PIN13R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN13R { match value { false => PIN13R :: INPUT , true => PIN13R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN13R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN13R :: OUTPUT } } # [ doc = "Possible values of the field `PIN14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN14R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN14R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN14R :: INPUT => false , PIN14R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN14R { match value { false => PIN14R :: INPUT , true => PIN14R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN14R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN14R :: OUTPUT } } # [ doc = "Possible values of the field `PIN15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN15R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN15R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN15R :: INPUT => false , PIN15R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN15R { match value { false => PIN15R :: INPUT , true => PIN15R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN15R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN15R :: OUTPUT } } # [ doc = "Possible values of the field `PIN16`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN16R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN16R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN16R :: INPUT => false , PIN16R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN16R { match value { false => PIN16R :: INPUT , true => PIN16R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN16R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN16R :: OUTPUT } } # [ doc = "Possible values of the field `PIN17`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN17R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN17R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN17R :: INPUT => false , PIN17R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN17R { match value { false => PIN17R :: INPUT , true => PIN17R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN17R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN17R :: OUTPUT } } # [ doc = "Possible values of the field `PIN18`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN18R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN18R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN18R :: INPUT => false , PIN18R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN18R { match value { false => PIN18R :: INPUT , true => PIN18R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN18R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN18R :: OUTPUT } } # [ doc = "Possible values of the field `PIN19`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN19R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN19R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN19R :: INPUT => false , PIN19R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN19R { match value { false => PIN19R :: INPUT , true => PIN19R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN19R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN19R :: OUTPUT } } # [ doc = "Possible values of the field `PIN20`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN20R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN20R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN20R :: INPUT => false , PIN20R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN20R { match value { false => PIN20R :: INPUT , true => PIN20R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN20R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN20R :: OUTPUT } } # [ doc = "Possible values of the field `PIN21`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN21R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN21R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN21R :: INPUT => false , PIN21R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN21R { match value { false => PIN21R :: INPUT , true => PIN21R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN21R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN21R :: OUTPUT } } # [ doc = "Possible values of the field `PIN22`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN22R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN22R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN22R :: INPUT => false , PIN22R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN22R { match value { false => PIN22R :: INPUT , true => PIN22R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN22R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN22R :: OUTPUT } } # [ doc = "Possible values of the field `PIN23`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN23R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN23R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN23R :: INPUT => false , PIN23R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN23R { match value { false => PIN23R :: INPUT , true => PIN23R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN23R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN23R :: OUTPUT } } # [ doc = "Possible values of the field `PIN24`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN24R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN24R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN24R :: INPUT => false , PIN24R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN24R { match value { false => PIN24R :: INPUT , true => PIN24R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN24R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN24R :: OUTPUT } } # [ doc = "Possible values of the field `PIN25`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN25R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN25R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN25R :: INPUT => false , PIN25R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN25R { match value { false => PIN25R :: INPUT , true => PIN25R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN25R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN25R :: OUTPUT } } # [ doc = "Possible values of the field `PIN26`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN26R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN26R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN26R :: INPUT => false , PIN26R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN26R { match value { false => PIN26R :: INPUT , true => PIN26R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN26R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN26R :: OUTPUT } } # [ doc = "Possible values of the field `PIN27`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN27R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN27R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN27R :: INPUT => false , PIN27R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN27R { match value { false => PIN27R :: INPUT , true => PIN27R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN27R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN27R :: OUTPUT } } # [ doc = "Possible values of the field `PIN28`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN28R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN28R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN28R :: INPUT => false , PIN28R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN28R { match value { false => PIN28R :: INPUT , true => PIN28R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN28R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN28R :: OUTPUT } } # [ doc = "Possible values of the field `PIN29`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN29R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN29R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN29R :: INPUT => false , PIN29R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN29R { match value { false => PIN29R :: INPUT , true => PIN29R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN29R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN29R :: OUTPUT } } # [ doc = "Possible values of the field `PIN30`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN30R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN30R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN30R :: INPUT => false , PIN30R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN30R { match value { false => PIN30R :: INPUT , true => PIN30R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN30R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN30R :: OUTPUT } } # [ doc = "Possible values of the field `PIN31`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PIN31R { # [ doc = "Pin set as input." ] INPUT , # [ doc = "Pin set as output." ] OUTPUT } impl PIN31R { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { PIN31R :: INPUT => false , PIN31R :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> PIN31R { match value { false => PIN31R :: INPUT , true => PIN31R :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == PIN31R :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == PIN31R :: OUTPUT } } # [ doc = "Values that can be written to the field `PIN0`" ] pub enum PIN0W { # [ doc = "Set pin as input." ] CLEAR } impl PIN0W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN0W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN0W < 'a > { w : & 'a mut W , } impl < 'a > _PIN0W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN0W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN0W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN1`" ] pub enum PIN1W { # [ doc = "Set pin as input." ] CLEAR } impl PIN1W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN1W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN1W < 'a > { w : & 'a mut W , } impl < 'a > _PIN1W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN1W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN1W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN2`" ] pub enum PIN2W { # [ doc = "Set pin as input." ] CLEAR } impl PIN2W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN2W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN2W < 'a > { w : & 'a mut W , } impl < 'a > _PIN2W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN2W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN2W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN3`" ] pub enum PIN3W { # [ doc = "Set pin as input." ] CLEAR } impl PIN3W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN3W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN3W < 'a > { w : & 'a mut W , } impl < 'a > _PIN3W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN3W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN3W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 3 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN4`" ] pub enum PIN4W { # [ doc = "Set pin as input." ] CLEAR } impl PIN4W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN4W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN4W < 'a > { w : & 'a mut W , } impl < 'a > _PIN4W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN4W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN4W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 4 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN5`" ] pub enum PIN5W { # [ doc = "Set pin as input." ] CLEAR } impl PIN5W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN5W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN5W < 'a > { w : & 'a mut W , } impl < 'a > _PIN5W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN5W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN5W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 5 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN6`" ] pub enum PIN6W { # [ doc = "Set pin as input." ] CLEAR } impl PIN6W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN6W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN6W < 'a > { w : & 'a mut W , } impl < 'a > _PIN6W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN6W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN6W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 6 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN7`" ] pub enum PIN7W { # [ doc = "Set pin as input." ] CLEAR } impl PIN7W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN7W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN7W < 'a > { w : & 'a mut W , } impl < 'a > _PIN7W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN7W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN7W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 7 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN8`" ] pub enum PIN8W { # [ doc = "Set pin as input." ] CLEAR } impl PIN8W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN8W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN8W < 'a > { w : & 'a mut W , } impl < 'a > _PIN8W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN8W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN8W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN9`" ] pub enum PIN9W { # [ doc = "Set pin as input." ] CLEAR } impl PIN9W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN9W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN9W < 'a > { w : & 'a mut W , } impl < 'a > _PIN9W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN9W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN9W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 9 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN10`" ] pub enum PIN10W { # [ doc = "Set pin as input." ] CLEAR } impl PIN10W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN10W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN10W < 'a > { w : & 'a mut W , } impl < 'a > _PIN10W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN10W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN10W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 10 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN11`" ] pub enum PIN11W { # [ doc = "Set pin as input." ] CLEAR } impl PIN11W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN11W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN11W < 'a > { w : & 'a mut W , } impl < 'a > _PIN11W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN11W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN11W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 11 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN12`" ] pub enum PIN12W { # [ doc = "Set pin as input." ] CLEAR } impl PIN12W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN12W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN12W < 'a > { w : & 'a mut W , } impl < 'a > _PIN12W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN12W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN12W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 12 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN13`" ] pub enum PIN13W { # [ doc = "Set pin as input." ] CLEAR } impl PIN13W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN13W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN13W < 'a > { w : & 'a mut W , } impl < 'a > _PIN13W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN13W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN13W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 13 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN14`" ] pub enum PIN14W { # [ doc = "Set pin as input." ] CLEAR } impl PIN14W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN14W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN14W < 'a > { w : & 'a mut W , } impl < 'a > _PIN14W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN14W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN14W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 14 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN15`" ] pub enum PIN15W { # [ doc = "Set pin as input." ] CLEAR } impl PIN15W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN15W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN15W < 'a > { w : & 'a mut W , } impl < 'a > _PIN15W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN15W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN15W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 15 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN16`" ] pub enum PIN16W { # [ doc = "Set pin as input." ] CLEAR } impl PIN16W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN16W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN16W < 'a > { w : & 'a mut W , } impl < 'a > _PIN16W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN16W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN16W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN17`" ] pub enum PIN17W { # [ doc = "Set pin as input." ] CLEAR } impl PIN17W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN17W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN17W < 'a > { w : & 'a mut W , } impl < 'a > _PIN17W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN17W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN17W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 17 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN18`" ] pub enum PIN18W { # [ doc = "Set pin as input." ] CLEAR } impl PIN18W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN18W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN18W < 'a > { w : & 'a mut W , } impl < 'a > _PIN18W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN18W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN18W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 18 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN19`" ] pub enum PIN19W { # [ doc = "Set pin as input." ] CLEAR } impl PIN19W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN19W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN19W < 'a > { w : & 'a mut W , } impl < 'a > _PIN19W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN19W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN19W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 19 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN20`" ] pub enum PIN20W { # [ doc = "Set pin as input." ] CLEAR } impl PIN20W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN20W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN20W < 'a > { w : & 'a mut W , } impl < 'a > _PIN20W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN20W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN20W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 20 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN21`" ] pub enum PIN21W { # [ doc = "Set pin as input." ] CLEAR } impl PIN21W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN21W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN21W < 'a > { w : & 'a mut W , } impl < 'a > _PIN21W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN21W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN21W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 21 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN22`" ] pub enum PIN22W { # [ doc = "Set pin as input." ] CLEAR } impl PIN22W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN22W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN22W < 'a > { w : & 'a mut W , } impl < 'a > _PIN22W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN22W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN22W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 22 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN23`" ] pub enum PIN23W { # [ doc = "Set pin as input." ] CLEAR } impl PIN23W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN23W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN23W < 'a > { w : & 'a mut W , } impl < 'a > _PIN23W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN23W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN23W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 23 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN24`" ] pub enum PIN24W { # [ doc = "Set pin as input." ] CLEAR } impl PIN24W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN24W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN24W < 'a > { w : & 'a mut W , } impl < 'a > _PIN24W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN24W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN24W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 24 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN25`" ] pub enum PIN25W { # [ doc = "Set pin as input." ] CLEAR } impl PIN25W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN25W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN25W < 'a > { w : & 'a mut W , } impl < 'a > _PIN25W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN25W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN25W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 25 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN26`" ] pub enum PIN26W { # [ doc = "Set pin as input." ] CLEAR } impl PIN26W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN26W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN26W < 'a > { w : & 'a mut W , } impl < 'a > _PIN26W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN26W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN26W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 26 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN27`" ] pub enum PIN27W { # [ doc = "Set pin as input." ] CLEAR } impl PIN27W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN27W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN27W < 'a > { w : & 'a mut W , } impl < 'a > _PIN27W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN27W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN27W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 27 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN28`" ] pub enum PIN28W { # [ doc = "Set pin as input." ] CLEAR } impl PIN28W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN28W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN28W < 'a > { w : & 'a mut W , } impl < 'a > _PIN28W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN28W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN28W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 28 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN29`" ] pub enum PIN29W { # [ doc = "Set pin as input." ] CLEAR } impl PIN29W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN29W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN29W < 'a > { w : & 'a mut W , } impl < 'a > _PIN29W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN29W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN29W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 29 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN30`" ] pub enum PIN30W { # [ doc = "Set pin as input." ] CLEAR } impl PIN30W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN30W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN30W < 'a > { w : & 'a mut W , } impl < 'a > _PIN30W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN30W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN30W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 30 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PIN31`" ] pub enum PIN31W { # [ doc = "Set pin as input." ] CLEAR } impl PIN31W { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { PIN31W :: CLEAR => true } } } # [ doc = r" Proxy" ] pub struct _PIN31W < 'a > { w : & 'a mut W , } impl < 'a > _PIN31W < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PIN31W ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Set pin as input." ] # [ inline ] pub fn clear ( self ) -> & 'a mut W { self . variant ( PIN31W :: CLEAR ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 31 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Set as input pin 0." ] # [ inline ] pub fn pin0 ( & self ) -> PIN0R { PIN0R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Set as input pin 1." ] # [ inline ] pub fn pin1 ( & self ) -> PIN1R { PIN1R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 2 - Set as input pin 2." ] # [ inline ] pub fn pin2 ( & self ) -> PIN2R { PIN2R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 3 - Set as input pin 3." ] # [ inline ] pub fn pin3 ( & self ) -> PIN3R { PIN3R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 3 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 4 - Set as input pin 4." ] # [ inline ] pub fn pin4 ( & self ) -> PIN4R { PIN4R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 4 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 5 - Set as input pin 5." ] # [ inline ] pub fn pin5 ( & self ) -> PIN5R { PIN5R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 5 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 6 - Set as input pin 6." ] # [ inline ] pub fn pin6 ( & self ) -> PIN6R { PIN6R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 6 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 7 - Set as input pin 7." ] # [ inline ] pub fn pin7 ( & self ) -> PIN7R { PIN7R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 7 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 8 - Set as input pin 8." ] # [ inline ] pub fn pin8 ( & self ) -> PIN8R { PIN8R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 9 - Set as input pin 9." ] # [ inline ] pub fn pin9 ( & self ) -> PIN9R { PIN9R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 9 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 10 - Set as input pin 10." ] # [ inline ] pub fn pin10 ( & self ) -> PIN10R { PIN10R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 10 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 11 - Set as input pin 11." ] # [ inline ] pub fn pin11 ( & self ) -> PIN11R { PIN11R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 11 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 12 - Set as input pin 12." ] # [ inline ] pub fn pin12 ( & self ) -> PIN12R { PIN12R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 12 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 13 - Set as input pin 13." ] # [ inline ] pub fn pin13 ( & self ) -> PIN13R { PIN13R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 13 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 14 - Set as input pin 14." ] # [ inline ] pub fn pin14 ( & self ) -> PIN14R { PIN14R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 14 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 15 - Set as input pin 15." ] # [ inline ] pub fn pin15 ( & self ) -> PIN15R { PIN15R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 15 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 16 - Set as input pin 16." ] # [ inline ] pub fn pin16 ( & self ) -> PIN16R { PIN16R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 17 - Set as input pin 17." ] # [ inline ] pub fn pin17 ( & self ) -> PIN17R { PIN17R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 17 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 18 - Set as input pin 18." ] # [ inline ] pub fn pin18 ( & self ) -> PIN18R { PIN18R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 18 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 19 - Set as input pin 19." ] # [ inline ] pub fn pin19 ( & self ) -> PIN19R { PIN19R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 19 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 20 - Set as input pin 20." ] # [ inline ] pub fn pin20 ( & self ) -> PIN20R { PIN20R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 20 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 21 - Set as input pin 21." ] # [ inline ] pub fn pin21 ( & self ) -> PIN21R { PIN21R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 21 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 22 - Set as input pin 22." ] # [ inline ] pub fn pin22 ( & self ) -> PIN22R { PIN22R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 22 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 23 - Set as input pin 23." ] # [ inline ] pub fn pin23 ( & self ) -> PIN23R { PIN23R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 23 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 24 - Set as input pin 24." ] # [ inline ] pub fn pin24 ( & self ) -> PIN24R { PIN24R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 24 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 25 - Set as input pin 25." ] # [ inline ] pub fn pin25 ( & self ) -> PIN25R { PIN25R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 25 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 26 - Set as input pin 26." ] # [ inline ] pub fn pin26 ( & self ) -> PIN26R { PIN26R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 26 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 27 - Set as input pin 27." ] # [ inline ] pub fn pin27 ( & self ) -> PIN27R { PIN27R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 27 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 28 - Set as input pin 28." ] # [ inline ] pub fn pin28 ( & self ) -> PIN28R { PIN28R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 28 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 29 - Set as input pin 29." ] # [ inline ] pub fn pin29 ( & self ) -> PIN29R { PIN29R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 29 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 30 - Set as input pin 30." ] # [ inline ] pub fn pin30 ( & self ) -> PIN30R { PIN30R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 30 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 31 - Set as input pin 31." ] # [ inline ] pub fn pin31 ( & self ) -> PIN31R { PIN31R :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 31 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Set as input pin 0." ] # [ inline ] pub fn pin0 ( & mut self ) -> _PIN0W { _PIN0W { w : self } } # [ doc = "Bit 1 - Set as input pin 1." ] # [ inline ] pub fn pin1 ( & mut self ) -> _PIN1W { _PIN1W { w : self } } # [ doc = "Bit 2 - Set as input pin 2." ] # [ inline ] pub fn pin2 ( & mut self ) -> _PIN2W { _PIN2W { w : self } } # [ doc = "Bit 3 - Set as input pin 3." ] # [ inline ] pub fn pin3 ( & mut self ) -> _PIN3W { _PIN3W { w : self } } # [ doc = "Bit 4 - Set as input pin 4." ] # [ inline ] pub fn pin4 ( & mut self ) -> _PIN4W { _PIN4W { w : self } } # [ doc = "Bit 5 - Set as input pin 5." ] # [ inline ] pub fn pin5 ( & mut self ) -> _PIN5W { _PIN5W { w : self } } # [ doc = "Bit 6 - Set as input pin 6." ] # [ inline ] pub fn pin6 ( & mut self ) -> _PIN6W { _PIN6W { w : self } } # [ doc = "Bit 7 - Set as input pin 7." ] # [ inline ] pub fn pin7 ( & mut self ) -> _PIN7W { _PIN7W { w : self } } # [ doc = "Bit 8 - Set as input pin 8." ] # [ inline ] pub fn pin8 ( & mut self ) -> _PIN8W { _PIN8W { w : self } } # [ doc = "Bit 9 - Set as input pin 9." ] # [ inline ] pub fn pin9 ( & mut self ) -> _PIN9W { _PIN9W { w : self } } # [ doc = "Bit 10 - Set as input pin 10." ] # [ inline ] pub fn pin10 ( & mut self ) -> _PIN10W { _PIN10W { w : self } } # [ doc = "Bit 11 - Set as input pin 11." ] # [ inline ] pub fn pin11 ( & mut self ) -> _PIN11W { _PIN11W { w : self } } # [ doc = "Bit 12 - Set as input pin 12." ] # [ inline ] pub fn pin12 ( & mut self ) -> _PIN12W { _PIN12W { w : self } } # [ doc = "Bit 13 - Set as input pin 13." ] # [ inline ] pub fn pin13 ( & mut self ) -> _PIN13W { _PIN13W { w : self } } # [ doc = "Bit 14 - Set as input pin 14." ] # [ inline ] pub fn pin14 ( & mut self ) -> _PIN14W { _PIN14W { w : self } } # [ doc = "Bit 15 - Set as input pin 15." ] # [ inline ] pub fn pin15 ( & mut self ) -> _PIN15W { _PIN15W { w : self } } # [ doc = "Bit 16 - Set as input pin 16." ] # [ inline ] pub fn pin16 ( & mut self ) -> _PIN16W { _PIN16W { w : self } } # [ doc = "Bit 17 - Set as input pin 17." ] # [ inline ] pub fn pin17 ( & mut self ) -> _PIN17W { _PIN17W { w : self } } # [ doc = "Bit 18 - Set as input pin 18." ] # [ inline ] pub fn pin18 ( & mut self ) -> _PIN18W { _PIN18W { w : self } } # [ doc = "Bit 19 - Set as input pin 19." ] # [ inline ] pub fn pin19 ( & mut self ) -> _PIN19W { _PIN19W { w : self } } # [ doc = "Bit 20 - Set as input pin 20." ] # [ inline ] pub fn pin20 ( & mut self ) -> _PIN20W { _PIN20W { w : self } } # [ doc = "Bit 21 - Set as input pin 21." ] # [ inline ] pub fn pin21 ( & mut self ) -> _PIN21W { _PIN21W { w : self } } # [ doc = "Bit 22 - Set as input pin 22." ] # [ inline ] pub fn pin22 ( & mut self ) -> _PIN22W { _PIN22W { w : self } } # [ doc = "Bit 23 - Set as input pin 23." ] # [ inline ] pub fn pin23 ( & mut self ) -> _PIN23W { _PIN23W { w : self } } # [ doc = "Bit 24 - Set as input pin 24." ] # [ inline ] pub fn pin24 ( & mut self ) -> _PIN24W { _PIN24W { w : self } } # [ doc = "Bit 25 - Set as input pin 25." ] # [ inline ] pub fn pin25 ( & mut self ) -> _PIN25W { _PIN25W { w : self } } # [ doc = "Bit 26 - Set as input pin 26." ] # [ inline ] pub fn pin26 ( & mut self ) -> _PIN26W { _PIN26W { w : self } } # [ doc = "Bit 27 - Set as input pin 27." ] # [ inline ] pub fn pin27 ( & mut self ) -> _PIN27W { _PIN27W { w : self } } # [ doc = "Bit 28 - Set as input pin 28." ] # [ inline ] pub fn pin28 ( & mut self ) -> _PIN28W { _PIN28W { w : self } } # [ doc = "Bit 29 - Set as input pin 29." ] # [ inline ] pub fn pin29 ( & mut self ) -> _PIN29W { _PIN29W { w : self } } # [ doc = "Bit 30 - Set as input pin 30." ] # [ inline ] pub fn pin30 ( & mut self ) -> _PIN30W { _PIN30W { w : self } } # [ doc = "Bit 31 - Set as input pin 31." ] # [ inline ] pub fn pin31 ( & mut self ) -> _PIN31W { _PIN31W { w : self } } } } # [ doc = "Configuration of GPIO pins." ] pub struct PIN_CNF { register : :: vcell :: VolatileCell < u32 > } # [ doc = "Configuration of GPIO pins." ] pub mod pin_cnf { # [ doc = r" Value read from the register" ] pub struct R { bits : u32 , } # [ doc = r" Value to write to the register" ] pub struct W { bits : u32 , } impl super :: PIN_CNF { # [ doc = r" Modifies the contents of the register" ] # [ inline ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R , & 'w mut W ) -> & 'w mut W { let bits = self . register . get ( ) ; let r = R { bits : bits } ; let mut w = W { bits : bits } ; f ( & r , & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Reads the contents of the register" ] # [ inline ] pub fn read ( & self ) -> R { R { bits : self . register . get ( ) } } # [ doc = r" Writes to the register" ] # [ inline ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W ) -> & mut W { let mut w = W :: reset_value ( ) ; f ( & mut w ) ; self . register . set ( w . bits ) ; } # [ doc = r" Writes the reset value to the register" ] # [ inline ] pub fn reset ( & self ) { self . write ( | w | w ) } } # [ doc = "Possible values of the field `DIR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DIRR { # [ doc = "Configure pin as an input pin." ] INPUT , # [ doc = "Configure pin as an output pin." ] OUTPUT } impl DIRR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { DIRR :: INPUT => false , DIRR :: OUTPUT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> DIRR { match value { false => DIRR :: INPUT , true => DIRR :: OUTPUT , } } # [ doc = "Checks if the value of the field is `INPUT`" ] # [ inline ] pub fn is_input ( & self ) -> bool { * self == DIRR :: INPUT } # [ doc = "Checks if the value of the field is `OUTPUT`" ] # [ inline ] pub fn is_output ( & self ) -> bool { * self == DIRR :: OUTPUT } } # [ doc = "Possible values of the field `INPUT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INPUTR { # [ doc = "Connect input pin." ] CONNECT , # [ doc = "Disconnect input pin." ] DISCONNECT } impl INPUTR { # [ doc = r" Returns `true` if the bit is clear (0)" ] # [ inline ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = r" Returns `true` if the bit is set (1)" ] # [ inline ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bit ( & self ) -> bool { match * self { INPUTR :: CONNECT => false , INPUTR :: DISCONNECT => true } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : bool ) -> INPUTR { match value { false => INPUTR :: CONNECT , true => INPUTR :: DISCONNECT , } } # [ doc = "Checks if the value of the field is `CONNECT`" ] # [ inline ] pub fn is_connect ( & self ) -> bool { * self == INPUTR :: CONNECT } # [ doc = "Checks if the value of the field is `DISCONNECT`" ] # [ inline ] pub fn is_disconnect ( & self ) -> bool { * self == INPUTR :: DISCONNECT } } # [ doc = "Possible values of the field `PULL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PULLR { # [ doc = "No pull." ] DISABLED , # [ doc = "Pulldown on pin." ] PULLDOWN , # [ doc = "Pullup on pin." ] PULLUP , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl PULLR { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { PULLR :: DISABLED => 0 , PULLR :: PULLDOWN => 0x01 , PULLR :: PULLUP => 0x03 , PULLR :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> PULLR { match value { 0 => PULLR :: DISABLED , 1 => PULLR :: PULLDOWN , 3 => PULLR :: PULLUP , i => PULLR :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == PULLR :: DISABLED } # [ doc = "Checks if the value of the field is `PULLDOWN`" ] # [ inline ] pub fn is_pulldown ( & self ) -> bool { * self == PULLR :: PULLDOWN } # [ doc = "Checks if the value of the field is `PULLUP`" ] # [ inline ] pub fn is_pullup ( & self ) -> bool { * self == PULLR :: PULLUP } } # [ doc = "Possible values of the field `DRIVE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DRIVER { # [ doc = "Standard '0', Standard '1'." ] S0S1 , # [ doc = "High '0', Standard '1'." ] H0S1 , # [ doc = "Standard '0', High '1'." ] S0H1 , # [ doc = "High '0', High '1'." ] H0H1 , # [ doc = "Disconnected '0', Standard '1'." ] D0S1 , # [ doc = "Disconnected '0', High '1'." ] D0H1 , # [ doc = "Standard '0', Disconnected '1'." ] S0D1 , # [ doc = "High '0', Disconnected '1'." ] H0D1 } impl DRIVER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { DRIVER :: S0S1 => 0 , DRIVER :: H0S1 => 0x01 , DRIVER :: S0H1 => 0x02 , DRIVER :: H0H1 => 0x03 , DRIVER :: D0S1 => 0x04 , DRIVER :: D0H1 => 0x05 , DRIVER :: S0D1 => 0x06 , DRIVER :: H0D1 => 0x07 } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> DRIVER { match value { 0 => DRIVER :: S0S1 , 1 => DRIVER :: H0S1 , 2 => DRIVER :: S0H1 , 3 => DRIVER :: H0H1 , 4 => DRIVER :: D0S1 , 5 => DRIVER :: D0H1 , 6 => DRIVER :: S0D1 , 7 => DRIVER :: H0D1 , _ => unreachable ! ( ) , } } # [ doc = "Checks if the value of the field is `S0S1`" ] # [ inline ] pub fn is_s0s1 ( & self ) -> bool { * self == DRIVER :: S0S1 } # [ doc = "Checks if the value of the field is `H0S1`" ] # [ inline ] pub fn is_h0s1 ( & self ) -> bool { * self == DRIVER :: H0S1 } # [ doc = "Checks if the value of the field is `S0H1`" ] # [ inline ] pub fn is_s0h1 ( & self ) -> bool { * self == DRIVER :: S0H1 } # [ doc = "Checks if the value of the field is `H0H1`" ] # [ inline ] pub fn is_h0h1 ( & self ) -> bool { * self == DRIVER :: H0H1 } # [ doc = "Checks if the value of the field is `D0S1`" ] # [ inline ] pub fn is_d0s1 ( & self ) -> bool { * self == DRIVER :: D0S1 } # [ doc = "Checks if the value of the field is `D0H1`" ] # [ inline ] pub fn is_d0h1 ( & self ) -> bool { * self == DRIVER :: D0H1 } # [ doc = "Checks if the value of the field is `S0D1`" ] # [ inline ] pub fn is_s0d1 ( & self ) -> bool { * self == DRIVER :: S0D1 } # [ doc = "Checks if the value of the field is `H0D1`" ] # [ inline ] pub fn is_h0d1 ( & self ) -> bool { * self == DRIVER :: H0D1 } } # [ doc = "Possible values of the field `SENSE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SENSER { # [ doc = "Disabled." ] DISABLED , # [ doc = "Wakeup on high level." ] HIGH , # [ doc = "Wakeup on low level." ] LOW , # [ doc = r" Reserved" ] _Reserved ( u8 ) } impl SENSER { # [ doc = r" Value of the field as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u8 { match * self { SENSER :: DISABLED => 0 , SENSER :: HIGH => 0x02 , SENSER :: LOW => 0x03 , SENSER :: _Reserved ( bits ) => bits } } # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _from ( value : u8 ) -> SENSER { match value { 0 => SENSER :: DISABLED , 2 => SENSER :: HIGH , 3 => SENSER :: LOW , i => SENSER :: _Reserved ( i ) , } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ] pub fn is_disabled ( & self ) -> bool { * self == SENSER :: DISABLED } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ] pub fn is_high ( & self ) -> bool { * self == SENSER :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ] pub fn is_low ( & self ) -> bool { * self == SENSER :: LOW } } # [ doc = "Values that can be written to the field `DIR`" ] pub enum DIRW { # [ doc = "Configure pin as an input pin." ] INPUT , # [ doc = "Configure pin as an output pin." ] OUTPUT } impl DIRW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { DIRW :: INPUT => false , DIRW :: OUTPUT => true } } } # [ doc = r" Proxy" ] pub struct _DIRW < 'a > { w : & 'a mut W , } impl < 'a > _DIRW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DIRW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Configure pin as an input pin." ] # [ inline ] pub fn input ( self ) -> & 'a mut W { self . variant ( DIRW :: INPUT ) } # [ doc = "Configure pin as an output pin." ] # [ inline ] pub fn output ( self ) -> & 'a mut W { self . variant ( DIRW :: OUTPUT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 0 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `INPUT`" ] pub enum INPUTW { # [ doc = "Connect input pin." ] CONNECT , # [ doc = "Disconnect input pin." ] DISCONNECT } impl INPUTW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> bool { match * self { INPUTW :: CONNECT => false , INPUTW :: DISCONNECT => true } } } # [ doc = r" Proxy" ] pub struct _INPUTW < 'a > { w : & 'a mut W , } impl < 'a > _INPUTW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : INPUTW ) -> & 'a mut W { { self . bit ( variant . _bits ( ) ) } } # [ doc = "Connect input pin." ] # [ inline ] pub fn connect ( self ) -> & 'a mut W { self . variant ( INPUTW :: CONNECT ) } # [ doc = "Disconnect input pin." ] # [ inline ] pub fn disconnect ( self ) -> & 'a mut W { self . variant ( INPUTW :: DISCONNECT ) } # [ doc = r" Sets the field bit" ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r" Clears the field bit" ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bit ( self , value : bool ) -> & 'a mut W { const MASK : bool = true ; const OFFSET : u8 = 1 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `PULL`" ] pub enum PULLW { # [ doc = "No pull." ] DISABLED , # [ doc = "Pulldown on pin." ] PULLDOWN , # [ doc = "Pullup on pin." ] PULLUP } impl PULLW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { PULLW :: DISABLED => 0 , PULLW :: PULLDOWN => 1 , PULLW :: PULLUP => 3 } } } # [ doc = r" Proxy" ] pub struct _PULLW < 'a > { w : & 'a mut W , } impl < 'a > _PULLW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : PULLW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No pull." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( PULLW :: DISABLED ) } # [ doc = "Pulldown on pin." ] # [ inline ] pub fn pulldown ( self ) -> & 'a mut W { self . variant ( PULLW :: PULLDOWN ) } # [ doc = "Pullup on pin." ] # [ inline ] pub fn pullup ( self ) -> & 'a mut W { self . variant ( PULLW :: PULLUP ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `DRIVE`" ] pub enum DRIVEW { # [ doc = "Standard '0', Standard '1'." ] S0S1 , # [ doc = "High '0', Standard '1'." ] H0S1 , # [ doc = "Standard '0', High '1'." ] S0H1 , # [ doc = "High '0', High '1'." ] H0H1 , # [ doc = "Disconnected '0', Standard '1'." ] D0S1 , # [ doc = "Disconnected '0', High '1'." ] D0H1 , # [ doc = "Standard '0', Disconnected '1'." ] S0D1 , # [ doc = "High '0', Disconnected '1'." ] H0D1 } impl DRIVEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { DRIVEW :: S0S1 => 0 , DRIVEW :: H0S1 => 1 , DRIVEW :: S0H1 => 2 , DRIVEW :: H0H1 => 3 , DRIVEW :: D0S1 => 4 , DRIVEW :: D0H1 => 5 , DRIVEW :: S0D1 => 6 , DRIVEW :: H0D1 => 7 } } } # [ doc = r" Proxy" ] pub struct _DRIVEW < 'a > { w : & 'a mut W , } impl < 'a > _DRIVEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : DRIVEW ) -> & 'a mut W { { self . bits ( variant . _bits ( ) ) } } # [ doc = "Standard '0', Standard '1'." ] # [ inline ] pub fn s0s1 ( self ) -> & 'a mut W { self . variant ( DRIVEW :: S0S1 ) } # [ doc = "High '0', Standard '1'." ] # [ inline ] pub fn h0s1 ( self ) -> & 'a mut W { self . variant ( DRIVEW :: H0S1 ) } # [ doc = "Standard '0', High '1'." ] # [ inline ] pub fn s0h1 ( self ) -> & 'a mut W { self . variant ( DRIVEW :: S0H1 ) } # [ doc = "High '0', High '1'." ] # [ inline ] pub fn h0h1 ( self ) -> & 'a mut W { self . variant ( DRIVEW :: H0H1 ) } # [ doc = "Disconnected '0', Standard '1'." ] # [ inline ] pub fn d0s1 ( self ) -> & 'a mut W { self . variant ( DRIVEW :: D0S1 ) } # [ doc = "Disconnected '0', High '1'." ] # [ inline ] pub fn d0h1 ( self ) -> & 'a mut W { self . variant ( DRIVEW :: D0H1 ) } # [ doc = "Standard '0', Disconnected '1'." ] # [ inline ] pub fn s0d1 ( self ) -> & 'a mut W { self . variant ( DRIVEW :: S0D1 ) } # [ doc = "High '0', Disconnected '1'." ] # [ inline ] pub fn h0d1 ( self ) -> & 'a mut W { self . variant ( DRIVEW :: H0D1 ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x07 ; const OFFSET : u8 = 8 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } # [ doc = "Values that can be written to the field `SENSE`" ] pub enum SENSEW { # [ doc = "Disabled." ] DISABLED , # [ doc = "Wakeup on high level." ] HIGH , # [ doc = "Wakeup on low level." ] LOW } impl SENSEW { # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] # [ inline ] pub fn _bits ( & self ) -> u8 { match * self { SENSEW :: DISABLED => 0 , SENSEW :: HIGH => 2 , SENSEW :: LOW => 3 } } } # [ doc = r" Proxy" ] pub struct _SENSEW < 'a > { w : & 'a mut W , } impl < 'a > _SENSEW < 'a > { # [ doc = r" Writes `variant` to the field" ] # [ inline ] pub fn variant ( self , variant : SENSEW ) -> & 'a mut W { unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled." ] # [ inline ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( SENSEW :: DISABLED ) } # [ doc = "Wakeup on high level." ] # [ inline ] pub fn high ( self ) -> & 'a mut W { self . variant ( SENSEW :: HIGH ) } # [ doc = "Wakeup on low level." ] # [ inline ] pub fn low ( self ) -> & 'a mut W { self . variant ( SENSEW :: LOW ) } # [ doc = r" Writes raw bits to the field" ] # [ inline ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { const MASK : u8 = 0x03 ; const OFFSET : u8 = 16 ; self . w . bits &= ! ( ( MASK as u32 ) << OFFSET ) ; self . w . bits |= ( ( value & MASK ) as u32 ) << OFFSET ; self . w } } impl R { # [ doc = r" Value of the register as raw bits" ] # [ inline ] pub fn bits ( & self ) -> u32 { self . bits } # [ doc = "Bit 0 - Pin direction." ] # [ inline ] pub fn dir ( & self ) -> DIRR { DIRR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 0 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bit 1 - Connect or disconnect input path." ] # [ inline ] pub fn input ( & self ) -> INPUTR { INPUTR :: _from ( { const MASK : bool = true ; const OFFSET : u8 = 1 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) != 0 } ) } # [ doc = "Bits 2:3 - Pull-up or -down configuration." ] # [ inline ] pub fn pull ( & self ) -> PULLR { PULLR :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 2 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 8:10 - Drive configuration." ] # [ inline ] pub fn drive ( & self ) -> DRIVER { DRIVER :: _from ( { const MASK : u8 = 0x07 ; const OFFSET : u8 = 8 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } # [ doc = "Bits 16:17 - Pin sensing mechanism." ] # [ inline ] pub fn sense ( & self ) -> SENSER { SENSER :: _from ( { const MASK : u8 = 0x03 ; const OFFSET : u8 = 16 ; ( ( self . bits >> OFFSET ) & MASK as u32 ) as u8 } ) } } impl W { # [ doc = r" Reset value of the register" ] # [ inline ] pub fn reset_value ( ) -> W { W { bits : 0x10 } } # [ doc = r" Writes raw bits to the register" ] # [ inline ] pub unsafe fn bits ( & mut self , bits : u32 ) -> & mut Self { self . bits = bits ; self } # [ doc = "Bit 0 - Pin direction." ] # [ inline ] pub fn dir ( & mut self ) -> _DIRW { _DIRW { w : self } } # [ doc = "Bit 1 - Connect or disconnect input path." ] # [ inline ] pub fn input ( & mut self ) -> _INPUTW { _INPUTW { w : self } } # [ doc = "Bits 2:3 - Pull-up or -down configuration." ] # [ inline ] pub fn pull ( & mut self ) -> _PULLW { _PULLW { w : self } } # [ doc = "Bits 8:10 - Drive configuration." ] # [ inline ] pub fn drive ( & mut self ) -> _DRIVEW { _DRIVEW { w : self } } # [ doc = "Bits 16:17 - Pin sensing mechanism." ] # [ inline ] pub fn sense ( & mut self ) -> _SENSEW { _SENSEW { w : self } } } } } # [ allow ( renamed_and_removed_lints ) ] # [ allow ( private_no_mangle_statics ) ] # [ no_mangle ] static mut DEVICE_PERIPHERALS : bool = false ; # [ doc = r" All the peripherals" ] # [ allow ( non_snake_case ) ] pub struct Peripherals { # [ doc = "POWER" ] pub POWER : POWER , # [ doc = "CLOCK" ] pub CLOCK : CLOCK , # [ doc = "PU" ] pub PU : PU , # [ doc = "RADIO" ] pub RADIO : RADIO , # [ doc = "UART0" ] pub UART0 : UART0 , # [ doc = "SPI0" ] pub SPI0 : SPI0 , # [ doc = "TWI0" ] pub TWI0 : TWI0 , # [ doc = "SPI1" ] pub SPI1 : SPI1 , # [ doc = "TWI1" ] pub TWI1 : TWI1 , # [ doc = "SPIS1" ] pub SPIS1 : SPIS1 , # [ doc = "GPIOTE" ] pub GPIOTE : GPIOTE , # [ doc = "ADC" ] pub ADC : ADC , # [ doc = "TIMER0" ] pub TIMER0 : TIMER0 , # [ doc = "TIMER1" ] pub TIMER1 : TIMER1 , # [ doc = "TIMER2" ] pub TIMER2 : TIMER2 , # [ doc = "RTC0" ] pub RTC0 : RTC0 , # [ doc = "TEMP" ] pub TEMP : TEMP , # [ doc = "RNG" ] pub RNG : RNG , # [ doc = "ECB" ] pub ECB : ECB , # [ doc = "AAR" ] pub AAR : AAR , # [ doc = "CCM" ] pub CCM : CCM , # [ doc = "WDT" ] pub WDT : WDT , # [ doc = "RTC1" ] pub RTC1 : RTC1 , # [ doc = "QDEC" ] pub QDEC : QDEC , # [ doc = "WUCOMP" ] pub WUCOMP : WUCOMP , # [ doc = "COMP" ] pub COMP : COMP , # [ doc = "SWI" ] pub SWI : SWI , # [ doc = "NVMC" ] pub NVMC : NVMC , # [ doc = "PPI" ] pub PPI : PPI , # [ doc = "FICR" ] pub FICR : FICR , # [ doc = "UICR" ] pub UICR : UICR , # [ doc = "GPIO" ] pub GPIO : GPIO , } impl Peripherals { # [ doc = r" Returns all the peripherals *once*" ] # [ inline ] pub fn take ( ) -> Option < Self > { cortex_m :: interrupt :: free ( | _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some ( unsafe { Peripherals :: steal ( ) } ) } } ) } # [ doc = r" Unchecked version of `Peripherals::take`" ] pub unsafe fn steal ( ) -> Self { debug_assert ! ( ! DEVICE_PERIPHERALS ) ; DEVICE_PERIPHERALS = true ; Peripherals { POWER : POWER { _marker : PhantomData } , CLOCK : CLOCK { _marker : PhantomData } , PU : PU { _marker : PhantomData } , RADIO : RADIO { _marker : PhantomData } , UART0 : UART0 { _marker : PhantomData } , SPI0 : SPI0 { _marker : PhantomData } , TWI0 : TWI0 { _marker : PhantomData } , SPI1 : SPI1 { _marker : PhantomData } , TWI1 : TWI1 { _marker : PhantomData } , SPIS1 : SPIS1 { _marker : PhantomData } , GPIOTE : GPIOTE { _marker : PhantomData } , ADC : ADC { _marker : PhantomData } , TIMER0 : TIMER0 { _marker : PhantomData } , TIMER1 : TIMER1 { _marker : PhantomData } , TIMER2 : TIMER2 { _marker : PhantomData } , RTC0 : RTC0 { _marker : PhantomData } , TEMP : TEMP { _marker : PhantomData } , RNG : RNG { _marker : PhantomData } , ECB : ECB { _marker : PhantomData } , AAR : AAR { _marker : PhantomData } , CCM : CCM { _marker : PhantomData } , WDT : WDT { _marker : PhantomData } , RTC1 : RTC1 { _marker : PhantomData } , QDEC : QDEC { _marker : PhantomData } , WUCOMP : WUCOMP { _marker : PhantomData } , COMP : COMP { _marker : PhantomData } , SWI : SWI { _marker : PhantomData } , NVMC : NVMC { _marker : PhantomData } , PPI : PPI { _marker : PhantomData } , FICR : FICR { _marker : PhantomData } , UICR : UICR { _marker : PhantomData } , GPIO : GPIO { _marker : PhantomData } , } } }
